%MODULE SWFIN <MAIN>;
***************************************************************
*                                                             *
* Copyright (c) 2007 by ACI Worldwide, Inc. All rights        *
* reserved.						      *
*                                                             *
* This Software is confidential and proprietary to IntraNet   *
* and it is protected by U.S. copyright law, other national   *
* copyright laws, and international treaties. The Software may*
* not be disclosed or reproduced in whole or in part in any   *
* manner to any third party without the express prior written *
* consent of ACI Worldwide, Inc.                              *
*                                                             *
* This Software and its related Documentation are made        *
* available under the terms of the IntraNet Software License  *
* and may not be used, reproduced or disclosed in any manner  *
* except as expressly authorized by the Software License. All *
* other uses are strictly prohibited.                         *
*                                                             *
* This Software and its related Documentation are proprietary *
* and confidential material of ACI Worldwide, Inc.            *
*                                                             *
***************************************************************

%^------------------------------------------------------------------------------
%^ Revision History:
%^
%^ Kristen Callihan October 1995
%^	Initial version.
%^ R. Swartz    6-Oct-1995  
%^	Added HostGet. If configured, calls the host mainframe thru
%^	real-time communications link to obtain account validation
%^	and/or name & address info before and/or after the 
%^	creditside lookup. If HostGet is configured, but down,
%^	processing continues as if HostGet is not configured, after
%^	a memo is written to the message history.
%^
%^	Hostget status is a function of both return status &
%^	hget_ac_status.
%^
%^	Situation		Return stat	hget_ac_status
%^	======================	===========	==============
%^	Hostget worked; shows 
%^	good acct.		Success		"V"
%^
%^	Hostget worked; shows 
%^	problem with acct.	Success		{"N","C","D","P"}
%^
%^	Hostget didn't work;
%^	problem with host sys.	Failure		{"U","B"}
%^
%^	Hostget didn't work;
%^	problem on local vax.	Failure		"F"
%^
%^	Hostget didn't work
%^	on purpose (config)	Failure		"W"
%^	=======================================================
%^	V ... valid		N ... not found
%^	C ... closed		D ... duplicate matches
%^	P ... do not post	U ... sys prob internal to host
%^	B ... bad parse		F ... failure
%^	W ... *this* bank not running hostget, although others are
%^	=======================================================
%^
%^ Fred P. Isaacs  8-Nov-1995
%^	Added credit party lock argument to CREDITSIDE_LOOKUP.
%^ D. Alquist	 9-NOV-1995 21:22:09.80			SPR 10797
%^	Save msg history label.memo contents upon initial DEQ in a global
%^	variable as part of general message context, in case cursor position
%^	changes later.  MAP_SUBS routine will use this variable to detect
%^	a PDM delivered here for mapping/logging/indexing prior to PDM routing.
%^
%^ R. Swartz   20-Dec-1995	
%^ 	Fixed hostget adr logic which was setting full_parse_flag to
%^	"N" even when no hostget call had been made.
%^
%^ K. Callihan   08-JAN-1996
%^	TIR 13367 - Do not call DBT_AUTH_CHECK unless dbt and sbk are different
%^ Fred P. Isaacs  11-Feb-1996
%^	Restructured DEBITSIDE_LOOKUP and CREDITSIDE_LOOKUP calls to match
%^	restructured routines.
%^ K. Callihan	 16-FEB-1996
%^	Added SI_FINAL_PARTY call to handle COR/RTE processing
%^ K. Callihan   06-MAR-1996   SPR=15073
%^	Call CREDITSIDE even though no credit party to satisfy moving
%^      of debitside lookups
%^ R. Swartz   19-Mar-1996	
%^	Removed call to hostget_memo and recoded it as local code.
%^ K. Callihan	 27-MAR-1996    BUG=15640
%^	Move back dated value date edits to C700_EDIT_FTR from Map_fields
%^ K. Callihan	 19-APR-1996
%^	Move multiple warnings memo to MAP_SUBS
%^ Fred P. Isaacs	22-MAY-1996
%^	Changed args for DEBITSIDE_LOOKUP and CREDITSIDE_LOOKUP 
%^		   to explicitly pass amount and currency.
%^ Fred P. Isaacs	28-MAY-1996
%^	Corrected currency and amount setup for DEBITSIDE_LOOKUP and
%^		CREDITSIDE_LOOKUP.
%^ K. Smith	 04-JUNE-1996
%^	Set FTRSCR for modification before calling CURRENCY_EDIT routine.
%^ K. Callihan	14-JUN-1996
%^	BUG=17865: For GMD messages, check if link already assigned sbk and
%^	if so do not map sender from header.
%^ K. Callihan	 18-JUN-1996    BUG=17428
%^	Changed 2 memos in EDIT_FTR to not be written out during enqueue to
%^	repair but on it's own line in history so it appears in repair
%^ K. Callihan   20-JUN-1996	TIR=18020
%^	Changed SWF_BR_BACKVAL = "S" for to mean allow back valued transfers
%^	to go straight thru.  Previously, the only way to go straight thru
%^	was if it was set to "T" and the branches matched.
%^ R. Swartz	 1-Jul-1996  #18178
%^	Removed ";& hget_compose ^OUT(memo_txt_ws) ^space / ;" from 
%^	hostget_memo. It was causing a SBJACT error on ent_msg_history.
%^
%^ K. Callihan	 04-JUL-1996
%^	TIR=18351 Do not bust payment types that are being processed as ADM
%^	for payment edits
%^
%^ K. Callihan	08-AUG-1996
%^	BUG=19153 Credit lookup by name not displaying memos.
%^
%^ K. Callihan	16-AUG-1996
%^	PROJ=12612 Added calls and support code for MT102 payment processing
%^
%^ K. Callihan	9-SEP-1996
%^	BUG=19883 NDA messages with a RTE si not going to NDA queue
%^
%^ R. Swartz   20-Sep-1996 	#20345
%^	Added hostget code to support crossbank id's.
%^
%^ N. Moore    20-Sep-1996	TIR #19415  
%^	If a bank doesn't have FED (FED adv type not in Credit_adv_types
%^	table in INTRTL), then don't fill Cdt_Adv_Typ with FED, if
%^	applicable.  Instead, leave it blank so Repair doesn't force
%^	entry of adv type prior to displaying other errors and allowing
%^	them to be fixed.  (Entering proper credit party, for bank, will
%^	properly fill the cdt adv type in Repair)
%^
%^ H. Podany	01-Oct-1996	Spr# 18538
%^	Call CREATE_PHN_CNF to create a PHN confirmation if the advice type is
%^	PHN and the site is not configured for PHN advising.  This will only
%^	apply to messages that have passed all edits.
%^
%^ K. Callihan 02-OCT-1996
%^	BUG=20580 Make sure that charge_state flag gets set to "N" on
%^      for all cases where the payment will go to repair (full_parse = "N")
%^
%^ K. Callihan  16-Oct-1996  	Bug from 19415 fix.
%^	The above fix has to check if payment_ws = 1 (meaning payment)
%^	because all admins are now erroring out.
%^
%^ K. Callihan 23-OCT-1996 	BUG 21377
%^	Need to compose results from IRT successful hit into
%^	destination to satisfy GMX.
%^ K. Callihan	BUG 21425
%^	If ftr screen edits fail, set charge_state flag to "F"
%^
%^ J. Phelan   24-OCT-1996
%^      Add call to Si_check_enabled to determine if CUS SI's are
%^      enabled for the message source.  #19846
%^ K. Callihan 05-NOV-1996	BUG 21975
%^	Unconditionally set debit_currency and amount input args
%^ T. Carroll  27-NOV-1996	SPR 18570
%^	Compare the current time against a cutoff time defined by 
%^      Bank in the INTRTL_USER_TABLES to see if the message is 
%^	allowed to continue processing or it will be routed to
%^	exception.
%^ K. Callihan 04-DEC-1996	PER 22722
%^	Add check for new REJ routing option and process as an admin if found.
%^
%^ K. Callihan  27-DEC-1996	PER 23671 (formerlly 4051)
%^	For bank, if message types 4XX have "COC", "CIC", "PLC" or "PN" in any
%^	field 21, route message to CCLPTRQ (or another configurable queue) by
%^	setting the full parse flag to "O".
%^
%^ 30-Dec-1996	N. Moore	SPR #23673
%^		After first incoming SWF msg, the tid and branch code lookups
%^		in PARSE_SWF_HEADER were not succeeding, resulting in a blank
%^		LOC field in the FTR set.  This is used by bank for EOD
%^		reporting and was, therefore, found by them.  Fixed by saving
%^		the address of the first SWF_BRANCH_CODES table entry to be
%^		used in the parse header subprogram and also in this pgm in the 
%^		X470_FIND_ACC_USING_LOC paragraph.
%^
%^ 13-Jan-1997	N. Moore	SPR #24230
%^		Force MT910 msgs, which are to be processed as payments, not 
%^		admins, to go to repair.
%^
%^ 14-Jan-1997	N. Moore	SPR #24405
%^		Best guess lookups shouldn't go straight through
%^		Routing table has entries (at least for bank) for parse flag 
%^		settings of 1, 2, and 3 which send msgs to a verify queue
%^		Re-Instating code from 3.3 orig implementation of functionality.
%^
%^ 31-JAN-1997  K. Callihan	BUG #19690
%^		Change debit authority failure memo to be "Debit party not
%^		sender or exceeded DA limit".
%^
%^ N. Moore     10-Mar-1997     Spr #23649
%^              Add new parameters for debit/creditside lookups
%^              Rearrange code to be able to call lookups multiple times, if
%^              needed, to get an account in the msg currency.
%^              Change lookup logic for assigning currency code to a party per
%^              specs from Fred I (and Tony).
%^
%^ M. Kuske	09-Apr-1997	SPR #26383
%^      	Added code to test the DEBIT_SWF_AMOUNT flag to determine 
%^		whether the debit currency argument is set to the message 
%^		currency in a cross currency environment.  The debit currency 
%^		argument is set when the value of the flag is "T".  The debit 
%^		currency argument is set to spaces with the value of the flag 
%^		is not "T".
%^
%^ J. Phelan	09-Apr-1997	SPR #27390
%^      	Do lookups before routing message as an authorization failure.
%^		Otherwise, message_routing traps.
%^
%^ 23-Apr-1997  B. Lanza        SPR 22951 	migrated from V4.1
%^              Unable to match anticipations generated from SWF mt210's.
%^              Delete parameter fields used for calling the debitside/creditside
%^
%^ 25-Apr-1997	A. Smith	Use new HGET subroutines instead of embedded
%^				custom variant for processing the results of a
%^				hostget call.
%^
%^ 06-MAY-1997	K. Callihan	SPR #27715
%^		Do not call debit authority check if the payment has a not
%^		on file debit party or sender since should go to repair.
%^
%^ 12-May-1997  T. Carroll      SPR 27684
%^       	ADMIN type message are not routing correctly because the full
%^       	parse flag is set to N.  The code now checks for a payment type
%^       	transaction before setting the full parse flag.
%^
%^ 15-May-1997  J. Phelan       SPR 27821
%^              Don't blank out the Debit_amount_currency and 
%^		Credit_amount_currency arguments to the lookup routines.  We 
%^		always want to try to find an account in the message currency 
%^		first.
%^
%^ 21-May-1997  J. Phelan       SPR 28949
%^              When restoring the message sets prior to doing another lookup,
%^		back out any memos that might have been written to the message
%^		history by the lookup routines.
%^
%^ 04-Jun-1997  J. Phelan       SPR 28949
%^       When restoring the message sets prior to doing another lookup,
%^       back out any memos that might have been written to the message
%^       history by the lookup routines.
%^
%^ 11-Jun-1997  A. Villa       SPR 28818 29244
%^       Non-payment messages were calling HOSTGET and failing thus sending
%^       the message incorrectly to repair.  I modified the code to NOT call
%^       HOSTGET for non-payment messages.
%^
%^ 17-Jun-1997  J. Phelan       SPR 30379
%^       Avoid hanging up on the second message processed.
%^
%^ 23-Jun-1997	H. Podany	Spr# 23348
%^	Do not call credit side lookup routine when the parsing dictionary has
%^	requested that the message be sent repair.
%^
%^ 01-Jul-1997  A. Villa       SPR 29927
%^      The current bank was not being reset to the default bank prior to a
%^	debitside_lookup.
%^
%^ 14-Jul-1997  M. Vallee      SPR 30153
%^	Under certain situations the save and restore routines for the msg_union
%^      sets could cause the sets subjects to point to objects that were no
%^	longer valid.  One of the symptoms of this problem was Dest_Count of
%^	Ent_Ftr_Set was updated after the restores but never made it to the
%^	database.
%^ 
%^ K. Hanlon	16-July-1997	SPR 31174
%^	Changed Hostget to not set full_parse_flag_ws to "N" if return value
%^	is "W".
%^ 
%^ A. Smith	22-July-1997
%^	Allow SWF_BRANCH_CODES records to be less than full record length.
%^
%^ N. Moore     5-Sep-1997      SPR #33061
%^      Break Ent_Cnf_Set in C305_Restore_Init_Sets; as it causes a trap in
%^      some situations when it has not been broken prior to getting to this
%^      point in subsequent messages.  The break in Cus_Cleanup, above, is not
%^      enough; as a cnf_set can get this connected after the cus cleanup 
%^      section (specifically, MT210's) and it is still connected for next msg.
%^      *Note, I also added break to CREATE_210_ANTICIPATIONS module which is
%^      one offender that I found.
%^
%^ N. Moore     5-Sep-1997      SPR #33084 and 30029
%^	Reorganize the connect (mod) statements in to ensure that sets are
%^	connected in the correct order in order to avoid a MOD_WAIT deadlock
%^	situation.  According to NEWS 'Gotcha' information from Fred I, Ftr Set
%^	should be connected first (;) then each set to be connected (mod) should
%^	be done as an individual statement ended with a semi-colon, as well.
%^
%^ K. Hanlon	27-Sep-1997		BUG=31334 (migrated from 4.1, 4.2)
%^		Break cnf_seq and cnf_set at B200_CUS_CLEANUP since
%^		it is causing subsequent messages to trap.
%^
%^ K. Hanlon    27-Sep-1997	PER 27274
%^	Enhancement to split MT101s as we do MT102s.  Changed name of
%^      MAP_SWF_102 to MAP_SWF_101_102.	
%^
%^ K. Hanlon    27-Sep-1997	SPR #32933
%^	SPR 27390 changed logic to do lookups before routing a message that
%^	fails authentication.  If however, the message has a mapping problem,
%^	the auth routing is lost and the message is routed to repair. Fixed
%^	logic to perserve the auth routing.
%^
%^ J. Phelan     7-Oct-1997  SPR 32902,32591
%^      At routing time, call Currency_edit to calculate the Base_amount and
%^      exchange_rate if they haven't already been calculated.
%^
%^ H. Podany	20-Oct-1997	Spr#'s 34887, 35277
%^	Move parsing dictionary call from MAP_FIELDS to just prior to lookups.
%^	The parsing dictionary was being called for admins and should only be
%^	called for payment messages which is determined after MAP_FIELDS, spr#
%^	34887.  Also, the full_parse_flg set by the parsing dictionary was
%^	being overwritten by SWFIN after the call to MAP_FIELDS, spr# 35277.
%^
%^ A. Smith	26-Oct-1997
%^	Add call to POST_LIQ. This subroutine will do whatever RTGS-related
%^	logging is necessary if it determines that the payment is from the
%^	central bank or clearing house, and returns a flag to tell the caller
%^	to notify the correct liquidity manager after committing the message
%^	by setting an event flag.
%^
%^ H. Podany	10-Dec-1997	Spr# 36238
%^	Move the returned parsing dictionary not-on-file flag to the credit ovr
%^	field.
%^
%^ A. Villa      10-Dec-1997  SPR 33889
%^      Priority_flag in adr_set not being mapped to ftr_set.
%^
%^ H. Podany	17-Dec-1997	Spr# 37412
%^	Routing_option was being set to BUST in all cases when the parsing
%^	dictionary returned an unsuccessful status or a full parse status of
%^	"N".  Routing_option will no longer be set in these cases so the
%^	items will be routed to payment repair instead of wire repair.
%^	The full parse flag will not be upgraded from "N" by the parsing
%^	dictionary full parse flag so that the bust routing option will be
%^	set to FTR before routing the message.
%^
%^ H. Podany	17-Dec-1997	Spr# 37546
%^	Call "DEBIT_LOOK_ACCOUNT" (normally called from CREDITSIDE_LOOKUP) if
%^	parsing dictionary edits fail in order to complete debit side lookup.
%^
%^  S. Smith    31-Dec-1997     Spr# 37695
%^      Move Parse of credit Id outside of VLD IF statement before first
%^      Hostget canadate call. If Bank was set up for ADR call but not VLD
%^      call then Id never got parsed.
%^
%^ N. Moore	7-Jan-1998	PER 34561
%^	Remove double lookups in base line currency mode and modify parameters
%^	used to call lookup routines (to correspond to the changes made in
%^	the lookup routines for simplifying the rules for lookups and assigning
%^	currency codes).
%^	Removed the actual parameter initializing and calls to lookup routines
%^	and put into a new centralized module, DO_MAP_LOOKUPS.
%^
%^ K. Hanlon	11-Jan_1998	PER #33319
%^	If FX in message and will be routing FX, keep message a payment (RPR)
%^	even if return from SWF_ROUTING returns ADM for foreign payments.
%^
%^ K. Hanlon	11-Jan-1998	Spr# 37587
%^	Ignore FX processing for admins by updating ftr fields with fx values
%^	after SWF routing table lookup.  If fx routing, redo amount index 
%^	update with fx amount/cur. 
%^
%^ K. Hanlon	7-Jan-1998	#37235
%^	When bank context switched in lookups, current_bnk_id not getting set
%^	back to default bank causing the next message to route via changed bank
%^	from previous message.
%^
%^ J. Carey	21-Jan-1998
%^	SPR 36588 - Wrong Hostget flag checked in para B200_FINISH_CDT_CHECKS.
%^	Was checking HOSTGET_CALLS_VLD, should have checked HOSTGET_CALLS_ADR.
%^
%^ T. Carroll   28-Oct-1997
%^	SPR 33969 - Do not map the SBK from swift header 2 when the header 2
%^	indicates that it's inbound.
%^
%^ A. Smith	7-Jan-1998
%^	CREDITSIDE_STATUS was being inappropriately passed to
%^	HGET_MAP_CDT_PARTY,
%^	when the subroutine expects a status indicating whether the credit
%^	party has been looked up on the REL. Also, HGET_WRITE_MEMOS was not
%^	being called, so no memos were written to the message.
%^	Also: full-parse-flag status of "2" was being assigned only if the
%^	full-parse flag was still "Y"; it will now also be assigned if the
%^	name is not similar, and the full parse flag is "1".
%^
%^	Also correct the assignment of the FULL_PARSE_FLAG levels, which can
%^	be set to "Y", "1", "2", "3" or "5" when the credit party is
%^	successfully identified. The test in use was checking for 3 vs. 4
%^	parties when it should have been checking for 2 vs. 3 parties; further,
%^	it was the wrong way round, since "3" is supposed to be the riskier
%^	case and should be set when there are only 2 parties; when there are 3
%^	parties, the party we have looked up by name is not the final recipient
%^	of the funds; it is a party through which the beneficiary is being paid,
%^	and it is identified as a bank (this last test is added for the first
%^	time by this release).  In addition, a new test was added to
%^	distinguish case "2" from case "3"; in order to qualify as case "2",
%^	the payment must have at least 3 parties and the immediate credit party
%^	must be a bank or internal department (REL types "B" or "I", not "C").
%^
%^   15-Jan-1998	H. Podany
%^		Added international "CHQ" to "CHK".
%^
%^ J. Carey    09-Feb-1998	#39632
%^      Problem with post-REL HOSTGET call (the ADR map call).
%^	In the case where creditside lookup has changed the Credit ID,
%^	the changed ID was not being used in the HOSTGET call.
%^
%^ T. Carroll   12-Feb-1998
%^      SPR 36433 - Residual SBK was carried from previous message to the next.
%^
%^ K. Hanlon	27-Feb-1998	#34811
%^	Introduce Dbt2_full_parse_ws to be used in the creditside lookup.
%^
%^ M. Lyons      4-March-1998	
%^      SPR 35121 - Check Authentication prior to routing message in the case	
%^      of a PDM (possible duplicat message).
%^
%^ K. Hanlon   11-Mar-1998	#39154
%^	Amount and currency not getting zeroed out correctly when FX codeword
%^	found but has an error (due to cobol move).
%^
%^ K. Hanlon   11-Mar-1998	#38841
%^	Do NOT change bank context if sbk found on another bank!
%^
%^ M. Lyons     13_mar-1998     SPR #7326
%^	If a bank doesn't have CHP (CHP adv type not in Credit_adv_types
%^	table in INTRTL), then don't fill Cdt_Adv_Typ with CHP, if
%^	applicable.
%^      
%^ K. Hanlon	22-Mar-1998	#40942
%^	Since we moved the assignment of the FX codeword parameters to the
%^	ftr set out of map_custom we must also move the initialization
%^	out to SAF_ISO and SWFIN.
%^
%^ K. Hanlon	08-Apr-1998	#39969
%^	PARSE_SWF_HEADER now calls an intrtl routine that could change the
%^	Swf_send_id_ws type to something other than "S" so now we must update
%^	the map_send_idtype using swf_send_idtype_ws and not hardcode it
%^	with "S".
%^
%^ K. Hanlon	01-Jun-1998	# 42689
%^	If we are cross-currency, and both debit and credit amt and currency
%^	remain blank (due to both nof), then map the amt/cur from the ftr set
%^	to the credit amt/cur since RPR requires one of the parties amt/cur
%^	to be set.
%^
%^ K. Hanlon	01-Jul-1998	# 44539
%^	Back out 42689 which updated debit/credit currency if both blank.
%^	Originally advised to do so but now asked to take it out.
%^
%^ J. Carey	06-Jul-1998	#44233
%^	Changed paragraph X200_hostget_call.
%^	For a HOSTGET address lookup, if HOSTGET returns Hget_ac_status_cdt_ws
%^	set to "W", (meaning that the call the Host was not made due to a
%^	configuration issue/problem), then set the full parse flag to N.
%^
%^ D. Boyajian  09-Jul-1998	#42485
%^	The call to POST_LIQ is wrong because the two arguments are reversed.
%^	Correct this.
%^
%^ K. Hanlon	09-Aug-1998	PROJ 45323
%^	Moved the save_ftr_currency definition to MAP_FSECT since now
%^	DO_MAP_LOOKUPS can update it and also removed clearing of the
%^	debit and credit amounts since do_map_lookups may set it if it
%^	hits on an account in an equivalent currency (EURO project).
%^
%^ B. Lanza	10-Aug-1998	Spr 37063
%^	Inquiry problem not finding adm message.  Create ADM log in
%^	sbk rel not dbt rel.
%^
%^ K. Hanlon	25-Jul-1998	# 44209
%^	Add logic to set flag if chp is not a valid advice type for a bank
%^
%^ K. Hanlon	20-Sep-1998	# 46668
%^	Have NDA routing take precedence over other rpr routing except
%^	auth, fx and pdm.
%^
%^ N. Moore	13-Oct-1998	#47904
%^	Incoming msgtype is not always set (as expected) in Ftr set when msg
%^	is queued to SWFINQ; so must check here to be sure it gets populated.
%^	**Needed in message routing tables
%^
%^ K. Hanlon	02-Oct-1998	# 47629
%^	Do not route PDMs until after SWF routing table lookup is done so
%^ 	the destination is set up properly.
%^
%^ J. Phelan	02-Nov-1998	# 42688
%^	Change logic to use the Payment_ws instead of the Lookup_payment_ws
%^	flag after performing X600_CDT_MATCH_BY_NAME, since the 
%^	Lookup_payment_ws flag hasn't been set at that point.
%^
%^ K. Hanlon	06-Nov-1998	# 48749
%^	If hostget sets full_parse to 1 and we have just an mapping error
%^	from map_fields, payments are going to WRP instead of RPR.  This
%^	is because the setting of full parse to 1.  Needed to change full
%^	parse check prior to setting FTR in routing option to "NOT = "Y"
%^	rather than = "N" to accomodate hostget.
%^
%^ J. Phelan	04-Jan-1999	# 47173
%^ 	This release changes the Swfin mapper to correctly flag admin messages
%^	that come from links other than Swfapc.  Formerly these messages were
%^	always treated as FTR messages which made it impossible to do inquiries
%^	on them as Admin messages.
%^
%^ Fred P. Isaacs	16-APR-1999 PORT
%^	Add two "value zero" arguments to LOCK_DEQ call.
%^
%^ Fred P. Isaacs	3-MAY-1999 54064(PORT)
%^	Changed allocation of logical queue feed to be ROTATING for
%^	multiple banks.  This should cause equitable processing from all
%^	input queues instead of a "first all from one, then all from next"
%^	approach.
%^
%^ Fred P. Isaacs	13-JUL-1999 56003(PORT)
%^	Now uses LQM_POST to post to y-copy log and LQM_KICK to rouse liquidity
%^	Manager once y-copy message has been posted and committed.
%^
%^ Fred P. Isaacs	21-JUL-1999 54959(PORT)
%^	No longer writes or composes silly memo containing rel_id when
%^	posting to *ADR_ADM_LOG.
%^
%^ Kristen Hanlon	30-Aug-1999 PORT Resynch Project
%^	The following has been resynched from VAX 4.5:
%^
%^	SPR 50511 - Only bypass debit authority checks if debit party not mapped
%^	NOT if not on file.  The sender may have global debit authority so a nof
%^	debit party could go straight thru.
%^
%^      SPR 49573 - Added CODEWORD_FSECT for new codeword processing and loading of
%^	MAP_CODEWORDS_IN table (see map_subs comments on codeword processing
%^	for more details on the new codeword processing approach)
%^
%^	SPR 15526 - Add new argument to Acct_lookup (Acct_look_pend_del).
%^
%^	MPER #48541 - Migration of PER #42789
%^      Implement Party Determination Processing.
%^      1.  What is Party Determination?
%^          It is an extension of and a replacement for the Parsing
%^          Dictionary.  It is an API that allows client-written routines
%^          to parse a message and replace/substitute parties,
%^          calculate fees, etc.
%^      2.  When is it done?
%^          It can be done before and after lookups.  The pre-lookup
%^          API for Party Determination is not really new;  it is
%^          essentially the same functionality as the Parsing Dictionary
%^          -- except that Party Determination can change the debit as
%^          well as the credit parties.  The Parsing Dictionary was
%^          restricted to changing the credit party only.
%^          The post-lookup API is new.
%^      3.  How is the post-lookup API done?
%^          INTRTL flag PD_ENQUEUE_TO_SERVER indicates that the client
%^          has chosen to implement a post-lookup API for Party Determination.
%^          The post-lookup API for Party Determination is not handled
%^          by the mapper; it is handled by the PD_SERVER.  So if the
%^          client has configured PD_ENQUEUE_TO_SERVER, then the mapper
%^          will route FTR's (assuming no exception conditions) to the
%^          PD_SERVER.
%^
%^ 	SPR 50748 - Add code if PD Acct insertion fails.
%^
%^ 	PER 53454 - Migration of PER 42966 Add call to PDM_CHECK.
%^
%^	SPR 53129 -	SWF99 changes
%^	Add check for Ent_ftr_set.flgs.swf_real_time_flg.  If it is set to
%^	'Y', indicating that the //RT clearing code (for real time gross
%^	settlement system processing) was received in one of the credit
%^	parties, then set ADV to "FED", unless PID extension table is defined 
%^	with an RTGS system.
%^
%^	SPR 53129 -	SWF99 changes - use new PID_Extension_Table
%^
%^	SPR 50434 - Add support for MT103 payment processing
%^
%^ 	SPR #55657 / same as 29883
%^      Add parm to hostget call "DR" for debit parties, "CR" for credit parties
%^
%^      Per 56214 - Add Entftr_fsect parameter to INTRTL_PDM_MATCH_CRITERIA.
%^
%^	SPR 56053 - Changed logic to NOT do lookups if message fails authentication.
%^	This was done so that message routing would not trap if we changed
%^	bank context and the dbt_adr_bnk_id would remain what the link set
%^	it to.  But the proper fix was to not have the link initialize the
%^	dbt_adr_bnk_id and leave that up to the lookups to do when the lookups
%^	are done.  Auth failed messages will come back into SWFIN and will
%^	do the lookups at that time and should not be done when a auth failure
%^
%^	Spr 56814 - Don not call create_phn_cnf if advice instructions is PHN unless
%^	advice type is LTR or NON.
%^
%^ K. Hanlon	14-Oct-1999	SPR 58232
%^	Do not go to ROUTE_MSG upon debit authority failed check but
%^	rather go through and do all the ftr processing/edits.
%^
%^ K. Hanlon	21-Oct-1999	SPR 58521
%^	Now that we are sending dbt_auth check payments through payment
%^	processing, need to change logic to not default routing to FTR
%^	if routing is set to dbt_auth.
%^
%^ K. Hanlon	26-Oct-1999	Spr 58595
%^	IRT sis to a printer queue was not working since it needed to
%^	take into account a 6 component queue now.
%^
%^ K. Hanlon	04-Nov-1999	Spr 58873
%^	Moved break of swfinq for multi-bank mode to leave it connected.
%^	Previously at the end of the perform which left it broken so
%^	any enqueus to it from splitting multiples resulted in a trap.
%^
%^ K. Hanlon	05-Nov-1999	Spr 58771
%^	Do not perform debit authority checks on MT210s.
%^				Spr 58766
%^	Clear out routing queue name if IRT match is made.
%^
%^ K. Hanlon	08-Nov-1999	Migrate from 4.5
%^
%^ 	#56814 - Do not call create_phn_cnf if advice instructions is PHN unless
%^	advice type is LTR or NON.
%^
%^ 	#58130 - Add parameter Misc_memo_len to MAP_ROUTE call to pass the
%^	correct length of the memo to message_routing.
%^
%^ K. Hanlon	31-Dec-1999	SPR 59856
%^	Code Health week - Change %end. to %end and clean up comments.
%^
%^ K. Hanlon	04-Jan-2000	Spr 59713
%^	If a bank doesn't have WIR advice type ten don't fill set cdt_adv_typ
%^	with WIR, if applicable.
%^
%^ K. Hanlon	05-Jan-2000	Spr 59891
%^	Add call to SET_BANK_CONTEXT after reseting current bank with default.
%^
%^ E. Babin	07-Jan-2000
%^	Change call of CUST_PARSE_DICT to CUST_PARTY_DETERMINATION.
%^
%^ K. Hanlon	21-Feb-2000	Spr 60171
%^	Remove illegal GO TOs for java translation which required some
%^	restructuring of the code.
%^				Spr 60593
%^	Removed pd_enabled check and perform party_determination regardless.
%^
%^ K. Hanlon	05-Mar-2000   Migrate from 4.5
%^	#60175 - If a routing override comes in in the enqueue to the mapper,
%^	the routing was getting lost if it was FUNC=RPR on the swf routing
%^	table and failed debit authority edits.  Also, if override routing
%^	comes in for a payment, get out before payment edits.
%^
%^ K. Hanlon	05-MAR-2000	SPR 60076
%^	Clear out Rte_codeword parameter since it is carrying over routing
%^	from one message to another.
%^
%^ K. Hanlon		04-May-2000	61791
%^	If CHECK_WIRE_ADV_FORMAT returns failure set charge_state to "F"
%^
%^ K. Hanlon		07-May-2000	61964
%^	Do not assign PD_action_string to Mapsh_routing_mode here but in
%^	MAP_ROUTE since it affects later processing based on the values being
%^	RPR, MRH, or WRP.
%^
%^ K. Hanlon		05-Apr-2000	62489 62040
%^	Write out sysmemos as we encounter them unless we are going directly to
%^	MAP_ROUTE since it could be overwritten by another sysmemo.
%^
%^ T. Carroll		21-Jun-2000	60928
%^	Set the Straight_thru_flg to the Full_parse_flag.
%^
%^ Chris Westbury	15-Jul-2000	64694
%^	Port VMS BANK_PARTY_DETERMINATION to AIX CUST_PARTY_DETERMINATION.
%^
%^ K. Hanlon	15-Aug-2000	64605 	CLS Developement
%^	Set msgtype to trade if cls_enabled and message type 300 or 304.
%^
%^ David Boyajian	14-Aug-2000	63276 & 56284
%^	Resynch AIX 1.0 and 1.1 to the way it is in this program on VAX 4.5:
%^
%^	Original change done on VAX by D. Boyajian:
%^	1. Changes instances of "SPL in Routing Option" to "Nowhere in Routing_Option".
%^	2. Add an IF statement after the call to SWF_ROUTING_MATCH [in B200] so that
%^	   an MT941's "Routing_Option" is set to "NOWHERE".
%^	Reason: This reflects the fact that an MT941 message is now to be
%^		routed NOWHERE after being dequeued from SWFINQ.
%^	        SPL has been renamed NOWHERE in Routing_Option's definition
%^		in Map[shr]_Fsect.ddl.
%^
%^	Original change done on VAX by D. Boyajian (09-Mar-2000	SPR 60935/59610)
%^	Move the call to POST_LIQ.COB [Lqm_Post on AIX !] from its present location 
%^	(just before the call to "PARSE_SWF_TRAILER") to FURTHUR DOWN,
%^	(to B200_process_msg_cleanup, before the call to "SYS$SETEF" [Lqm_Kick on AIX!]).
%^
%^	Reason: POST_LIQ.COB [On AIX, is Lqm_Post !] posts to the Bal_log of the message's
%^		debit account when that is a Participant (P/).
%^		However, the debit account might still be a SWIFT (S/)
%^		address if we call POST_LIQ [Lqm_POost on AIX !] too early.
%^		Hence, POST_LIQ [Lqm_Post on AIX ! ]should be called LATER, when we are sure
%^		that the Participant (P/) has been fully mapped into the
%^		debit account of the message.
%^
%^
%^	David Boyajian  24-Aug-2000 VAX 4.5 to AIX Resynch project for LQM, SPR 63276
%^   
%^		Original change done on VAX by R. Lanza 14-JUL-2000, SPR 65175,
%^		[and an accompanying change in program [.map]Post_liq.cob, which is Lqm_post.cob on AIX]:
%^	
%^		. Add new arg (Liq_auto_rls_ls) to call to Lqm_post.cob.
%^		. If that arg is returned as Success, then call Auto-Release [ie. call Message_Routing
%^		  with argument "*AR"] in B200.
%^		. Must add this variable: Swfi_Liq_auto_rls_ls:   Boolean;
%^		  [Note: this change obviously also required adding a new argument to /common_subs/Lqm_post.cob
%^		         itself, the latter program being the equivalant of the VAX's [.map]Post_liq.cob ]
%^
%^ K. Hanlon	31-Aug-2000	Spr 67026
%^	Do not set found_fw based on idtype of "A" since clearinghouse logic should determine that
%^
%^ K. Hanlon	01-Sep-2000	Spr 66195
%^	Default credit and/or debit currencies to base currency if blank due to NOF
%^	party and we are in multi-currency mode so that CURRENCY_EDIT comes up with
%^ 	the right exchange rate.
%^
%^ K. Hanlon	10-Nov-2000	68813
%^	Add logic to carry forward bke_log settings
*
* Fred P. Isaacs	 3-Jan-2001	70834
* 	Now allow both long form and short form parse of SWF BRANCH CODE table
*	and allow spare flags field to be missing.
*
%^ E. Dulog     17-Dec-2000     63474
%^	Add logic to process SWF message types 010, 012, and 019.
%^
%^ David Boyajian	10-Jan-2001	70516
%^	On AIX only, not VAX:
%^	When handling a 941 message, just after the call to SWF_ROUTING_MATCH,
%^	do NOT hard code the Mapsh_routing_option to NOWHERE.
%^	Instead, eliminate the 3 lines of code (an IF statement) that did that.
%^	Reason: 941's will henceforth be handled by normal SWIFT routing, which
%^		requires that the client have an entry for a 941 in the
%^		SWF_ROUTING_TABLE and a companion entry in route.cfg.
%^
%^ K. Hanlon	11-Jan-2000	#69584
%^	Perform debit authority edits even if both sbk and dbt party NOF if full parse
%^	flag is "Y" to fill security hole when NOF debit parties are allowed.
%^
%^ K. Hanlon	17-Jan-2001	67707
%^	Add flag Prelookup_by_name so which is set if id identified by the pre-lookup by
%^	name so later when we edit for not a branch of the bank we know it was done by prelookup.
%^
%^ B. Lanza	29-Jan-2001	Spr 71011
%^	Trap with MSGRTE$_BADPARAM - NOTHING: Unsupported special function "*AR" call while routing.
%^	Added initialize for Swfi_liq_auto_rls_ls to failure.
%^
%^ K. Hanlon	01-Feb-2001	CLS
%^	Add logic to use TRD as source when doing source lookup in swf_routing_table lookup
%^
%^ M. Harris	1-Mar-2001  	Spr 72351 (and 68813)
%^	When bringing forward BKE_LOG from last period, carry forward the state bits too.
%^	Then if BKE_ENABLED is set, it will remain set in the current period too.
%^
%^ K. Hanlon	27-Mar-2001	#70808
%^	Change Hostget_calls_vld flag to Hostget_calls_adr in B200_finish_checks per Eric O.
%^
%^ K. Hanlon	09-Apr-2001	#70504
%^	Do not set REJ routing, rejected transactions to admins but let swf_routing table
%^	determine that.
%^
%^ K. Hanlon	10-Apr-2001	#71153
%^	Move edit of transaction currency to debit/credit currency to do_map_lookups.	
%^
%^ D. Boyajian	23-Apr-2001	#69237
%^	In B200, call new module "IS_THIS_ACCT_A_NOSTRO" (in Pid_routines.cob)
%^	before calling "LQM_POST".
%^	Reason: To determine if the message's debit party is a NOSTRO account
%^		belonging to a "NOSTRO PSEUDO CLEARINGSYSTEM", and if so, to get 
%^		the NAME of that clearingsystem.  This name is then passed,
%^		as usual, to LQM_POST.  IS_THIS_ACCT_A_NOSTRO is the "Nostro"
%^		analogue of GET_PID_ADV_CENTBANK.
%^
%^  S. Smith    7-May-2001      73772
%^      	add check of intrtl table NO_PDM_CHECK which will check the messages
%^      	source with this table and if there is a match, will NOT do a pdm_check.
%^
%^ K. Hanlon	21-May-2001	#69234
%^	Add call to CHECK_RELEASE_TIME to monitor CLSTIME messages.
%^
%^ K. Hanlon	05-Jun-2001	74956
%^	Set full_parse_flag to "N" upon warning_is return from TRADE_COMMON_EDITOR.
%^
%^ K. Hanlon	11-Jun-2001	74346
%^	Add setting of mapsh_payment to 1 for MT392 to allow for extraction of MT300/304
%^	from it.
%^
%^ K. Hanlon	03-Jul-2001	75859
%^	Add check for compare id during lookup by name logic being zero since it will
%^	cause and infinite loop.
%^
%^ C. Westbury	18-Jul-2001	36271
%^	Migrate SWF_READ_MT067 from 1.0 to 1.1.
%^
%^ K. Bjelke	22-Aug-2001	76448
%^	Correct check for SWIFT_BRANCH_CODES.  Swfi_branch_codes was not being
%^	set correctly, resulting in trades not being identified.
%^
%^ R. Gadzinski	05-Sep-2001	77148
%^	The ent_codeword_seq alloc from ent_msg_union.codeword_seq is moving to
%^	DAT_ALLOC_MSG.  We would like to remove the alloc of ent_codeword_seq
%^	from SWFIN but cannot.  For if we had any messages unions that were
%^	created but not yet processed by SWFIN as the code fix was installed,
%^	ent_codeword_seq would fail to be ALLOCed.  So instead, we now first
%^	check if ent_codeword_seq is already ALLOCed, and then ALLOC it if not.
%^
%^ J. Walsh	12-Sep-2001	75580
%^	For 910s, pass the credit party mapped from field 25 to DO_MAP_LOOKUPS.
%^
%^ C. Westbury	15-Oct-2001	74966
%^	Enable umbrella anticipations by calling ANT_MATCH instead of
%^	ANTC_MATCH.  After ANT_MATCH has stabilized, ANTC_MATCH will be
%^	obsoleted.
%^
%^ T. Carroll	01-Nov-2001	69978
%^ 	Automatically map the non_return_valve_flag from the routing table if
%^	there is one.
%^
%^ K. Hanlon	26-Nov-2001	EPER 79325
%^	Added call to "entpf_refresh_pf_info" which checks if the period has changed
%^	in a 24x7 operating environment.
%^
%^ K. Hanlon	23-Jan-2002	81105
%^	If MAP_GL_OVERRIDE is set then set Mapsh_dbt_acct_type or Mapsh_cdt_acct_type to "G"
%^	for gl override (this logic used to happen without flag).  Normal processing would
%^	be to set the account types to "D" or "F" to find vostro vs nostro account.
%^
%^ T. Welch	27-Feb-2002	spr 62177
%^	DTA Port Project:  Vax 4.5-v to Aix 1.2
%^	Add DTA_REC_FSECT for CHECK_WIRE_ADV_FORMAT call
%^
%^ J. Phelan	19-Apr-2002	82767
%^	Use PAC from 77E embedded message when embedded field 103:TPS.
%^
%^ D. Boyajian	21-Apr-2002	SPR's 57994/62688
%^	Version 001 Port Project:
%^	. Add HGET_RECS_FSECT.DDL, just as was done in this program in VAX 4.6,
%^	  Gen 129.  (Note: on VAX, that fsect was named AUTRV_RECS_FSECT.DDL)
%^	. Add one arg to the call to "HOST_GET": MAP.
%^
%^ T. Welch	 9-May-2002	76638
%^	Account expansion changes
%^
* Topher Belknap	16-May-2002	76377	European Date Conversion
*       Put release_time into the time fields of the prime_send_date.
*       Put send_date into the date fields of the prime_send_date.
*       Replace the value_date in ftr_set with Cdt_value_Date in credit_set.
*
* Kristen Hanlon	21-May-2002	85102
*	Force a trap if swf_routing_match routine does not find a match (mode is
*	blank) to keep msgs from being dequeued without being enqueued
*	somewhere.
*
* Joanne Curley		30-Jul-2002	87385
*	Change HOSTGET calls for version 1.2
*
* Harry Podany		02-Aug-2002	87201
*	Remove the two and three party parameters to subroutine CREATE_PHN_CNF.
*
* Joanne Curley		05-Aug-2002	87524
*	Temporary Fix to remove call to SI_MATCH_IRT since Standing Order (SI)
*	Logic for 1.2 has been moved to processing rules.
%^
%^ K. Hanlon	18-Jul-2002	86793
%^	Do an additional log to the senders ref index for trades which bank
%^	gets switched during trade lookups.
%^
%^ K. Hanlon	20-Aug-2002
%^	Removed check_wire_adv_format call since it is done in channel determination
%^
%^ K. Hanlon	27-Aug-2002	87498
%^	Add return sysmemo length parameter to PARSE_HEADER
%^
%^ M. Harris	29-Aug-2002	88111
%^	In paragraph B101, when bringing BKE_LOG state bits forward from last
%^	period, make BKE_LOG memo more explicit.
%^
%^ J. Curley	24-Oct-2002	75828
%^	Agreements enhancement.  Add call to DETERMINE_AGREEMENT.  Make some changes
%^	to correct processing of incoming MT102's 1) added Perform X800_PARTY_DETERsMINATION 
%^ 	2) commented out SI code in paragraph B500_CUS (MT102 CUS Check) because SI's 
%^	have been replaced by Processing Rules in version 1.2.
%^
%^ J. Curley	24-Oct-2002	80387
%^	Add call to CUST_JUST_PAYMENT
%^
%^ K. Hanlon	29-Oct-2002	87830
%^	Add looping mechanism to perorm VLD hosget calls, PD, lookups, ADR hostget,
%^	PD and loop if debit or credit party changed.
%^	Also, change MT102 CUS lookup to determine if the sender has MT102 authority
%^	to now loop for conditional PRM MT102_SUBSCRIBER.
%^
%^ K. Hanlon	30-Oct-2002	Related to change above
%^	Logic was erroring out MT102_SUBSCRIBER checks on MT103s
*
* Harry Podany		05-Nov-2002	87695
*	Use call to PRULE subroutines to search for IRT processing rules and to
*	retrieve execution parameters.
*
* Greg Johnston		12-Nov-2002	76651
*	Enq to autotrieve hold q on hostget failures if Autrv_automated config
*	value is 'y'
*
* Joanne Curley		10-Dec-2002	93114
*	Add call to DETERMINE_RESIDENCY before call to DETERMINE_AGREEMENTS,
*	since DETERMINE_RESIDENCY might set the BBK_RES_COUNTRY from if the
*	BBK_ID is a SWIFT BIC.  
*
* Greg Johnston		11-Dec-2002	76651
*	Fix arg list in routing call to autotrieve hold.  Move call to
*	autotrieve hold to maximize amount of completed mapping.
*
* Joanne Curley		17-Dec-2002	93652
*	1) add party_changed parameter to CUST_PARTY_DETERMINATION call
*	2) process AUTRV_AUTOMATED as N when cfg_rec.dat value not set
*	3) change swfi_tmp_vstr80 parameter passed to MESSAGE_ROUTING from
*	   "MRSWF   N" to "*MRH/MAP/   /N"
*
* Joanne Curley		31-Dec-2002	93577
*	MT102 Agreement processing.  Uncomment call to Determine Agreements for
*	incoming 102's.  Change Mapsh_child_msg_flag to Msgsubtype_oneof.
*	Initialize Mapsh_agreement_cdwrd.
*
* Kristen Hanlon	06-Jan-2003	94279
*	Changed mapping of field 32 to debit value date, so need to change
*	amount index updates and back valued checks to use that date.
*
* Joanne Curley		07-Jan-2003	94243
*	Add Swfi_agreement_ok which is set to success by default, and only set
*	to failure when Determine_agreements is rejecting the message with an
*	MT195.  After perform C700_EDIT_FTR check Swfi_agreement_ok, and if
*	failure go to B300_SPECIAL_FUNDS_end - since we are done with the
*	message.  Change logic to decide if MAP_ROUTE should be called.
*	MAP_ROUTE is skipped when AUTRV_AUTOMATED cfg_rec.dat flag is set to Y
*	and HOST_GET calls failed, or when Swfi_agreement_ok is failure.  Move
*	code to queue to Autotrieve RETRY_Q closer to MAP_ROUTE call for clarity
*	- items are only moved to HGET_RETRY_Q when agreements were ok and
*	HOST_GET calls fails.  Move getting RES_CTRY_DISPL cfg_rec.dat value to
*	start of program so it is done only once per run.
*
* Chris Westbury	12-Jan-2003	93733
*	Try to match a message with an anticipation only if the message is not
*	already matched.
*
* Joanne Curley		16-Jan-2003	94242
*	Rename Swfi_hget_all_ws to Swfi_hostget_call, set Swfi_hostget_call to
*	Success_is at the start of each new message.
*
* Joanne Curley		17-Jan-2003	94534
*	Do not place on autotrieve hold queue when HOST_GET returns "B" (bad
*	syntax).
*
* Kristen Hanlon	24-Jan-2003	94615
*	Allocated ftrscr upon swfin initialization and broke it upon exit because
*	mapper is calling more routines which require it allocated and we are
*	trapping if it is not.  This should ensure it is always allocated for mapper.
*
* Bob Lanza		27-Jan-2003	49634
*	Migrated following changes from 4.6.
*	%^ M. Reyder   28-Dec-2000	Migrate following from 4.3-v to 4.6:
*	%^ F. Rust     07-Jul-1999     #49634/55784  
*	%^	Retain credit party logic for CON.  Added call to Retain_Credit 
*	%^      sub-program added to MAP_SUBS
*
* T. Carroll		28-Jan-2003	92021
*	Updated call to cust_party_determination with new parameter list and
*	set func parm to MAP1/MAP2 for the pre and post lookup calls.
*
* T. Carroll		30-Jan-2003	95345
*	Remove the local version of the party determination parm list and use the 
*	version that resides in the MAPSHR_FSECT.
*
* Kristen Hanlon	02-Feb-2003
*	Add prule api trace calls
*
* J. Curley		05-Feb-2003	94725
*	Skip DBT_AUTH_CHECK when processing a child of a 102 with a Debit ID
*	type of G -- thus a child of a 102 using global debits.
*
* J. Curley		07-Feb-2003	94534
*	Hostget changes.  Host_get changed to return HGET_SUMMARY_STATUS which will
*	have the cumulative status for all the HOST_GET calls for a message.  Values
*	returned are "EXC" which indicates the message should be sent to Repair,
*	"UNV" which indicates unavailable and the message should be sent to the 
*	Autotrieve retry queue, or SPACES indicates no problems or configuration does
*	not require autotrieve/hostget.  Also renamed cfg_rec value local variable from
*	Swfi_autrv_auto_ws to Swfi_autrv_automated to match cfg_rec value name.
*
* E. Osterberg		09-Feb-2003	94534
*	Change Autotrieve caller ID from MAP to SWF
*
* K. Hanlon		28-Feb-2003
*	Remove back date edits and let date routines do it.
*
* T. Carroll		03-Mar-2003	Spr 96300
*	Renamed the party determination parameter list and moved it into the 
*	ENT_FSECT.   
*
* J. Curley		10-Mar-2003	92226
*	Add special repair queue for CUST_JUST_PAYMENT failures - set Mapsh_just_pymt_reqd
*	to true if CUST_JUST_PAYMENT returns failure.
*
* J. Curley		13-Mar-2003	96751
*	Changes for children of 102 DBT_AUTH_CHECK, DBT_AUTH_CHECK has been changed
*	to look at the parents debit account when processing a SWF 100 or 103 that is
*	a child of a 102, so there is no longer a need to skip over DBT_AUTH_CHECKS
*	here anymore.  Took out code added for SPR 94725.
*	
* J. Curley		18-Mar-2003	96918
*	Correct problem for incoming MT102, where not mapping and therefore failing 
*	Determine_agreement.  Problem due to Ent-ftr-set.incoming-msgtype being set to
*	102 which does not happen when loading using swf2load.  Took out code relating
*	to Swfi_first_time Y/N where Swfi_first_time set to N when Ent-ftr-set.incoming_msgtype
*	set to 102.  Also removed unused variables for CUS Standing instruction lookup for
*	MT102 and IRT Lookup route as they appear to also be obsolete.
*
* T. Carroll		07-Apr-2003	97444
*	Update call to determine_residency with new parameter (ALL) indicating that both
*	debit and credit sides should be processed.
*
* Kristen Hanlon	14-Apr-2003	97460
*	Do ftrscr edits before map_swf_102 call for child to get dates set.
*
* Kristen Hanlon	15-Apr-2003	98544
*	Change cdt_adr_type check from (1:1) to (3:1) to accomodate database change.
*
* Joanne Curley		30-Apr-2003	98920
*	Only call CUST_JUST_PAYMENT when cfg_rec flag JUSTIFICAT_PAYMENT  is T, 
*	and there are no other repair conditions on the item.  This prevents items 
*	with repair  conditions other than Regulatory Reporting Justification from 
*	going to the special JUSTPYMTRPRQ.
*
* J. Curley		02-Jun-2003	98423
*	Check for Global Debit Processing earlier, by checking Sender's id for 
*	Processing rule MTS$GLOBAL_DEBIT not set to N.  Also, if doing MT102 global 
*	debit check to see if the MT102 CLEARANCE account has been defined on the Bank.
*	After mapping inbound MT102 parent, if doing Global Debits and the MT102
*	Clearance account is not set, switch to ADM and set Bust (exception) in routing option.
*
* J. Curley		09-Jun-2003	101075
*	Change test from Global Debits from "NOT = N" to "= Y" since PRULE_ADR_GET_PARAM
*	returns success_is when the parameter is not found.	
*
* M. Harris	09-Jun-2003	100821
*	Bring BKE_LOG state bits forward from last period, in B200_Process_Message para,
*	to always have the current state bit, for 24X7 operations.
*
* K. Hanlon	08-Aug-2003	102645
*	Change GLOBAL_DEBIT PRM check to be supported at the bank and system level and
*	assume no single debit processing ONLY if it is defined AND set to "N".
*
* K. Hanlon	11-Aug-2003	102180
*	When handling possible duplicates, the Ent_msg_union needs to be set to ftr type
*	or admin based on the swf_routing_table entry.  It was not getting set because
*	pos dups or authentication failures usually are resloved vis SWF function and
*	sent back to SWFIN for mapping.  But, banks that send these to RPR to be handled
*	and do not return to SWFIN have issues when being formatted out FED because the
*	ent_msg_union is not set properly for a payment.
*
* K. Hanlon	17-Aug-2003
*	Only edit for MT102_CLEARANCE if global debit PRM is found AND we are a mt102.
*
* K. Hanlon	17-Aug-2003	103651
*	Fix non global debit mt102 need to route to nowhere
*
* J. Curley	26-Aug-2003	EPER 100485
*	Only set Ent_ftr_set.Flgs.Priority_flg when it is SPACES, if it was set by
*	PARSE_SWF_HEADER based on the incoming Swift Priority in Header 2 do not change it.
*
* E. Osterberg	29-Aug-2003	104402
*	Add call to HGET_WRITE_MEMOS to write Autotrieve memos and comment
*	to the message history.
*
* K. Hanlon	18-Sep-2003	102643
*	Allow MT102 processing if either MT102_SUBSCIBER OR AGR_AGREEMENTS_ID is
*	defined.
*
* J. Curley	24-Sep-2003	SPR 103272
*	Correct problems with Agreement rejects (mt102 children rejects). Determine
*	Agreements will now change credit advice type to LTR when rejecting child of 
*	MT102, route rejected MT103 child as FTR, do not route to Justification Repair queue
*	if Justification required.  Initialize PRULE_MSG_GET_PARAM calling parameter 
*	Swfi_prule_vals_left since MTS$AGR_AGREEMENT_ID allows mulitple values and next
*	call to PRULE_MSG_GET_PARAM would trap.
*
* K. Hanlon	28-Oct-2003	PROJ 98430
*	Add support for global debit processing for collective and concatenated MT101s
*
* J. Curley	24-Nov-2003	SPR 105813 (migrate from v1.2)
*	Allow host_get summary status EXC to route to exception/repair even if Autrv_automated 
*	cfg_rec flag is not Y.  Autrv_automated only controls retry server, not all of autotrieve.
*
* J. Curley	23-Dec-2003	EPER 98430 add support for MT104 Direct Debit agreement processing.
*				Add call to DETERMINE_AGREEMENT toward the end of non-payment
*				processing.
*
* K. Hanlon	08-Jan-2004
*	Do not check hostget status if routing to NOWHERE which would be the case if we are
*	a parent message type not global debit processing so routing to nowhere.  Hostget will
*	be performed on all the children instead.
*
* J. Curley	09-Jan-2004	98430 Correct error introduced with migration of 105813, when 
*				Hget_summary_status UNV and AUTOTRIEVE_AUTOMATED = "Y" route to 
*				Autotrieve retry, if AUTOTRIEVE_AUTOMATED is not "Y" then
*				route normally.  Had been forcing to Exception whenever
*				Hget_summary_status was UNV.
*
* K. Hanlon	13-Jan-2004	SPR 106206
*	Map childrens total base amount to parents base amount else may be off by a
*	penny due to rounding.
*
* K. Hanlon	13-Jan-2004	107905
*	We used to skip ftrscr_edits if full_parse was "N" due to lookup problems
*	but since too many things get set (like dates) unrelated to lookups in ftrscr_edit
*	subroutine calls it no longer makes sense to skip it.
*
* K. Hanlon	16-Jan-2004	99369
*	Remove the check if return from map_fields is failure route to bust
*	since we do not always call it (ie MT101s).  We should just route to
*	RPR for mapping errors.
*
* K. Hanlon	21-Jan-2004	109207
*	When doing pre-lookup by name due to no credit id, do not change full_parse flag to "N"
*	since now in V1.2 on up we can insert a credit party based on PRMs.
*
* K. Hanlon	22-Jan-2004	99369
*	Supress edit memos for MT101/102 who is not processing global debits.
*
* K. Hanlon	17-Feb-2004	99369
*	Fix error in edit above.
*
* K. Hanlon	29-Feb-2004	110548
*	BUST MT102 to WRP if sender does not have authority to process these.
*
* K. Smith	01-Mar-2004	110499
*     Add new error message parameter in call to "DBT_AUTH_CHECK" routine.
*
* K. Hanlon	10-Mar-2004	110672
*	Fix parse of routing queue name to succeed if bank is supplied.
*
* K. Hanlon	17-Mar-2004	EPER 105183
*	Add BEN_DED_PTRNS call
*
* J. Curley	29-Mar-2003	108190 (migrate)
*	Initialize Mapsh_Dbt_account_type and Mapsh_Cdt_account_type at the start of each
*	message, so lingering data from previous message isn't left hanging around.
*
* J. Curley	29-Mar-2004	109915 (migrate)
*	Set All_lookup_wf flag to FAILURE_IS when HOST_GET returns Hget_summary_status "EXC" to 
*	prevent looping.
*
* J. Curley	02-Apr-2004	109688 (migrate)
*	Rename custom subroutine CUST_DETERM_RESIDE to CUST_DET_RESIDENCY to be more like
*	v1.2 DETERMINE_RESIDENCY
*
* K. Hanlon	31-Mar-2004	111837
*	When checking GLOBAL_DEBIT PRM, allow for dbt_bank_is since bank level PRM should
*	be considered.
*
* K. Hanlon	10-Apr-2004	112167
*	Initialized Mapprop FX variables to avoid carryover.
*
* J. Curley	21-May-2004	110845 (migrate)
*	When totalling up childrens total base amount to update the parents base amount, need
*	to add any RECEIVER_CHARGE that may be on the parent (converted to base currency if
*	need be).
*
* J. Curley	21-May-2004	110480 (migrate)
*	Children of MT102's with Global Debits failing agreement checks should not route to
*	repair.  Skip over FTRSCR_EDITS and Set Mapsh_full_parse_flag to Y so the rejected
*	children can process straight thru to payadv.
*
* J. Curley	21-May-2004	111957 (migrate)
*	Move calls to SET_ENTERED_SIDE from DO_MAP_LOOKUPS and MAP_FIELDS.  Needs to be called
*	just befor FTRSCR_EDITS and only needed for FTR's (not Admins).  This corrects 
*	problem where ENTERED_SIDE flag was not set to C.
*
* J. Curley	21-May-2004	111415 (Migrate)
*	Changed to correct missing END-IF that was
*	causing MAP_SWF_101 not to be called.  MT101's don't need Parent/Child processing
*	in version 1.2 (that is for v1.3).
*
* J. Curley	21-May-2004	109915 (migrate)
*	Move HGET_WRITE_MEMOS call outside of HOSTGET_PD_LOOKUPS loop.  HGET_WRITE_MEMOS
*	clears info used to set Party_changed flag within HOST_GET routines, and would
*	cause a loop condition for banks using non-XML hostget format.
* 
* J. Curley	21-May-2004	110348 (migrate)
*	Call Autotrieve again for children that fail Agreements (determine agreement
*	changes the CDT party to the parent's Debit Party and Autotrieve needs to be 
*	called again).
*
* K. Hanlon	02-June-2004	112869/113081
*	Do not call CHECK_RELEASE_TIME if PDM or link override routing.
*
* K. Hanlon	02-June-2004	113545
*	Fix IRT processing rule logic to find the params correctly and set up the destination correctly.
*
* K. Hanlon	02-June-2004	113582
*	Do not set full parse (or STP flag) to "N" if just LATE returned from CHECK_RELEASE_TIME.
*
* K. Hanlon	02-June-2004	112389
*	Set swfrout_type to ENQ if routing to queue to allow destination to get properly set.
*
* K. Hanlon	06-Jul-2004	114623
*	Do not set Mapsh_charge_state_flg to "F" if doing a pre-lookup by name since we
*	could be advice type CHK (which is now determined later).  Later, after lookups
*	it is set if prelookup is not a branch of the bank.
*
* K. Hanlon	06-Jul-2004	112947
*	Reassign Mapsh_cdt_2nd_id and Mapsh_dbt_2nd_id from PD routines even if blank
*	to allow PD routines to clear it out.
*
* K. Hanlon	06-Jul-2004	113545
*	Fix IRT processing rule logic to find the params correctly and set up the destination correctly.
*
* J. Curley	08-Jul-2004	113277 (migrate)
*	Repeat Hostget Party Determination Lookups loop when 2nd MAP2 party_determination
*	call returns party changed.  Add limit  to number of times the Hostget/Party
*	Determination Lookups loop will execute (Swfi_hg_loop_limit set to 25).
*
* J. Curley	28-Jul-2004	113362 (migrate)
*	Don't skip FTRSCR_EDITS for children of MT102's failing agreements (when Global Debits), 
*	was skipping over setting of Credit Value date among other things.
*
* J. Curley	29-Jul-2004	113891 (migrate)
*	When accumulating childrens total base amount to update parents base amount, 
*	cannot assume that first child processed with be segment_index 1.  So for each
*	child need to accumulate all the parent's childrens base_amount and update the parent
*	with that.  Then deduct any RECEIVER_CHARGE that may be on the parent.  When more
*	than one SWFIN process running, first child processed was not segment_index 1 so 
*	base amount was set incorrectly.
*
* J. Curley	30-Jul-2004	114278 (migrate)
*	Initialize variables used by IRT processing rule logic to correct PRULE Trap. 
*	Comments only release this fix was included in migration of 113545
*
* J. Curley	12-Aug-2004	97929, 100394, 109263 (migrate)
*	Added 2 new calling arguments to PARSE_SWF_TRAILER Swfi_rcvd_pde and Swfi_rcvd_pdm. 
*	If Ent_message_history contains "PDEDONE" on dequeue from SWFINQ sets Swfi_pde_done 
*	to TRUE.  When Success_is is returned from PARSE_SWF_TRAILER, if Swf_pde_done is 
*	Failure, then will route to PDMQ, otherwise, continues along (because had 
*	been released from PDMQ).  Add an additional scan of SWFINQ to check for occurance of 
*	BOTH PDEDONE and AUTHDONE.
*
* J. Curley	13-Aug-2004	114575 (migrate)
*	When there is an Authorization failure or Possible Dup, set the Credit Value Date to the
*	MTS$ORIGINAL_32A_DATE parameter value, so it will pass to BYLOGS_DUMP.  Set the
*	Credit Value Date Change State to Calculated_is so the date will be recalculated
*	when the message goes back to SWFIN after Authorization or PDM is cleard.
*
* J. Curley	13-Aug-2004	114966 (migrate)
*	Add SYS_MEMO and set full_parse_flag to N when 1) CDT party not identified and 
*	2) advice type not CHK or CHQ and 3) Success_is in Swfi_prelookup_by_name.
*
* K. Hanlon	16-Aug-2004	115252
*	Do not break out of D100 loop based on Hget_summary_status if either the
*	debit or credit party has changed and
*	Do not set Swfi_all_lookup_status to failure based on lookup return status.
*
* K. Hanlon	08-Sep-2004	116010
*	If IRT queue name parse fails, assume it is just the queue name and set accordingly.
*
* K. Hanlon	08-Sep-2004	116340
*	Advice type check for CHQ added with OR not AND conition causes memo to always
*	appear even if advice type is CHK.
*
* J. Curley	16-sep-2004	116879
*	Set memo string to use Mapsh_Full_parse_flag not hardcoded as N when routing to 
*	Autotrieve Hold Queue. (Released by Eric)
*
* J. Curley	24-Sep-2004	116464 (migrate)
*	Skip calls to Autotrieve / Host_get on Admins.
*
* R. Gadzinski	02-Sep-2004	101536
* 	Add STPACE holdq routing.
*
* D. Albertsen 	04-Nov-2004	113701
* 	Added prule_msg_copy_from_template to copy parent's CNF to child.
*
*	 C. Hansen             29-Nov-2004     Spr 59856
*       remove 2nd arg from call to cust_party_determination.
*
* K. Hanlon	09-Dec-2004	Fix prule edit parameters
*
* C. McKenzie	21-Dec-2004	SPR#119114
*	Added code to set the .txt field to the transaction reference number.  Logs
*	and queues that can be scanned by by_logs_dump need to have this field set.
*
* C. McKenzie	13-Jan-2005	114817	
*	Changed how ent_ftr_set.inst_date is set.  It was being set to the menu-date,
*	but this is the calendar date upon which the message is received, so it was
*	changed to be set to the NOW date.
*
* R. Gadzinski	26-Jan-2005	101536
*	Remove 3rd party reference from base code.
*
* K. Hanlon	09-Feb-2005	120703
*	Call CHECK_RELEASE_TIME even if possible duplicate or
*	routing override designated by the link.  Just do not change routing
*	from poss dup or routing override from link. The timer_index entry
*	will be made causing later routing to RSK.
*
* K. Hanlon	16-Mar-2005	119631
*	Make PD action string and full parse flag return arguements independent in
*	usage from one another.
*
* K. Hanlon	22-Mar2005	119898
*	Remove BEN_DED_PTRNS call - moved to PAYADV
*
* K. Hanlon	13-Apr-2005	88354
*	Routing Precedence Enhancement - No longer use Mapsh_routing_option but rather
*	load up Mr_rout_cond_seq with all possible routings and let ROUTE_PRECEDENCE
*	table decide on the routing.
*
* K. Hanlon	01-May-2005	122809/88354
*	Regression tweaks for the rewrite and stop AUTH carryover.
*
* K. Hanlon	10-Jun-2005	122916
*	Add support for MTS$LOCATION for IRT processing
*
* J. Curley	23-Jun-2005	EPER 120282 (migrate)
*	Do not map Header 2 Sender ID to Mapsh_send_id for children of MT101's. 
*
* J. Curley	30-Jun-2005	118694 (migrate)
*	Route MT102's where Sum of 32B + parent's 71G not equal parent's 32A using 
*	EPR command (and output sys_memo). 
*
* K. Hanlon	26-July-2005	124409
*	Move call for GLOBAL DEBIT PRM check to DO_MAP_LOOKUPS after
*	debitside call to allow for sender/debit level definition.
*
* J. Curley	27-Oct-2005	V3.O NEW UI
*	Remove references to FTRSCR FTR Screen, called modules now use
*	error routines.  Needed for java translation.
*	
* S. Smith	10-Oct-2005	126974
*	Remove call to set_entered_side before the call to ftrscr_edits. We 
*	want to wait till after currency_edit, called from ftrscr_edits has
*	calculated the amounts.
*
* S. Smith	15-Nov-2005	126974
*	Also Remove the memo written to msg history if the above call to set
*	entered side fails
*
* K. Hanlon	02-Dec-2005	126283
*	Move the check for Mapsh_dbt_full_parse and Mapsh_cdt_full_parse to after the
*	D100 loop in case ACE/PD or autotriev fixed a lookup problem.
*
* Kristen Hanlon	02-Dec-2005	125058
*	Only set Mapsh_payment for 300/304/392 if cls is enabled.
*		
* K. Hanlon	06-Dec-2005	124408
*	Add call to CUST_SYSMEMO_TO_PRM
*
* K. Hanlon	09-Jan-2006	128061
* 	Moved edit for blank credit advice until after D100 perform to allow
*	ACE to populate it.
*
* K. Hanlon	11-Jan-2006	128061
*	Fix error in moving the edit above.
*
* K. Hanlon	16-Jan-2006	128288
*	Only call CHECK_RELEASE_TIME if we are processing a payment.
*
* K. Hanlon	15-Mar-2006	128979
*	Only route EXC autotriev items to Exception if Swfi_autrv_exc_routing is set to "T"
*	If set to "F", route to repair.
**
* D. Albertsen  09-June-2006	130874
* 	Copy parent prules to children after lookups, but before FTRSCR_Edits for proper
*	date row use of DBTCOMPVAL prule use.
*
* S. Smith	12-Jun-2006	131421
*	Id cust_just_payment returns a error message and audit_errors is turned
*	on then write the error message out to message history.
*
* K. Hanlon	28-Jun-2006	EPER 126515
*	Add call to CUST_MAP_101_FLDS
*
* K. Hanlon	28-Jun-2006	124741
*	Add call to CUST_CODEWORD_CHECK to check codewords across concatenated collective MT101s.
*
* K. Hanlon	07-Aug-2006	131401
*	If autotrieve returns EXC causing all lookup status to be failure, loop once
*	more through to apply and PD changes through lookups.
* 
* K. Hanlon	09-Aug-2006	Fix compilation bug from migrations.
*
* J. Curley	21-Aug-2006	125427 (migrate K. Hanlon 23-Aug-2005)
*	Remove setting of sysmemo after failure in trailer status since it does not
*	apply and memos should be written in the trailer routine.
*
* J. Curley	21-Aug-2006	125705 (migrate  K. Hanlon 06-Sep-2005)
*	Route to NOWHERE if BKE routed it to avoid a trap.
*
* J. Curley	24-Jan-2006	127808 (migrate J. Curley 24-Jan-2006)
*	Migrate initialize of MAPPROP_FX_FOUND at satrt of each
*	mesage - from release 20050901_curleyj_3 (v1.1) 125088
*
* J. Curley	11-Dec-2006	icr_1045 
*	Change calling args to DBT_AUTH_CHECK to use str(80) instead of omitted.
*	fixes java xlate problem in DBT_AUTH_CHECK.
*
* K. Hanlon	16-Jan-2007	134987  - Migrate
*	Add call to CUST_GET_TESTKEY_RQTS to set test out state from SWFIN.
*
* D. Albertsen 	08-May-2007	135640 icr_001839
*	Set bulk parent flgs5.childq_create_flg to prevent premature triggers.
*
* B. McLean	22-Jun-2007     EPER 130182 
*	Add call to CUST_SET_PRIORITY.
*
* S. Smith	26-Jul-2007	spr 139662
*	Use an alloc_join rather than a Join
*
* S. Smith	1-Aug-2007	Spr 139879
*	Make sure that the amt_index is in (insert) mode before above alloc_join.
*
* D. Ryan	23-Aug-2007	138763	icr_002954
*	After the message has been routed to the Authfailq queue and returned, 
*	continue checking for a possible duplicate.  The mapsh_child_msg_flag is
*	temporarily being set to "F" if it is a possible duplicate.
*
* D. Ryan	29-Oct-2007	140779	icr_003440
*	Correct the carrier which has been found via IRT standing orders.  If the
*	Rcs_category of Mr_rout_cond_seq is PRM/IRT and the Rcs_carrier is not spaces,
*	then use it instead of the Ent_dst_set.dst_carrier when the cust_get_testkey_rqts
*	module is called.
*
* B. McLean	11-Mar-2008	CR 1559
*	Added SAC_FSECT. Added code to write the SWF_AUTH results to MSG_HISTORY.
*
* F. Rust       15-Oct-2008     CR 4944 [1.2 was 4470, 2.0 4943]
*       Changed sys memos...
* MAC AUTH SUCCESS                -> AUTHORIZATION OK
* MAC AUTH NOT REQ                -> AUTHORIZ NOT REQ
* MAC Authenticator key not found -> AUTHORIZATION Relation not found
* MAC Authfail: <variable text>   -> AUTHORZ FAIL: <variable text>     
*
* G. Johnston	08-Dec-2008	CR3958 ((v1.2)111246)
*	V3.0 migration.
*	Add call to CUST_CHNG_SWF_RTG_PARAM just before SWF_ROUTING_MATCH.
*	Overwrites the Mapsh_rte_codeword, if implemented.
*
* B. McLean	02-Feb-2009 	CR7622
*	Changed the return status checking from SWF_AUTHENTICATION to
*	recognize Auth Not Required.
*
* J. Curley	16-Feb-2009	cr6375
*	Correct addional problems with X1000_CHECK_TEST, this time migrate para
*	almost in its entirety from 1.2  fixes cr6575 and 6038
*
*
* T. Carroll	25-Feb-2009	cr 7460 (upgrade Joanne's CR2567 to version 3.0)
* 	J. Curley	13-May-2008	cr 2567
*	AME Italian pensions processes huge MT102's for global debit processing.
*	Change the way base_amount is updated in parent to instead of connected
*	to each child mapped, update each child's CHILD_QUE.CHILD_VALUE with its
*	base amount after its mapped.  Then parent can be updated with sum
*	of base amount from SWFI_PARENT_CHILD_QUE SUM.   Still need to factor
*	in parents receiver's charges from parent RELATED_AMOUNT_SEQ.
*
* R. Jhawar	17-Apr-2009	CR5354 
*	Fix for When you use the SWF function to re-authenticate a message after 
*       you have established the relationship the message print still states  
*       No S.W.I.F.T authentication relationship
*	Migrate from CR3942 in 2.0
*
* J. Curley	03-Jun-2009	cr8067
*	Skip DBT_AUTH_CHECK on MT101's that are NOT Global Debits.  Parents
*	will die anyway, and checks are one on kids.
*
* R. Jhawar     21-Jul-2009     CR10641
*       SWFIN busts message with no memo in history (memo dropped)
*       Memo was being populated in PARSE_SWF_HEADER but never written,
*       so, made a call to Z400_WRITE_HIST_MEMO to write it in SWFIN
*
* B. McLean	11-Feb-2009	tc1320
*	Added support for TPSPKIAUTHDONE.
*
* M. Thakkar 	20-Nov-2009     TC13696
*     Call the CUST_SWFIN_CMD_LINE program after connecting the SWFINQ to
*     allow the subroutine to re-connect an alternate input queue based
*     on a command line parameter -q[ueue].
*
*
* End Revision History
*-------------------------------------------------------------------------------

*
* 
* SWIFT input mapping program processes messages that come into the SWFINQ
* and perform SWIFT specific logic as well as general mapper logic.
* 
* The logic common to all mappers is contained in the MAP_SUBS.COB module and
* the SWIFT specific mapping logic is contained in MAP_SWF_SUBS.COB module.
*  
* Once the mapper has dequeued the message from SWFINQ and performed the
* necessary initialization, the following subroutines are called setting
* necessary mapping statuses based on the functionality performed.
*                                           
*     	PARSE_SWF_HEADER  	: Parse the SWF1/SWF2 header
*	MAP_FIELDS	  	: Maps body of the message and assigns parties
*     	PARSE_SWF_TRAILER 	: Parse the SWF1/SWF2 trailer
*     	SWF_AUTHENTICATION	: Authentication of Swift message
*       SWFIN_BKE	  	: Process BKE-related messages
*     	PARSE_SWF_DLV_CNF 	: Process SWF delivery confirmations
*	SWF_ROUTING_MATCH 	: Lookup SWF Routing table
*	DEBITSIDE_LOOKUP  	: Lookup debitside parties
*	CREDITSIDE_LOOKUP 	: Lookup creditside parties
*	DEBIT_AUTH_CHECK  	: Debit Authority Check
*	SI_MATCH_IRT	  	: Lookup IRT standing instructions
*	CREATE_CHILD_MSG  	: Splitting of 201, 203 & 204 messages into 
*			    	  multiple single transactions
*	MAP_SWF_102		: Splitting of 102 messages multiple 100s
*	CREATE_210_ANTICIPATIONS: Create individual anticipations for each
*				  notice transmitted within a 210
*	ANT_MATCH		: Automated anticipation matching
*	MAP_ROUTE         	: Route message
*
* 	
*
* 	Routing Options are set as described in MAP_ROUTE.  All processing
*	will continue and routing will be done based on the routing option
*	selected.  In the case of header/trailer errors, processing will
*	stop and the message will be routed to exception repair queues.  Errors
*	encountered during field mapping will be noted in history but 
*	processing will continue and the message will ultimately be routed
*	to the exception repair queues.  If a lookup or payment edit is 
*	encountered, the message will be routed to a repair queue. If a 
*	message must be busted to a repair queue, the integrity of the 
*	original destination will be saved in the destination set allowing
*	the message to be repaired and released to the proper destinations.
*
*
*			    	 --------
*				| SWFINQ |
*				 --------
*				    |
*			      ----------------
*  Statuses Established	     | Initialization |
*  --------------------	      ----------------
*				    |
*			   ----------------------- Fail	             
*     Header Status	  | Call SWF_PARSE_HEADER |------------------
*			   -----------------------                   |       
*		                    | Success                        |       
*	                   -----------------------                   |       
*     Mapping Status	  | Call MAP_FIELDS       |                  |       
*			   -----------------------                   |       
*				    | Success/Fail                   |       
*			   ----------------------- Fail	             |	    
*     Trailer Status      | Call SWF_PARSE_TRAILER|------------------|
*			   -----------------------                   |       
*                                   | Success        Fail and Mapping|       
*			   ------------------------- Status Success  |       
*     Auth Status         | Call SWF_AUTHENTICATION |----------------|       
*			   -------------------------                 |          
*				    | Success or                     |       
*				    | Mapping status                 |       
*			            | Failure                        |       
*			   -----------------------  Success	     |       
*     Return_status_ws    | Call SWFIN_BKE        |----------        |       
*			   -----------------------           |       |       
*				    |Fail 		Exit Program |       
*     			   ------------------------                  |       
*     Delivery Status     | Call PARSE_SWF_DLV_CNF |                 |       
*			   ------------------------                  |       
*				    | Success/fail	             |       
*     			   ------------------------  Establishes ENQ,|       
*     Return_status_ws    | Call SWF_ROUTING_MATCH | ID or MRH route |
*			   ------------------------		     |
*				    | Established Payment Y or N     |
*		  	   ------------------------		     |       
*     Debitside Status    | Call DEBITSIDE_LOOKUP  |		     |       
*			   ------------------------                  |       
*				    | Success/fail		     |       
*			   ------------------------		     |       
*     Creditside Status   | Call CREDITSIDE LOOKUP |		     |       
*			   ------------------------		     |       
*				    | Success/fail                   |
*			   ------------------------                  |
*     Rte_Cor_status	  | Call SI_FINAL_PARTY    |                 |
*			   ------------------------                  |
*				    |                Fail w/ no	     |       
*			   ------------------------  previous failure|       
*     Dbt_auth Status     | Call DBT_AUTH_CHECK    |-----------------|       
*			   ------------------------	       	     |       
*				    | Success		       	     |       
*				    |		     Success w/ no   |
*			   ------------------------  prev routing    |
*     IRT Status	  | Call SI_MATCH_IRT      |-----------------|
*			   ------------------------		     |
*                                   | Fail                           |
*			      --------------- No   	             |
*                            |  Payment????  |-----------------------|
*			      ---------------			     |
*				    | Yes			     |
*			   ------------------------  Success/Fail    |
*     Child Status        | Call CREATE_CHILD_MSG  |-----------------|
*			  | for 201, 203 & 204 only|		     |
*			   ------------------------                  |
*				    |			     Success/|
*			   --------------------------------  Fail    |
*     Notice Status       | Call CREATE_210_ANTICIPATIONS  |---------|
*			  | (for 210s only)                |	     |
*			   --------------------------------          |
*				    |				     |
*			   ----------------			     |
*			  | Call ANT_MATCH |			     |
*			   ----------------			     |
*				    |				     |
*				    |				     |
*   -----------------------------------------------------------------------------------------------------------------------
*  |		 Call MAP_ROUTE                                                                                            |
*  |					                      			                                           |
*  | Routing           Description					           Comments                                |
*  |                                                                          						   |
*  | FTR      -> Route as payment (repair or otherwise)                       	  Debitside/Creditside or no failure	   |
*  | EPR      -> Route to Exception Print Queue                               	  No failure - warning messages only	   |
*  | MRH      -> Route via routing override                                   	  MRH override found - successful statuses |
*  | AUTH     -> Route to AUTHFAILQ                                           	  Auth Status failure                  	   |
*  | COR      -> Route to Core verify                                        	  CORE processing - sucessful statuses     |  
*  | ENQ      -> Route by enqueuing on queue (MRH, SWF_ROUTE queue, WRP queue)	  SWF routing - successful statuses	   |
*  | ID	      -> Route by SWF_ROUTE idtype/id destination                     	  SWF routing - successful statuses	   |
*  | IRT      -> Route to IRT standing instruction queue                          IRT status success - no other failure    |
*  | BUST     -> Route to EXCEPTION Repair Queues                                 Header/Trailer/Mapping/Child status fail |
*  | NOWHERE  -> Route nowhere - create empty destination (for 201,203,204,210)   Parent message routing                   |
*  |										  for messages that are to go "nowhere".   |
*  |										  Note: NOWHERE was formerly named "SPL",  |
*  |											for "Splits".			   |
*  | DBT_AUTH -> Route "NDA" no debit authority                                   Dbt_auth status failure                  |
*  | PDM      -> Route as possible duplicate                                      Mapping status failure for PDM           |
*  | RTE      -> Route to RTE SI override										   |
*   -----------------------------------------------------------------------------------------------------------------------
*

%def	<ACE>		%`SBJ_DD_PATH:ACE_FSECT.DDL`		%end
%def	<AUX_FS>	%`SBJ_DD_PATH:AUX_FS_FSECT.DDL`		%end
%def	<BKE>		%`SBJ_DD_PATH:BKE_FSECT.DDL`		%end
%def	<CODEWORD>	%`SBJ_DD_PATH:CODEWORD_FSECT.DDL`	%end
%def	<ENT>		%`SBJ_DD_PATH:ENT_FSECT.DDL`		%end
%def	<ENTFTR>	%`SBJ_DD_PATH:ENTFTR_FSECT.DDL`		%end
%def	<ENT_TEMP_MSG>	%`SBJ_DD_PATH:ENT_TEMP_MSG_FSECT.DDL`	%end
%def    <FFANT>         %`SBJ_DD_PATH:FFANT_FSECT.DDL`          %end
%def	<HOSTGET>	%`SBJ_DD_PATH:HOSTGET_FSECT.DDL`	%end
%def	<MAPSHR>	%`SBJ_DD_PATH:MAPSHR_FSECT.DDL`		%end
%def	<RELGET>	%`SBJ_DD_PATH:RELGET_FSECT.DDL`		%end
%def 	<ROUTE>		%`SBJ_DD_PATH:ROUTE_FSECT.DDL`		%end
%def	<SWF_SUBS>	%`SBJ_DD_PATH:SWF_SUBS_FSECT.DDL`	%end
%def	<SAC>		%`SBJ_DD_PATH:SAC_FSECT.DDL`		%end
%def	<SWFFINCPYDSC>	%`SBJ_DD_PATH:SWFFINCPYDSC_FSECT.DDL`	%end

%def			%^ local fsect

%^ Cfg_rec.dat flag variables

Swfi_cfg_values_state:	Oneof(Not_loaded_is,Loaded_is);
Swfi_autrv_automated:	Str(1);
Swfi_cls_enabled:	Str(1);
Swfi_gl_override:	Str(1);


%^ General definitions 


Swfi_amount_ndx:		que(	%`SBJ_DD_PATH:AMT_INDEX.DDF` );

%^ Statuses and States
Swfi_find_status:		Boolean;
Swfi_header_status:		Boolean;
Swfi_trailer_status:		Boolean;
Swfi_mapping_status:		Boolean;
Swfi_auth_status:		Boolean;
Swfi_mt102_authorize:		Boolean;
Swfi_delivery_status:		Boolean;
Swfi_rte_cor_status:		Boolean;
Swfi_Irt_Status:		Boolean;
Swfi_child_status:		Boolean;
Swfi_notice_status:		Boolean;
Swfi_routing_status:		Boolean;
Swfi_cus_enab_status:		Boolean;
Swfi_temp_status:		Boolean;
Swfi_temp1_status:		Boolean;	%^ #138763
Swfi_pos_dup_flag:		Str(1);
Swfi_loop_status:		Boolean;
Swfi_class_locs:		Boolean;
Swfi_branch_codes:		Boolean;
Swfi_acc_by_loc:		Boolean;
Swfi_matched_by_name:		Boolean;
Swfi_minilook_status:		Boolean;
Swfi_cutoff_status:		Boolean;
Swfi_hget_ch_credit:		Boolean;
Swfi_hget_status:		Boolean;
Swfi_pd_status:			Boolean;
Swfi_prelookup_by_name:		Boolean;
Swfi_MT067_status:		Boolean;
Swfi_route_msg:			Boolean;
Swfi_do_map_route:		Boolean;

%^
%^ Prule variables
%^
%^ Prule CNF processing
Swfi_cnf_global_ws:		oneof(	%`SBJ_DD_PATH:PRULE_GLOBAL_ONEOF.DDF`);
Swfi_cnf_prule_fnd_ws:		Long;			
Swfi_cnf_param_fnd_ws:		Long;			
Swfi_cnf_hist_msg_crtd:		Long;

Swfi_prule_ordinal_ws:		Long;
Swfi_prule_type_ws:		Vstr(80);
Swfi_prule_msglevel_ws:		Oneof(	%`SBJ_DD_PATH:PRULE_MSGLEVEL_ONEOF.DDF`);
Swfi_prule_source_ws:		Oneof(	%`SBJ_DD_PATH:PRULE_SOURCE_ONEOF.DDF`);
Swfi_prule_subtype_ws:		Vstr(80);
Swfi_prule_memo_ws:		Vstr(	%`%ACE$_MSG_STR_SIZE`);	%^ Prule CNF match history memo

Swfi_prule_param_name:		Vstr(40);
Swfi_prule_level:		Oneof(	%`SBJ_DD_PATH:PRULE_LEVEL_ONEOF.DDF`);
Swfi_prule_source:		Oneof(	%`SBJ_DD_PATH:PRULE_SOURCE_ONEOF.DDF`);
Swfi_prule_edit:		Oneof(	%`SBJ_DD_PATH:PR_PARAM_EDIT_ONEOF.DDF`);
Swfi_prule_vals_left:		Long;
Swfi_prule_value:		Vstr(80);
Swfi_prule_status:		Boolean;

Swfi_pruleadr_ischanged:	Boolean;
Swfi_pruleadr_type:		Oneof(%` SBJ_DD_PATH:PR_PARAM_EDIT_ONEOF.DDF`);


%^ Host Get call variables

Swfi_Hg_request_type:		STR(3);
Swfi_Hg_dbt_cdt:		STR(2);
Swfi_Party_changed:		STR(4);
Swfi_Dbt_party_changed:		STR(4);
Swfi_Cdt_party_changed:		STR(4);
Swfi_PD_party_changed:		Boolean;
Swfi_Edit_memo:			VSTR(80);	
Swfi_all_lookup_status:		boolean;
Swfi_return_status:		boolean;
Swfi_hg_loop_limit:		Long = <25>; %^ Limit on number of times to loop HOSTGET/PD/LOOKUPS
Swfi_hg_loop_count:		Long;
Swfi_loop_once_more:		Long;

%^ Modes and settings - Initialization Constants

Swfi_ftr_mode: 			Str(3) = "MAP";
Swfi_res_mode:			Str(3) = "ALL";
Swfi_default_bank: 		Vstr(3);
Swfi_reset_bank:		Str(3);
Swfi_special_mapping:		Str(1);
Swfi_bke_installed:		Str(1) = "T";  	
Swfi_q_name:			Vstr(60);
Swfi_id_parms:			Vstr(20);
Swfi_Codeword_entry_ws:		Vstr(60);
Swfi_custom_code:		Vstr(10);
Swfi_dat_notonfile:		str  = "VMSG$_DAT_NOTONFILE";

%^ Working definitions

Swfi_Currtime:			str(11);              
Swfi_Colontime:			str(5) = "  :  ";      
Swfi_rte_party:			Str(1);
Swfi_tmp_old_id:		Vstr(10);
Swfi_tmp_new_id:		Str(1);
Swfi_Temp_adv_type:		str(3);
Swfi_phone:			Str(13);	
Swfi_oneof_ord:			Word;
Swfi_Loop_Forever: 		Word = <1>;
Swfi_scratch_w0:		Word;
Swfi_loop_ind:			Word;
Swfi_word_count:		Word;
Swfi_best_match:		Word;
Swfi_fake_bic:		 	Vstr(8);
Swfi_long_zero_wc:		Long = <0> ;
Swfi_tmp_long:			Long;
Swfi_trap_message:		Vstr(132);
Swfi_Swf_Bank:  		Str(3);
Swfi_blank_str_3:	        Str(3) = "   ";	
Swfi_blank_str_4:	        Str(4) = "   ";	
Swfi_msg_currency: 		Str(3);
Swfi_cdt_adv_flg: 		Str(1);
Swfi_return_memo:		Vstr(80);
Swfi_hist_memo:			Vstr (80);
Swfi_cust_memo:			Vstr (80);
Swfi_err_memo:			Vstr (80);
Swfi_temp_memo:			Vstr(80);
Swfi_tmp_vstr80: 		Vstr(80);	
Swfi_temp_bic:			Str(12);
Swfi_tmp_vstr: 			Vstr(35);
Swfi_tmpwild_vstr:		Vstr(37);
Swfi_long_tmp_vstr: 		Vstr(210);
Swfi_swf_route_src:		Str(3);
Swfi_orig_msgtype:		Str(3);
Swfi_auth_memo:			Vstr(80);
Swfi_Codeword_ws:		Str(10);
Swfi_Codetext_ws:	 	Vstr(30);
Swfi_Route_ws:		 	Str(1);
Swfi_Bbi_ws:			Str(10);
Swfi_Ordinal_ws:		Word;
Swfi_Found_default_ws:		Boolean;

Swfi_routing_memo:		Vstr(80);
Swfi_2nd_routing_memo:		Vstr(80);
Swfi_temp_command:		Str(3);
Swfi_routing_found:		Boolean;

Swfi_Tid_Rec: 			Rec( Tid_Adr:		Str(8);
				     Tid_Branch:	Str(3) );
Swfi_cl_table_entry: 		Rec(
				    Sclte_acc : 	Str(6);
				    Sclte_Loc : 	Str(6));
Swfi_que_id_rec: 		Rec(  %`SBJ_DD_PATH:PRIV_ITEM_REC.DDF`);

Swfi_intrtl_cutoff:             rec(
                        	    Cut_Bnk_id:     str(3);
                        	    Cut_slash1:     str(1);
                        	    Cut_Time:       str(4));
Swfi_intrtl_cutoff_size:        word = <8>;

%^ Composes and Parses

Swfi_misc_compose:		Compose(^NOTRAP);
Swfi_misc_parse:		Parse(^FTRAP, ^NOSPACE_SKIP );
Swfi_parse:			Parse(^NOTRAP);
Swfi_compose:			Compose(^NOTRAP);
Swfi_pki_compose:		Compose(^NOTRAP);
Swfi_block_8_compose:		Compose(^NOTRAP);
Swfi_block_4_compose:		Compose(^NOTRAP);

%^ Variables for authentication and trailer processing
Swfi_rcvd_mac:			Str(8);
Swfi_rcvd_pac:			Str(8);
Swfi_rcvd_pde:			Boolean;
Swfi_rcvd_pdm:			Boolean;
Swfi_pde_done:			Boolean;
Swfi_test_message: 		Long;
Swfi_tmp_rcvd_pac:		Str(8);

Swfi_dbt_auth_memo:		Str(80);

%^ Variables for Debitside and Creditside Lookup routines

Swfi_acctyp_seq:		seq( %`SBJ_DD_PATH:REL_NAME_SEQ.DDF`
						Scan_Key = Rel_name_key.Idtype);
Swfi_acc_set:			set( %`SBJ_DD_PATH:ACC_SET.DDF`);

Swfi_2nd_idtype:		Str(1);	  
Swfi_2nd_id:			Vstr(64);  
Swfi_ovr:			Str(1);	   
Swfi_name1:			Vstr(35);	
Swfi_name2:			Vstr(35);
Swfi_name3:			Vstr(35);
Swfi_name4:			Vstr(35);
Swfi_cmp_id1:			Vstr(64);
Swfi_cmp_id2:			Vstr(64);
Swfi_last_msg_src:   		Str (3);
Swfi_tmp_ambig:  		Str (1);
Swfi_tmp_ovr:			Str(1) ;
Swfi_saved_dbt_idtype:  	Str(1);
Swfi_saved_cdt_idtype:  	Str(1);
Swfi_saved_dbt_id: 		Vstr(64);
Swfi_saved_cdt_id: 		Vstr(64);
Swfi_swf_idt:			Str(1);		
Swfi_swf_id:			Vstr(64);	
Swfi_xbank_acc_wc:		Long = <0> ;
Swfi_adr_conn_ws:		long ;
Swfi_pend_del:			Str(1);


%^ For passing currency/amount to Debitside and creditside lookup routines.

Swfi_Save_Ftr_Curr:	Str(3);
Swfi_init_currency:	Str(3);

%^ Variables for DETERMINE AGREEMENT

Swfi_agree_type:		Str(1);
Swfi_agree_reject:		Boolean;
Swfi_agree_codeword:		Str(10);
Swfi_agree_codetext:		Str(25);
Swfi_agreement_status:		Boolean;
Swfi_agreement_ok:		Boolean;

%^ Variables needed for DETERMINE_RESIDENCY

Swfi_Residency_status:		Boolean;
Swfi_res_ctry_displ:		Str(1);

%^ Variable for CUST_JUST_PAYMENT
%^
Swfi_Reg_info_status:	oneof ( %`SBJ_DD_PATH:EXIT_STATUS_ONEOF.DDF` );
Swfi_Just_req:		Str(1);
Swfi_Just_party_req:	Str(1);
Swfi_Just_Reg_id_req:	Str(1);
Swfi_Just_ret_status:	boolean;
Swfi_Just_error:	Vstr(80);
Swfi_Justificat_payment:	str(1);

%^ Variables for cutoff routine

Swfi_current_date:	date ;
Swfi_current_time:	time;
Swfi_current_hours:	Str(2);
Swfi_current_minutes:	Str(2);
Swfi_current_nhours:	long ;
Swfi_current_nminutes:	long ;
Swfi_cutoff_nhours:	long ;
Swfi_cutoff_nminutes:	long ;

%^ Subject variables for call to configuration routines.
Swfi_union_key_ws:   	rec (%`SBJ_DD_PATH:CFG_ID_REC.DDF`);
Swfi_item_key:		vstr(25);
Swfi_item_type_ws:	vstr(16);
Swfi_item_data_ws:   	vstr(256);
Swfi_seq_ordinal_ws:	word;
Swfi_error_msg_ws:	vstr(80);
Swfi_temp_size:		long ;
Swfi_temp_long:		long;
Swfi_match_key:		vstr(80);

Swfi_gen_work_que:	que(	%`SBJ_DD_PATH:GEN_WORK_QUE.DDF` );
Swfi_hostget_call:	boolean;
Swfi_hget_video_msg:	STR(80) ;
Swfi_table_error:	vstr(132);
Swfi_queue_spec:	vstr(80) ;

%^ Variables for LIQ_POST call
Swfi_centbank:		vstr(3);
Swfi_pid_status:	Boolean;
Swfi_kick_lqm:		Boolean;
Swfi_Liq_auto_rls_ls:   Boolean;
Swfi_kind_of_clrsys_ws: Str(1);			%^ Kind of clearingsystem: Blank = Regular,  N = Nostro

%^ Variables for the PDM check routine

Swfi_Key_search:         Str(1);
Swfi_PDM_S_ftr_set:      Set(%`SBJ_DD_PATH:FTR_SET.DDF`);
Swfi_PDM_S_dbt_set:      Set(%`SBJ_DD_PATH:DEBIT_SET.DDF`);
Swfi_PDM_S_cdt_set:      Set(%`SBJ_DD_PATH:CREDIT_SET.DDF`);
Swfi_PDM_match_criteria: Vstr(80);
Swfi_PDM_match_status:   Boolean;


Mts_prod_wc:		Str = "MTS"; 
Source_code_tables_wc:	Str = "SOURCE_CODE_TABLES";
Cfg_union_key_ws:	rec (%`SBJ_DD_PATH:CFG_ID_REC.DDF`);
Cfg_item_key_ws:	vstr(25);
Cfg_item_type_ws:	vstr(16);
Cfg_item_data_ws:	vstr(256);
Cfg_error_msg_ws:	vstr(80);
Cfg_seq_ordinal_ws:	word;
Cfg_match_key_ws:	vstr(80);

%^ Variables for CLS trade processing

Swfi_trade_edit_status:	 Oneof(%`SBJ_DD_PATH:return_stat_oneof.ddf`);	 
Swfi_cross_bank:	 Boolean;
Swfi_owning_bank:	 Str(3);
Swfi_fully_parsed:	 Boolean;
Swfi_memo_count:	 Long;
Swfi_trade_lookup_sts:   Boolean;


%^ Variables for parent base amount updates
Swfi_Parent_union:	Set(%`SBJ_DD_PATH:MSG_UNION.DDF`);
Swfi_Parent_ftr_set:	Set(%`SBJ_DD_PATH:FTR_SET.DDF`);
Swfi_Parent_child_que:	Que(%`SBJ_DD_PATH:CHILD_QUE.DDF`);
Swfi_Parent_relamt_seq:	seq(%`SBJ_DD_PATH:RELATED_AMOUNT_SEQ.DDF`);
Swfi_Child_history_seq:	seq(%`SBJ_DD_PATH:MSG_HISTORY_SEQ.DDF`);
Swfi_Child_msg_history:	seq(%`SBJ_DD_PATH:MSG_HISTORY_SEQ.DDF`);
Swfi_Child_msg_union:	Set (%`SBJ_DD_PATH:MSG_UNION.DDF`);	
Swfi_Child_ftr_set:	Set (%`SBJ_DD_PATH:FTR_SET.DDF`);

Swfi_Parent_Rcvr_chgs:	Amount;
Swfi_Children_Base_amt:	Amount;
Swfi_Base_rel_amt:	Amount;
Swfi_Base_rel_cur:	Str(3);
Swfi_Base_Precision:	Str(1);
Swfi_Rel_amt_amt:	Amount;
Swfi_Rel_amt_cur:	Str(3);
Swfi_Zero_rate:		Fixed(11);


%^ Variables for CHECK_RELEASE_TIME call

Swfi_rls_rte_command: 	  Str(3);
Swfi_rls_error_msg:	  Vstr(80);
Swfi_rls_return_status:	  Boolean;

Swfi_Lcl_msg_history: 	SEQ ( %`SBJ_DD_PATH:MSG_HISTORY_SEQ.DDF` );

Date_Ws:                 DATE;

Swfi_32A_date:		REC (%`SBJ_DD_PATH:EXP_DATE_REC.DDF`);


Swfi_turned_on:		Boolean;
Swfi_turned_off:	Boolean;

Swfi_cnf_Return_status: Boolean;

Swfi_pd_down_wf:	Boolean;
Swfi_hold_routing_ws:	Str(3);
Swfi_loc:		Str(6);

Swfi_autrv_exc_routing: Str(1);
Swfi_codeword_status:	Boolean;

Swfi_arg_audit_error:	Boolean;

%^ Variables for EMF_replacement

Swfi_Temp_dst_carrier:		Str(3);
Swfi_in_test:	  		Str(1);
Swfi_out_test:     		Str(1);
Swfi_dest_conn:    		Long ;
Swfi_incoming_msgtype:		Str(3);

Swfi_dest_ovr_flag:		Word;
Swfi_zero_long:			Long = <0>;
Swfi_swf_ovr:			Str(1);

%^ Variables for CLS Embedded PKI validation.
Swfi_Block_4_found:	Boolean;
Swfi_iMoreServices:	long;
Swfi_iServiceIndex:	long;
Swfi_Pki_sts:		Boolean;
Swfi_vFldListName:	vstr(80);
Swfi_sMessageType:	str(3);
Swfi_iMoreFldTags:	long;
Swfi_iFldTagIndex:	long;
Swfi_recCRLF: rec(
  bCR:			byte = <13>;
  bLF:			byte = <10>);
Swfi_vSigValue:		vstr(2000);
Swfi_vSavedSigValue:	vstr(2000);
Swfi_vSigBlock:		vstr(10000);	%^ Assemble signature blocks here
Swfi_vTextBlock:	vstr(11000);	%^ Assemble text for digest computation here
Swfi_iOutOffset:	long;
Swfi_vTargetField:	vstr(5);
Swfi_tmp_text_seq:	seq(%`SBJ_DD_PATH:dat_text_seq.ddf`);
Swfi_tmp_2text_seq:	seq(%`SBJ_DD_PATH:dat_text_seq.ddf`);
Swfi_junk:		long;
Swfi_padding_needed:	long;
Swfi_vHashcodeBase64:	vstr(45);		%^ Base64-encoded hashcode (44 bytes + 1 extra byte during encoding)
Swfi_4b256HashcodeBin:	str(32);		%^ 32-bytes = 256 bit binary hashcode.
Swfi_8b256HashcodeBin:	str(32);
Swfi_block_8_1:		vstr(10000);
Swfi_block_8_2:		vstr(10000);
Swfi_block_8_prep:	vstr(10000);
Swfi_pki_receiver_bic:	Str(8);
Swfi_Vstr_ws:		VSTR(80);
Swfi_iStatus:		long;
Swfi_Ascii_block_8:	Vstr(30000);
Swfi_block_8_encode:	Vstr(30000);
Swfi_alt_BIC:		Str(8);
Swfi_Block_8_tmp:	Vstr(80);
Swfi_block_8_digest:	Str(44);
Swfi_need_PKI:		Boolean;
Tpspkiauthdone_ws:	Boolean;

%End



%Work

* Overlay to convert a binary byte to a longword

01  Long_mask 		%Long;
01  REDEFINES Long_mask.
    05	Mask_low 	PIC X(1).
    05	Mask_high 	PIC X(3).

%PROCEDURE.


A100_MAIN_PROGRAM.

* Connect/init subjects that aren't bank-specific.
	Call "DAT_CONN_ROOT_AND_MSG".
*
* Determine the initial bank:
*	- if the process was started with a -bank XXX switch, get its value.
*	- otherwise, just connect to the first bank in BNK_INDEX.
*
	%Beg  Swfi_default_bank = "   "; %End 
	If Ace_arg_count > 1
	Then
	   Call "ACE_ARG_FIND" using
               by content   Z"-b*ank",
               by content   "U",
               by value     3,
               by reference Swfi_default_bank,
               by reference Swfi_default_bank_length,
               by reference OMITTED,
               by reference OMITTED,
             returning Swfi_temp_status
	End-if.

	If (Swfi_default_bank  = SPACES )
	    OR (Swfi_default_bank_length = 0 )
	THEN
	    %Beg
	    Mapsh_program_name = "SWFIN ";
	    %End
	ELSE
	    %Beg
	    Swfi_misc_compose ^OUT(Mapsh_program_name)
		"SWFIN -bank ", Swfi_default_bank, / ;
	    %End
	END-IF.
	
***************************************************************************
* Make sure tables are loaded
*
	CALL "MAP_TABLES"
	    Returning Swfi_find_status.
        If Failure_IS in Swfi_find_status then
	    Call "NEX_CREATE_AND_BROADCAST_MSG" Using 
		by content	Z"MAPPER$_NO_TABLE"
		by value	-1
		%ace_msg_arg_list(Mapsh_program_name);
	    %Exit Program
	End-if.



***************************************************************************
* Perform initialization
*
	PERFORM B100_SBJ_INIT THRU B100_SBJ_INIT_END.
*
* Loop to dequeue messages and process them
*
	PERFORM B200_PROCESS_MSG THRU B200_PROCESS_MSG_END UNTIL
		Swfi_loop_forever = ZERO.

%^ End processing rule API trace

	Call "PRULE_TRACE_OFF" returning Swfi_turned_off.


	%EXIT PROGRAM;.
A100_MAIN_PROGRAM_END.
	EXIT.

B100_SBJ_INIT.
* Initialization:
*
%^
%^ Connect to the logs and queues we need
%^
	%ACE_CONN_ROOT_Q Swift_index;
	%ACE_CONN_ROOT_Q Rmt_index ;
	%ACE_CONN_ROOT_Q Cur_frx_index ;
	%ACE_CONN_ROOT_Q Cur_iso_index ;
	%beg
	Dat_root_set.Aux_db_set CONN: Aux_db_set(NOMOD,
	.Aux_sname_index CONN: Aux_sname_index(READ_ONLY) );

%^ Connect queues/logs with null bank/loc/
%^
	Swfi_que_id_rec = NULL ;
	%End

%^ Begin processing rule API trace

	Call "PRULE_CHECK_TRACE" returning Swfi_turned_on.


	If Not_loaded_is in Swfi_cfg_values_state then

	   Call "GCV_CLS_ENABLED" using
		by reference Swfi_cls_enabled
	   Set Loaded_is in Swfi_cfg_values_state to TRUE
	   Call "GCV_MAP_GL_OVERRIDE" using
		by reference Swfi_gl_override

	    Call "GCV_JUSTIFICAT_PAYMENT" Using 
			By Reference Swfi_Justificat_payment
	    Call "GCV_REG_ID" Using
			By Reference Swfi_Just_reg_id_req
	    Call "GCV_AUTRV_AUTOMATED"
		using by reference Swfi_autrv_automated
	    Call "GCV_AUTRV_EXC_ROUTING"
		using by reference Swfi_autrv_exc_routing
	    Call "GCV_RES_CTRY_DISPL"
	         using by reference Swfi_res_ctry_displ

	   Set Loaded_is in Swfi_cfg_values_state to TRUE

	End-if.



*
* Connect all BKE queues
*
	Perform B101_CONN_BKE_QUEUES thru B101_CONN_BKE_QUEUES_END.

*
* Connect round-robin logical queue to a single bank specific (or all)
* Swfinq message queues.
*
	If (Swfi_default_bank_length NOT = 0 )
	   AND (Swfi_default_bank NOT = SPACES )
	THEN
%^ We are in single-bank mode.
	    %Beg
	    Swfi_reset_bank = Swfi_default_bank ;
	    Swfi_que_id_rec(.Idbank = Swfi_default_bank,
			   .Idname = "SWFINQ" ) ;
	    %End
	    %ACE_CONN_Q Swfi_que_id_rec TO Mapsh_swfinq FOR INSERT ;
	    If (Success_Is in Mapsh_swfinq_status )
		%Beg
		ALLOC_TEMP: Mapsh_swfinq_lq(LOGICAL);
		Mapsh_swfinq_lq LINK: Mapsh_swfinq ;
		%End
	    END-IF
	ELSE
	    %Beg
	    ALLOC_TEMP: Mapsh_swfinq_lq(LOGICAL, ROTATING_DEQ );
	    FIRST: Bnk_index ;
	    Swfi_reset_bank = Bnk_index.Bnk_id ;
	    Swfi_que_id_rec.Idname = "SWFINQ" ;
	    %End
	    PERFORM UNTIL (SEQ_END_IS in Bnk_index_cursor)
		%Beg
	        BREAK: Mapsh_swfinq ;
		Swfi_que_id_rec.Idbank = Bnk_index.Bnk_id;
		%End
	        %ACE_CONN_Q Swfi_que_id_rec TO Mapsh_swfinq FOR INSERT ;
	        If (Success_Is in Mapsh_swfinq_status )
		    %Beg  Mapsh_swfinq_lq LINK: Mapsh_swfinq ; %End
	 	END-IF
		%Beg
		NEXT: Bnk_index ;
		%End
	    END-PERFORM
	END-IF.

* Optionally change the input queue based on input command line argument -q[ueue].
	Call "CUST_SWFIN_CMD_LINE".

	%Beg
	Mapsh_swfinq_lq(FORWARD);
	Mapsh_future_date = Fut_bound_date_ws ;
	Mapsh_back_date = Backdate_bound_date_ws ;
	Mapsh_current_bnk_key = Swfi_reset_bank ;
	%End

	CALL "SET_BANK_CONTEXT". 

	%Beg
	Fut_bound_date_ws = Mapsh_future_date ;
	Backdate_bound_date_ws = Mapsh_back_date ;
	%End

* Check if CLASS_LOCS table is present.
	Move %SIZ(Swfi_cl_table_entry) to Swfi_temp_size.
	%Beg
	Swfi_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
			  .Idprod = "MTS", 	   
			  .Idbank =  Menu_bnk_union.Bnk_id,    
	 		  .Idloc  = null,    	   
	 		  .Idcust = null);
	Swfi_seq_ordinal_ws = <1>;

	Swfi_item_key = "CLASS_LOCS:";	
	Swfi_misc_compose ^OUT(Swfi_item_type_ws )
		"STR(", Swfi_temp_size, ")", / ;
	%End       
	Call "CFG_GET_ITEM" USING
	    BY Reference Idname of Swfi_union_key_ws
	    BY Reference Idprod of Swfi_union_key_ws
	    BY Reference Idbank of Swfi_union_key_ws
	    BY Reference Idloc of Swfi_union_key_ws
	    BY Reference Idcust of Swfi_union_key_ws
	    BY Reference Swfi_item_key
	    By Reference Swfi_seq_ordinal_ws
	    By Reference Swfi_item_type_ws
	    By Reference Swfi_item_data_ws
	    By Reference Swfi_item_data_ws_length
	    By Reference Swfi_error_msg_ws
	    By Reference Swfi_error_msg_ws_length
          RETURNING Swfi_class_locs

	%Beg
	Swfi_union_key_ws(.Idname = "SWIFT_TELEX_TABLES",
			  .Idprod = "MTS", 	   
			  .Idbank = Menu_bnk_union.Bnk_id,    
	 		  .Idloc  = null,    	   
	 		  .Idcust = null);
	Swfi_item_key = "SWF_BRANCH_CODES:";	
	Swfi_item_type_ws = "VSTR(42)";
	%End       
	Call "CFG_GET_ITEM" USING
	    BY Reference Idname of Swfi_union_key_ws
	    BY Reference Idprod of Swfi_union_key_ws
	    BY Reference Idbank of Swfi_union_key_ws
	    BY Reference Idloc of Swfi_union_key_ws
	    BY Reference Idcust of Swfi_union_key_ws
	    BY Reference Swfi_item_key
	    By Reference Swfi_seq_ordinal_ws
	    By Reference Swfi_item_type_ws
	    By Reference Swfi_item_data_ws
	    By Reference Swfi_item_data_ws_length
	    By Reference Swfi_error_msg_ws
	    By Reference Swfi_error_msg_ws_length
          RETURNING Swfi_branch_codes


%^ Now see if FED is a valid advice type.
	%Beg
	Swfi_union_key_ws.Idname = "FIELD_EDIT_TABLES";
	Swfi_item_key = "CREDIT_ADV_TYPES:";
	Swfi_match_key = "FED" ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    By Reference Idname of Swfi_union_key_ws
            By Reference Idprod of Swfi_union_key_ws
            By Reference Idbank of Swfi_union_key_ws
            By Reference Idloc  of Swfi_union_key_ws
            By Reference Idcust of swfi_union_key_ws
            By reference Swfi_item_key
   	    By Reference Swfi_match_key
            By Reference Swfi_match_key_length
      	    By Reference Swfi_seq_ordinal_ws
            By Reference Swfi_error_msg_ws
            By Reference Swfi_error_msg_ws_length
          Returning Mapsh_allow_fed_advice


 %^ Now see if WIR is a valid advice type.
	%Beg
	Swfi_union_key_ws.Idname = "FIELD_EDIT_TABLES";
	Swfi_item_key = "CREDIT_ADV_TYPES:";
	Swfi_match_key = "WIR" ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    By Reference Idname of Swfi_union_key_ws
            By Reference Idprod of Swfi_union_key_ws
            By Reference Idbank of Swfi_union_key_ws
            By Reference Idloc  of Swfi_union_key_ws
            By Reference Idcust of swfi_union_key_ws
            By reference Swfi_item_key
   	    By Reference Swfi_match_key
            By Reference Swfi_match_key_length
      	    By Reference Swfi_seq_ordinal_ws
            By Reference Swfi_error_msg_ws
            By Reference Swfi_error_msg_ws_length
          Returning Mapsh_allow_wir_advice
 
%^ Now see if Chips is a valid advice type.
	Call "IS_SWF_CLEARHOUSE" USING
	    By Content "   "     %^ Blank bank name forces search of all banks.
            By Content "CP"
          Returning Mapsh_allow_chp_advice
 
%^ Now see if CHK is a valid advice type.
	%Beg
	Swfi_union_key_ws.Idname = "FIELD_EDIT_TABLES";
	Swfi_item_key = "CREDIT_ADV_TYPES:";
	Swfi_match_key = "CHK" ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    By Reference Idname of Swfi_union_key_ws
            By Reference Idprod of Swfi_union_key_ws
            By Reference Idbank of Swfi_union_key_ws
            By Reference Idloc  of Swfi_union_key_ws
            By Reference Idcust of swfi_union_key_ws
            By reference Swfi_item_key
   	    By Reference Swfi_match_key
            By Reference Swfi_match_key_length
      	    By Reference Swfi_seq_ordinal_ws
            By Reference Swfi_error_msg_ws
            By Reference Swfi_error_msg_ws_length
          Returning Mapsh_allow_chk_advice
	If (Failure_is in Mapsh_allow_chk_advice)
	    %Beg  Swfi_match_key = "CHQ";  %End       
	    Call "CFG_MATCH_ITEM" USING
		By Reference Idname of Swfi_union_key_ws
		By Reference Idprod of Swfi_union_key_ws
		By Reference Idbank of Swfi_union_key_ws
		By Reference Idloc  of Swfi_union_key_ws
		By Reference Idcust of swfi_union_key_ws
		By reference Swfi_item_key
		By Reference Swfi_match_key
		By Reference Swfi_match_key_length
		By Reference Swfi_seq_ordinal_ws
		By Reference Swfi_error_msg_ws
		By Reference Swfi_error_msg_ws_length
              Returning Mapsh_allow_chk_advice
	END-IF.


 
* Build ISO IDENTIFIERS sequence from INTRTL.
        %Beg
	ALLOC_TEMP: Mapsh_iso_id_seq(MOD) ;
	COMMIT_TEMP: Mapsh_iso_id_seq ;
	Swfi_union_key_ws.Idname = "SWIFT_TELEX_TABLES";
	Swfi_seq_ordinal_ws = <1>;

	Swfi_item_key = "MAP_IDTYPE_IDENTIFIERS:";
	Swfi_item_type_ws = "VSTR(12)";
	%End

	Set Success_Is in Swfi_loop_status to TRUE
	Perform UNTIL (Failure_is in Swfi_loop_status )
	    Call "CFG_GET_ITEM" USING
	        BY Reference Idname of Swfi_union_key_ws
	        BY Reference Idprod of Swfi_union_key_ws
	        BY Reference Idbank of Swfi_union_key_ws
	        BY Reference Idloc of Swfi_union_key_ws
	        BY Reference Idcust of Swfi_union_key_ws
	        BY Reference Swfi_item_key
	        By Reference Swfi_seq_ordinal_ws
	        By Reference Swfi_item_type_ws
	        By Reference Swfi_item_data_ws
	        By Reference Swfi_item_data_ws_length
	        By Reference Swfi_error_msg_ws
	        By Reference Swfi_error_msg_ws_length
              RETURNING Swfi_loop_status
	    If (Success_Is in Swfi_loop_status)
		Add 1 to Swfi_seq_ordinal_ws
		%Beg
		Swfi_parse ^IN(Swfi_item_data_ws)
                	Swfi_tmp_old_id, "|", Swfi_tmp_new_id, /;
		ALLOC_END: Mapsh_iso_id_seq(.Isoid_name = Swfi_tmp_old_id,
					    .Isoid_field = Swfi_tmp_new_id ) ;
		%End
	    END-IF
	END-PERFORM.
  	%Beg  BEG: Mapsh_iso_id_seq(NOMOD );  %End



* Check for MAP_CODEWORDS_IN table (required)

	%Beg
	ALLOC_TEMP: Mapsh_code_tbl_seq (MOD);
	COMMIT_TEMP: Mapsh_code_tbl_seq ;
	Swfi_union_key_ws.Idname = "SWIFT_TELEX_TABLES";
	Swfi_seq_ordinal_ws = <1>;
	Swfi_item_key = "MAP_CODEWORDS_IN:";
	Swfi_item_type_ws = "VSTR(60)";
	%End

	Set Success_Is in Swfi_loop_status to TRUE
	Set Failure_Is in Swfi_found_default_ws to TRUE
	Perform UNTIL (Failure_is in Swfi_loop_status )
	    Call "CFG_GET_ITEM" USING
	        BY Reference Idname of Swfi_union_key_ws
	        BY Reference Idprod of Swfi_union_key_ws
	        BY Reference Idbank of Swfi_union_key_ws
	        BY Reference Idloc of Swfi_union_key_ws
	        BY Reference Idcust of Swfi_union_key_ws
	        BY Reference Swfi_item_key
	        By Reference Swfi_seq_ordinal_ws
	        By Reference Swfi_item_type_ws
	        By Reference Swfi_item_data_ws
	        By Reference Swfi_item_data_ws_length
	        By Reference Swfi_error_msg_ws
	        By Reference Swfi_error_msg_ws_length
              RETURNING Swfi_loop_status
	    If (Success_Is in Swfi_loop_status)
		Add 1 to Swfi_seq_ordinal_ws
		%Beg
		Swfi_parse ^IN(Swfi_item_data_ws)
                	Swfi_codeword_ws, "|", Swfi_codetext_ws, "|", Swfi_route_ws, "|",
			Swfi_bbi_ws, "|", Swfi_ordinal_ws, /;
		ALLOC_END: Mapsh_code_tbl_seq(.codeword_In = Swfi_codeword_ws,
						  .codetext = Swfi_codetext_ws,
						  .rte_by_code = Swfi_route_ws,
						  .bbi = Swfi_bbi_ws,
					          .ordinal = Swfi_ordinal_ws ) ;
		%End
		If Swfi_codeword_ws = "*" then
		   Set Success_is in Swfi_found_default_ws to True
	        End-if
	    END-IF
	END-PERFORM.
  	%Beg  BEG: Mapsh_code_tbl_seq (NOMOD) ;  %End


*	If Failure_IS in Swfi_find_status then
*	    Call "NEX_CREATE_AND_BROADCAST_MSG" Using 
*		by content	Z"MAPPER$_NO_TABLE"
*		by value	-1
*		%ace_msg_arg_list(Mapsh_program_name);
*	    %Exit Program
*	End-if.




*
* Build up our sequence of WRP queue names so we can tell when we hit one.
*
        %Beg
	ALLOC_TEMP: Mapsh_wrp_que_seq(MOD) ;
	COMMIT_TEMP: Mapsh_wrp_que_seq ;
	Swfi_union_key_ws.Idname = "REPAIR_VERIFY_TABLES";
	Swfi_seq_ordinal_ws = <1>;

	Swfi_item_key = "WRP_RPR_Q:";
	Swfi_item_type_ws = "VSTR(60)";
	%End

	Set Success_Is in Swfi_loop_status to TRUE
	Perform UNTIL (Failure_is in Swfi_loop_status )
%^ Get the WRP repair queues.
	    Call "CFG_GET_ITEM" USING
	        BY Reference Idname of Swfi_union_key_ws
	        BY Reference Idprod of Swfi_union_key_ws
	        BY Reference Idbank of Swfi_union_key_ws
	        BY Reference Idloc of Swfi_union_key_ws
	        BY Reference Idcust of Swfi_union_key_ws
	        BY Reference Swfi_item_key
	        By Reference Swfi_seq_ordinal_ws
	        By Reference Swfi_item_type_ws
	        By Reference Swfi_item_data_ws
	        By Reference Swfi_item_data_ws_length
	        By Reference Swfi_error_msg_ws
	        By Reference Swfi_error_msg_ws_length
              RETURNING Swfi_loop_status
	    If (Success_Is in Swfi_loop_status)
		Add 1 to Swfi_seq_ordinal_ws
		%Beg
		Swfi_parse ^IN(Swfi_item_data_ws)
                	"/", ^OPTION(^STRING),  "/", ^OPTION(^STRING),  "/",
			^OPTION(^STRING),  "/", Swfi_q_name,
			"/", ^OPTION ("(", ^STRING, ")" ), /;
		%End
		If Success_is in Swfi_parse_status then
		   %Beg ALLOC_END: Mapsh_wrp_que_seq(.wrpq_name = Swfi_q_name ) ; %End
		End-if
	    END-IF
	END-PERFORM.
	%Beg
	Swfi_seq_ordinal_ws = <1>;

	Swfi_item_key = "WRP_EXC_Q:";
	%End

	Set Success_Is in Swfi_loop_status to TRUE
	Perform UNTIL (Failure_is in Swfi_loop_status )
%^ Get the WRP exception queues.
	    Call "CFG_GET_ITEM" USING
	        BY Reference Idname of Swfi_union_key_ws
	        BY Reference Idprod of Swfi_union_key_ws
	        BY Reference Idbank of Swfi_union_key_ws
	        BY Reference Idloc of Swfi_union_key_ws
	        BY Reference Idcust of Swfi_union_key_ws
	        BY Reference Swfi_item_key
	        By Reference Swfi_seq_ordinal_ws
	        By Reference Swfi_item_type_ws
	        By Reference Swfi_item_data_ws
	        By Reference Swfi_item_data_ws_length
	        By Reference Swfi_error_msg_ws
	        By Reference Swfi_error_msg_ws_length
              RETURNING Swfi_loop_status
	    If (Success_Is in Swfi_loop_status)
		Add 1 to Swfi_seq_ordinal_ws
		%Beg
		Swfi_parse ^IN(Swfi_item_data_ws)
                	"/", ^OPTION(^STRING),  "/", ^OPTION(^STRING),  "/",
			^OPTION(^STRING),  "/", Swfi_q_name,
			"/", ^OPTION ("(", ^STRING, ")" ), /;
		%End
		If Success_is in Swfi_parse_status then
		   %Beg ALLOC_END: Mapsh_wrp_que_seq(.wrpq_name = Swfi_q_name ) ; %End
		End-if
	    END-IF
	END-PERFORM.
	%Beg  BEG: Mapsh_wrp_que_seq(NOMOD );  %End
	Move "$$$SWF" to Opr_login_id of Menu_opr_union.
	CALL "SET_DATES".
	set failure_is in Swfi_arg_audit_error to true.
	    %^ Check for Argument to write results to msg history
	    Call "ACE_ARG_FIND" using
		by content Z"-audit_err*or",
		by content "L"
		Omitted
		Omitted
		Omitted
		Omitted
		Omitted
		returning Swfi_arg_audit_error.

B100_SBJ_INIT_END. EXIT.

B101_CONN_BKE_QUEUES.
*
* Attempt to connect all USE/BKE related queues
*
* BKE_BLKLSTQ - BKE blacklist
*
	%BEG Swfi_que_id_rec.Idname = "BKE_BLKLSTQ"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_cv_bl_que;.
	If Failure_Is in Bke_cv_bl_que_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* BKE_BL_CTXQ - BKE blacklist initialization protocol context queue
*
	%BEG Swfi_que_id_rec.Idname = "BKE_BL_CTXQ"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_bl_ctx_que;.
	If Failure_Is in Bke_bl_ctx_que_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* BKE_CTXQ - BKE contexts queue
*
	%BEG Swfi_que_id_rec.Idname = "BKE_CTXQ"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_ctx_que;.
	If Failure_Is in Bke_ctx_que_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* BKE_CV_CTXQ - Certification protocol context queue
*
	%BEG Swfi_que_id_rec.Idname = "BKE_CV_CTXQ"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_cv_ctx_que;.
	If Failure_Is in Bke_cv_ctx_que_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* BKE_CV_ID_Q - Certificate list
*
	%BEG Swfi_que_id_rec.Idname = "BKE_CV_ID_Q"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_cv_id_que;.
	If Failure_Is in Bke_cv_id_que_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* BKE_DSC_CTXQ - Discontinuation context queue
*
	%BEG Swfi_que_id_rec.Idname = "BKE_DSC_CTXQ"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_disc_ctx_que;.
	If Failure_Is in Bke_disc_ctx_que_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* BKE_LOG - BKE event log (connect to END for chronological insertion)
*
	%BEG Swfi_que_id_rec.Idname = "BKE_LOG"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_log;.
	If Failure_Is in Bke_log_STATUS
	  then	Move "F" to Swfi_bke_installed
		Go to B101_CONN_BKE_QUEUES_END
	End-if.
*
* Carry forward BKE_LOG settings
*
	%BEG LAST: Bke_log; %END.
	If SEQ_BEG_IS in Bke_log_CURSOR
	  then	%BEG
		PREV_PERIOD: Bke_log;		%^ Last allocated period
		LAST: Bke_log;			%^ Last element
		ALLOC_ELEM: Bke_log(
			.Systime NOW,
			.Log_type STATUS_LOG,
			.Memo = "SOD Entry carried forward by SWFIN" );
		COMMIT: Tran;
		%END
	End-if.
*
* BKE_RV_CTXQ - Certificate Revocation protocol context queue
*
	%BEG Swfi_que_id_rec.Idname = "BKE_RV_CTXQ"; %END.
	%ACE_CONN_Q Swfi_que_id_rec TO Bke_cv_rv_ctx_que;.
	If Failure_Is in Bke_cv_rv_ctx_que_STATUS
	  then	Move "F" to Swfi_bke_installed
***		Go to B101_CONN_BKE_QUEUES_END
	End-if.

B101_CONN_BKE_QUEUES_END. EXIT.

B200_PROCESS_MSG.
*
* Get next message
*
	%BEG
        Mapsh_deq_tran Assign: Mapsh_Swfinq_lq;
 	Mapsh_swfinq_lq  DEQ_WAIT: Ent_msg_history(MOD);
	CHANGE: Message_domain;
	TRAN Assign: Ent_msg_history;
	%END

	if (Failure_Is in Mapsh_swfinq_lq_status)
	then
	    CALL "NEX_CREATE_AND_BROADCAST_MSG" using 
		by content	Z"SWFIN$_DEQWAITERR"
		by value	-1
		%ace_msg_arg_list(Mapsh_program_name, Mapsh_swfinq_lq_status);
	    %Exit Program
	end-if.


* Period change?
	call "entpf_refresh_pf_info".

*
* Carry forward BKE_LOG settings when SOD has occurred, for 24X7 operations
*
*
* BKE_LOG - BKE event log (connect to END for chronological insertion)
*
	If Swfi_bke_installed = "T"
	Then
	    %BEG LAST: Bke_log; %END
	    If SEQ_BEG_IS in Bke_log_CURSOR
	    then	%BEG
		PREV_PERIOD: Bke_log;		%^ Last allocated period
		LAST: Bke_log;			%^ Last element
		ALLOC_ELEM: Bke_log(
			.Systime NOW,
			.Log_type STATUS_LOG,
			.Memo = "SOD Entry carried forward by SWFIN" );
		COMMIT: Tran;
		%END
	    End-if
	End-if.

	%Beg
%^ Lock the message
	Ent_msg_history TOP: Ent_msg_union(MOD);
	%End
*
*
* Initializations for loop
*
	%Beg
	Mapsh_swfrout_mode = NULL ;
	Mapsh_swfrout_command = NULL ;
	Mapsh_swfrout_id = NULL ;
	Mapsh_swfrout_queue = NULL ;
	Mapsh_swfrout_type = NULL ;
	Mapsh_swfrout_carrier = NULL ;
	Mapsh_swfrout_format = NULL ;
	Mapsh_swfrout_route_id = NULL ;
 	Mapsh_rte_codeword = NULL;
	Mapsh_rtg_option_save = <0> ;
	Mapsh_full_parse_flag = "Y" ;		
	Mapsh_charge_state = "T" ;
	Mapsh_memo_count = <0> ;
	Mapsh_notice_ctr = <0> ;
	Swfi_special_mapping = NULL ;
	Mapsh_current_bnk_key = Swfi_reset_bank ;
	Mapsh_agreement_cdwrd = NULL;
	Hget_summary_status = NULL;
	Mapsh_msg_command = "$$$SWF";
	Mapsh_dbt_account_type = NULL;
	Mapsh_cdt_account_type = NULL;
	MapProp_Fx_found = NULL; 
	%End

	CALL "SET_BANK_CONTEXT". 

	Set Success_Is in Mapsh_dbt_auth_status to TRUE.
	Set Success_is in Swfi_route_msg to TRUE.
	Set Failure_Is in Swfi_prelookup_by_name to TRUE.
	Set Failure_IS in Mapsh_found_cls to TRUE.
	Set Success_is in Swfi_mapping_status to TRUE.
	Set Success_is in Swfi_hostget_call to TRUE.
	Set Success_is in Swfi_agreement_ok to TRUE.
	Set Failure_is in Mapsh_warehouse to TRUE.
	Set Failure_is in Mapprop_Fx_status to TRUE.
	Initialize Mapprop_fx_found


	%Beg
	BREAK: Mapsh_msg_cnf_seq;
	ALLOC_TEMP: Mapsh_Msg_cnf_seq (Mod, Init);
	BREAK: Mr_rout_cond_seq;
	ALLOC_TEMP: Mr_Rout_cond_seq (Mod, Init);
	%End


*   
* Refresh current date stuff if period date has changed
* Determine next business day
*
	%Beg  Swfi_current_date Current_period;  %End
	If (Swfi_current_date NOT = Mapsh_todate )
		CALL "SET_DATES" 
	END-IF.
*
* If there is a routing override, remember it.
*

	IF Memo OF Ent_msg_history(1:5) = "*MRH/" THEN
	    MOVE Memo OF Ent_msg_history (6:) TO Mapsh_route_ovr_str
	ELSE
	    MOVE SPACES TO Mapsh_route_ovr_str
	END-IF.


%^	If (memo of Ent_msg_history(1:8) = "AUTHDONE") 
%^	   Move "T" to Mapsh_child_msg_flag
%^	Else
%^	   Move "F" to Mapsh_child_msg_flag
%^	End-if.


	Move "F" to Mapsh_child_msg_flag
	Set Failure_is in Swfi_pde_done to TRUE
	Set Success_is in Swfi_temp_status to TRUE.

	%Beg
	   BREAK: Swfi_Lcl_msg_history;
	   Ent_msg_union.Msg_history Conn: Swfi_Lcl_msg_history(NOMOD);
	   End: Swfi_Lcl_msg_history;
	   SCAN: Swfi_Lcl_msg_history (BACKWARD, Scan_key = "SWFINQ");
	   Swfi_temp_status = Swfi_Lcl_msg_history Status;
	%End.

	Set Failure_Is in Tpspkiauthdone_ws to True.
	If Success_is in Swfi_temp_status then
	   If (memo of Swfi_lcl_msg_history(1:8) = "AUTHDONE") OR		
		(memo of Swfi_lcl_msg_history(1:14) = "TPSPKIAUTHDONE")
%^ #138763 Check for a possible duplicate memo in a previous message history.
%^	   If so, then set the flag to "F" and Swf_parse_trailer can check for
%^	   a PDE item.  The message will then be routed to the Swfpdmq queue.
%^	   Continue to keep the code to (Move "T" to Mapsh_child_msg_flag), use another
%^	   indicator when checking for the "possible duplicate".  Use this indicator when
%^	   checking the Parse_swf_trailer for PDE.

	   Then
		If (memo of Swfi_lcl_msg_history(1:8) = "AUTHDONE")
			Move "T" to Mapsh_child_msg_flag
		Else
		        Set Success_Is in Tpspkiauthdone_ws to True
		End-if

		Move "F" to Swfi_pos_dup_flag
		Set Success_is in Swfi_temp1_status to True
	   	Perform until (failure_is in Swfi_temp1_status)
	      	    %Beg
	      	    	SCAN_CONT: Swfi_Lcl_msg_history (BACKWARD, Scan_key = "AUTHFAILQ"); 
	      	    	Swfi_temp1_status = Swfi_Lcl_msg_history Status;
	      	    %End

	      	    If Success_is in Swfi_temp1_status 
		    Then
		    	%Beg
		    	    PREV: Swfi_lcl_msg_history;
		    	%End
		    	If (memo of Swfi_lcl_msg_history(1:18) = "Possible duplicate")
		    	Then 
	      	    	    Move "T" to Swfi_Pos_dup_flag
		    	End-if
		    	%Beg
		    	    NEXT: Swfi_lcl_msg_history;
		    	%End
			Set Failure_is in Swfi_temp1_status to True
		    End-if
		End-perform
	   End-if

	   If memo of Swfi_lcl_msg_history(1:7) = "PDEDONE" then
	      Set Success_is in Swfi_pde_done to TRUE
	   End-if

	   Perform until (failure_is in Swfi_temp_status)
	      %Beg
	      SCAN_CONT: Swfi_Lcl_msg_history (BACKWARD, Scan_key = "SWFINQ"); 
	      Swfi_temp_status = Swfi_Lcl_msg_history Status;
	      %End

	      If Success_is in Swfi_temp_status then

	         If (memo of Swfi_lcl_msg_history(1:8) = "AUTHDONE") 

%^ #138763 Check for a possible duplicate memo in the previous message history.
%^	   If so, then set the flag to "F" and Swf_parse_trailer can check for
%^	   a PDE item.  The message will then be routed to the Swfpdmq queue.

		   		Move "F" to Swfi_pos_dup_flag
		    		Set Success_is in Swfi_temp1_status to True
	   	    		Perform until (failure_is in Swfi_temp1_status)
	      	    			%Beg
	      	    		   	 SCAN_CONT: Swfi_Lcl_msg_history (BACKWARD, Scan_key = "AUTHFAILQ"); 
	      	    		   	 Swfi_temp1_status = Swfi_Lcl_msg_history Status;
	      	    			%End

	      	    			If Success_is in Swfi_temp1_status 
		    			Then
		    	    			%Beg
		    	    				PREV: Swfi_lcl_msg_history;
		    	    			%End
		    	    			If (memo of Swfi_lcl_msg_history(1:18) = "Possible duplicate")
		    	    			Then 
	      	    	    				Move "T" to Swfi_Pos_dup_flag
		    	    			End-if
		    	    			%Beg
		    	    				NEXT: Swfi_lcl_msg_history;
		    	     			%End
			    			Set Failure_is in Swfi_temp1_status to True
		    			End-if
				End-perform
			End-if
			If memo of Swfi_lcl_msg_history(1:7) = "PDEDONE" then
	      			Set Success_is in Swfi_pde_done to TRUE
	      		End-if	      
		End-if
	     End-perform
	End-if.
	%Beg BREAK: Swfi_Lcl_msg_history; %End.

*
* Connect to the rest of the message and get its header
*
	%BEG
	Swfi_hist_memo = NULL;
	Swfi_cust_memo = NULL;
	Prev: Ent_msg_history;
	Mapsh_deq_memo_vstr = ent_msg_history.memo;	%^ Save DEQ memo
	Last:ent_msg_history;
	%End
	CALL "DAT_CONN_MSG"

	%Beg
	Ent_ftr_set(MOD);
	Ent_debit_set(MOD);
	Ent_credit_set(MOD) ;
	Ent_trade_detail_set(MOD) ;

	Ent_msg_union(NOTRAP);
	Ent_msg_union.codeword_seq CONN: Ent_codeword_seq(MOD);
	Ent_msg_union(ETRAP);

	Ent_ftr_set.inst_date NOW;
	FIRST: Ent_text_seq(MOD);
	%END.


	If Mapsh_deq_memo_vstr(1:11) = "WAREHOUSING" then
	   Set Success_is in Swfi_codeword_status to TRUE
 	   CALL "CUST_CODEWORD_CHECK" returning Swfi_codeword_status
	End-if




*
* Set Cross bank search flag for call to Lookup Routines
*
	If ( Cross_Bank_Search OF Menu_cfg = "T" OR
	     Cross_Bank_Search OF Menu_cfg = "Y" )THEN
	     Move "Y" to Mapsh_Cross_bank_search
	Else Move "N" to Mapsh_Cross_bank_search
	End-if.


************************************************************************
* New Header Parse Subroutine for SWF
*
*
* Parse/edit output message header.
*
	%Beg
	Mapsh_send_id = NULL;
	Mapsh_send_idtype = NULL;
	%End
	CALL "PARSE_SWF_HEADER" USING 
	    BY REFERENCE Swfi_branch_codes
	    BY REFERENCE Swfi_hist_memo_length
	    BY REFERENCE Swfi_hist_memo
	  Returning Swfi_header_status.


	If Failure_Is in Swfi_header_status
	  then
		Move "N" to Mapsh_full_parse_flag
		Move "F" to Mapsh_charge_state
		%Beg
	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	        .Rcs_Command  	= "EPR"),
					     .Rcs_Routing_Str   	= "",
					     .Rcs_Rtg_Memo1	   	= "",
					     .Rcs_Rtg_Memo2	   	= "*MRH/MAP/EPR/N");
		%End 
     
                If Swfi_hist_memo not = spaces
	           PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
	        End-if

		Go to B200_PROCESS_MSG_CLEANUP
	End-if.

 

	If (Swfshl2_msg_type of Swfs_hdr_line2 = "100" or "103" or "200" or "202" or "205") OR
	   ((Swfshl2_msg_type of Swfs_hdr_line2 = "300" or "304" or "392" or "398") AND (Swfi_cls_enabled = "Y")) then

	   Move 1 to Mapsh_payment
	Else
	   Move 0 to Mapsh_payment
	End-if. 

	%^ Double check to see that the message type has been properly posted
	%^ to the Ftr set - sometimes it comes in empty
	IF Incoming_MsgType of Ent_Ftr_Set = SPACES
        OR Incoming_MsgType of Ent_Ftr_Set NOT =
					    Swfshl2_Msg_Type of Swfs_Hdr_Line2
	THEN
	   %Beg
	      Ent_Ftr_Set.Incoming_MsgType = Swfs_Hdr_Line2.Swfshl2_Msg_Type;
	   %End
	END-IF.

	Initialize Swfi_orig_msgtype
	If Orphan_is in Msgsubtype_oneof of Ent_msg_union or
            Child_is in Msgsubtype_oneof of Ent_msg_union then

	    %Beg Swfi_Compose ^OUT(Swfi_prule_param_name), "MTS$ORIGINAL_SWF_MSG_TYPE", /; %END

	    Perform X800_GET_PRULE_PARAM thru X800_GET_PRULE_PARAM_END

	    If Success_is in Swfi_prule_status and
	       Swfi_prule_value_length > ZERO then
		%Beg Swfi_orig_msgtype = Swfi_prule_value; %End
	    End-if

	End-if

	If sbk_id of sbk of ent_debit_set not = spaces then
	   %Beg
	    Mapsh_send_id = Ent_debit_set.sbk.sbk_id;
	    Mapsh_send_idtype = Ent_debit_set.sbk.sbk_idtype;
	   %End
	Else
            If Swfshl2_io_id of Swfs_hdr_line2 not = "I" and
               Swfi_orig_msgtype NOT = "101" then
	        %Beg
	        Mapsh_send_id = Swfs_send_id_ws;
	        Mapsh_send_idtype = "S";
	        %End
	    END-IF
	End-if.

*
*************************************************************************
*
* If Ent_ftr_set.incoming_format is not set to SWF, set it now.

	If Incoming_format of Ent_ftr_set not = "SWF" Then
	   %Beg Ent_Ftr_Set.Incoming_Format = "SWF"; %End
	End-if.
*
* Reset the ambiguous lookup flags if source has changed
* Use AMBIG_DBT_MAP_SOURCES config flag to determine the setting
* of MAPSH_CFG_DBT_AMBIG when calling DEBIT_LOOKUP for DDA lookups.
* A "T" is for banks which want the first address mapped in situations
* where ambiguousness would otherwise result in a lookup failure.
* Use AMBIG_CDT_MAP_SOURCES config flag to determine the setting
* of Mapsh_cfg_cdt_ambig when calling CREDIT_LOOKUP for DDA lookups.
* A "T" is for banks which want the first address mapped in situations
* where ambiguousness would otherwise result in a lookup failure.

	IF Src_code OF Ent_ftr_set NOT = Swfi_last_msg_src THEN
	    MOVE Src_code OF Ent_ftr_set TO Swfi_last_msg_src
 	    %BEG
	    Swfi_union_key_ws.Idname = "SOURCE_CODE_TABLES";
	    Swfi_item_key = "AMBIG_DBT_MAP_SOURCES:";
 	    Swfi_match_key = Swfi_last_msg_src ; 
	    %END       
	    Call "CFG_MATCH_ITEM" USING
	        By Reference Idname of Swfi_union_key_ws
                By Reference Idprod of Swfi_union_key_ws
                By Reference Idbank of Swfi_union_key_ws
                By Reference Idloc  of Swfi_union_key_ws
                By Reference Idcust of swfi_union_key_ws
                By reference Swfi_item_key
   	        By Reference Swfi_match_key
                By Reference Swfi_match_key_length
      	        By Reference Swfi_seq_ordinal_ws
                By Reference Swfi_error_msg_ws
                By Reference Swfi_error_msg_ws_length
              Returning Swfi_temp_status
	    If (Success_Is in Swfi_temp_status)
	        Move "T" to Mapsh_cfg_dbt_ambig
	    ELSE
	        Move "F" to Mapsh_cfg_dbt_ambig
	    END-IF
 	    %BEG
	    Swfi_item_key = "AMBIG_CDT_MAP_SOURCES:";
 	    Swfi_match_key = Swfi_last_msg_src ; 
	    %END       
	    Call "CFG_MATCH_ITEM" USING
	        By Reference Idname of Swfi_union_key_ws
                By Reference Idprod of Swfi_union_key_ws
                By Reference Idbank of Swfi_union_key_ws
                By Reference Idloc  of Swfi_union_key_ws
                By Reference Idcust of swfi_union_key_ws
                By reference Swfi_item_key
   	        By Reference Swfi_match_key
                By Reference Swfi_match_key_length
      	        By Reference Swfi_seq_ordinal_ws
                By Reference Swfi_error_msg_ws
                By Reference Swfi_error_msg_ws_length
              Returning Swfi_temp_status
	    If (Success_Is in Swfi_temp_status)
	        Move "T" to Mapsh_cfg_cdt_ambig
	    ELSE
	        Move "F" to Mapsh_cfg_cdt_ambig
	    END-IF
	END-IF.

**************************************************************************
*
*  NEW MAP_FIELDS SUBROUTINE TESTING
*

	If Incoming_msgtype of ent_ftr_set = "102" then
	   CALL "MAP_SWF_102" USING
		BY content "P"
	     Returning Swfi_child_status

	    If Failure_Is in Swfi_child_status then
	   	Move "N" to Mapsh_full_parse_flag
	   	%Beg
	   	ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	   .Rcs_Command  	= "EPR"),
					.Rcs_Routing_Str   		= "",
					.Rcs_Rtg_Memo1	   		= "",
					.Rcs_Rtg_Memo2	   		= "*MRH/MAP/EPR/N");
	   	%End 

           	%BEG Swfi_hist_memo = "Sequence C 32A not equal to sum of Sequence B 32B plus Sequence C 71G"; %END
	   	PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END

	   	GO TO B200_PROCESS_MSG_CLEANUP
	    End-if
	Else
	   If Incoming_msgtype of ent_ftr_set = "101" then
	      If Mapsh_deq_memo_vstr(1:11) NOT = "WAREHOUSING" then
	         CALL "MAP_SWF_101" USING
		    BY content "P"
	            Returning Swfi_child_status
	      End-if
	   Else

              CALL "MAP_FIELDS" USING
                   BY REFERENCE Swfi_special_mapping
	           Returning Swfi_mapping_status
	   End-if
	End-if.

	If Global_debit of Flgs4 of Ent_ftr_set = "P"
* Bulk parent, mark child creation in progress.
	    %Beg Ent_ftr_set.Flgs5.Childq_create_flg = "I"; %End
	End_if.

        If Incoming_msgtype of ent_ftr_set = "067" then
           CALL "SWF_READ_MT067"
             Returning Swfi_MT067_status
           If (Failure_is in Swfi_MT067_status) then
              Add 1 to Mapsh_Memo_count
           End-if
        End-if.


*...... Note: August 14, 2000: Move the following commented-out block of code to
*	      just before the call to Lqm_kick, near the end of B200.  This was
*	      what was done on VAX, GEN 119, so do it on AIX too.
*
* Post the incoming funds for liquidity purposes if applicable.  If LQM_POST
* succeeds, we will call LQM_KICK later on to wake the throttler after
* committing the message.
*	Set Failure_is in Swfi_kick_lqm to TRUE.
*	Call "GET_PID_ADV_CENTBANK" using
*	    by reference Bank of Loc_info of Ent_ftr_set
*	    by reference Src_code of Ent_ftr_set
*	    By Reference Swfi_centbank
*	    By Reference SwfI_centbank_length
*	  Returning Swfi_pid_status
*	If (Success_is in Swfi_pid_status )
*	   AND (Swfi_centbank_length NOT = 0 )
*	THEN
*	    Call "LQM_POST" Using
*	        By Reference Bank of Loc_info of Ent_ftr_set
*	        By Reference Swfi_centbank
*		By Reference Amount of Ent_ftr_set
*		By Reference Currency_code of Ent_ftr_set
*		By Reference Incoming_msgtype of Ent_ftr_set
*		By Reference SubType of Ent_ftr_set
*		By Reference Value_date of Typ of Ent_ftr_set
*		By Reference Trn_ref of Ent_ftr_set
*	      Returning Swfi_kick_lqm
*	END-IF.

	IF Cdt_Adv_Typ of Ent_Credit_Set = "FED"
	AND (Failure_Is in Mapsh_allow_Fed_Advice)
	THEN
	   %^ FED advice type not allowed, so clear out Cdt_Adv_Typ
	   SET Success_Is in Mapsh_Found_Fw TO TRUE
	   %Beg
	      Ent_credit_set.cdt_adv_typ = "   " ;
	      Ent_ftr_set.flgs.cdt_adv_flg = "" ;
	   %End
	END-IF.
	   


***************************************************************************
*
* NEW TRAILER PARSING SUBROUTINE:
*
* Dig through the trailer: should be positioned at start of trailer

%^ #138763 Checking for a possible duplicate being detected.  Temporarily
%^	   resetting Mapsh_child_msg_flag to "F".

	If Swfi_Pos_dup_flag = "T"
	Then
	    Move "F" to Mapsh_child_msg_flag
	End-if.

	CALL "PARSE_SWF_TRAILER" USING
	     BY REFERENCE Swfi_rcvd_mac
	     BY REFERENCE Swfi_rcvd_pac
	     BY REFERENCE Swfi_test_message
	     By REFERENCE Swfi_rcvd_pde
	     By REFERENCE Swfi_rcvd_pdm
      	  Returning Swfi_trailer_status.

%^ #138763 Reset both flags.

	If Swfi_Pos_dup_flag = "T"
	Then
	    Move "T" to Mapsh_child_msg_flag
	    Move "F" to Swfi_Pos_dup_flag
	End-if.

	If Failure_Is in Swfi_trailer_status then

	   Move "N" to Mapsh_full_parse_flag
	   %Beg
	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	   .Rcs_Command  	= "EPR"),
					.Rcs_Routing_Str   		= "",
					.Rcs_Rtg_Memo1	   		= "",
					.Rcs_Rtg_Memo2	   		= "*MRH/MAP/EPR/N");
	   %End 

 	   PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
       End-if.



* If there is {PDE in trailer and the SWFIN Enqueue memo is NOT PDEDONE
* then set the possible duplicate routing to true.

	If (Success_is in Swfi_rcvd_pde) and
	   (Failure_is in Swfi_pde_done) then

	    MOVE "N" TO Mapsh_full_parse_flag
	    %Beg
	    ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "POSDUP",
		       	        	   	    .Rcs_Command  	= "PDM"),
					 .Rcs_Routing_Str   		= "",
					 .Rcs_Rtg_Memo1	   		= "",
					 .Rcs_Rtg_Memo2	   		= "*MRH/MAP/PDM/N",
				         .Rcs_info_hist_memo		=  "Possible duplicate detected"); 

	    %End



	    %Beg Swfi_Compose ^Out(Swfi_hist_memo) "(PDE) message received as PDE",/;%End
	    PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
	End-if.




***************************************************************************

*
* AUTHENTICATION LOGIC:
*

	%Beg Swfi_tmp_rcvd_pac = Swfi_rcvd_pac; %End.
	Set Success_is in Swfi_Pki_sts to True	
	%^ If we have a PAC from an embedded TPS message, use it instead of
	%^ the PAC from the wrapper message.

	If (Mapsh_77e_fin_srvc = "TPS" or (Mapsh_mur_str = "CLS" and Incoming_msgtype of Ent_ftr_set = "398")) and
	   (Mapsh_77e_pac not = spaces)
	    %Beg 
	    Swfi_tmp_rcvd_pac = Mapsh_77e_pac;
	    %End
	end-if.

%^ To prevent carryover from a previous call to swf_access_control 
%^ remaining in sac_result_oneof, we will initialize it here

	Set Failure_Is in Sac_result_oneof to True.

	CALL "SWF_AUTHENTICATION" USING
	     BY REFERENCE Swfi_rcvd_mac
	     BY REFERENCE Swfi_tmp_rcvd_pac	
	     BY REFERENCE Swfi_test_message
	   Returning Swfi_auth_status.
%^	Determine where Swf Authorization occured (RMA/SAT) and
%^	write a Memo to Msg History detailing where that authorization was done
%^	and the reason, if any, why it failed.

	Evaluate True
		When Sat_success_is in Sac_result_oneof
        		%BEG	
			 Ent_ftr_set.Flgs2.Test_state_flg = "P";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			 "*SWF Authorization performed by SAT Successful.",/;
       		       %END	
		When Rma_Success_Is in Sac_result_oneof
			%BEG		 		
			 Ent_ftr_set.Flgs2.Test_state_flg = "P";     
		 	 Compose ^OUT(Swfi_auth_memo) 
			 "*SWF Authorization performed by RMA Successful.",/;
			%End
		When Rma_not_enabled_is in Sac_result_oneof		
		        %BEG	
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization performed by RMA Failed - RMA not Enabled",/;
			%End
		When Rma_invalid_period_is in Sac_result_oneof
		        %BEG		 	
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization performed by RMA Failed - Invalid Period",/;
			%End
		When Rma_cat_not_incl_is in Sac_result_oneof
		        %BEG	
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";	     
		  	 Compose ^OUT(Swfi_auth_memo) 
		 	 "*SWF Authorization performed by RMA Failed - Cat. not Included",/;
			%End
		When Rma_mt_exclued_is in Sac_result_oneof
		        %BEG		 	
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization performed by RMA Failed - Msg Type Excluded",/;
			%End
		When Rma_not_included_is in Sac_result_oneof	
		        %BEG		 
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization performed by RMA Failed - Msg Type Not Included",/;
			%End
		When Sat_Failure_is in Sac_result_oneof	
		        %BEG		 		
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization performed by RMA/SAT Failed",/;
			%End
		When Rma_Failure_is in Sac_result_oneof	
		        %BEG	
			 Ent_ftr_set.Flgs2.Test_state_flg = "F";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization performed by RMA Failed",/;
			%End		
		When Success_Is in Swfi_auth_status							
		        %BEG	     			 
		 	 Compose ^OUT(Swfi_auth_memo) 
			  "*SWF Authorization NOT required",/;
			%End		
%^ P - Auth in SWF, "A" in Test_req_flg - Force in SWF - KEEP.
	
			If Test_state_flg of Flgs2 of Ent_ftr_set = "P" OR
				(Test_state_flg of Flgs2 of Ent_ftr_set = " " AND
					Test_req_flg  of Flgs of Ent_ftr_set = "A")		   
				Continue	
			Else
				If Test_req_flg of Flgs of Ent_ftr_set = "A"   AND
						Test_state_flg of Flgs2 of Ent_ftr_set = "A"
					%Beg Ent_ftr_set.Flgs.Test_req_flg = "N";%End 	 
				Else											
		   			%BEG	
					 Ent_ftr_set.Flgs.Test_req_flg = "N"; 	 		
  		   			 Ent_ftr_set.Flgs2.Test_state_flg = " ";
		  			 %END
				End-if
			End-if

		When Other
			%BEG	
			 Ent_ftr_set.Flgs2.Test_state_flg = " ";	     
		 	 Compose ^OUT(Swfi_auth_memo) 
			  " ",/;
			%End	
	End-Evaluate

	If Swfi_auth_memo NOT = Spaces
		%Beg
            	 	 ALLOC_END: Ent_msg_history (
               			.Qname (
		    		.Idprod = null,
		    		.Idbank = Menu_bnk_union.Bnk_id,
	            		.Idloc = null,
	            		.Idcust = null,
		    		.Idname = "*SYS_MEMO"),
				.Qtype = "OBJTYP$_NULL",
				.Memo = Swfi_auth_Memo);
       		 %END			
	End-if.
	%Beg
            	Swfi_auth_memo = null;	
	%End.

	If Success_is in Swfi_auth_status AND Failure_Is in TPSPKIAUTHDONE_ws
	   Perform D300_PKI_CHECK thru D300_PKI_CHECK_EXIT
	End-if.

	If (Failure_Is in Swfi_auth_status) then

	    %Beg
	    Swfi_routing_memo = "";
	    Swfi_2nd_routing_memo = "";
	    Swfi_temp_memo = "";
	    Swfi_temp_command = "";
	    Swfi_hist_memo = ""; 
	    %End
	    Move "N" to Mapsh_full_parse_flag


	    If NOT Auth_required in Mapsh_pac_auth_sts then

	       If (Bypass in Mapsh_Fin_pac_mode) then
	           Move "PAB" to Swfi_temp_command
                   %Beg
		   Swfi_Compose ^Out(Swfi_hist_memo) "Fin copy service bypass mode detected", /; 
		   Swfi_Compose ^Out(Swfi_routing_memo),
	               "*/", Mapsh_Current_Bnk_Key, "/", "/", "/SWFINQ|PAC auth bypassed.",/;
	           %End

	       Else
	           Move "PAC" to Swfi_temp_command
	       End-if

	     End_if


	     If (NOT Bypass in Mapsh_Fin_pac_mode) then


	         If (AUTH_FAILED in Mapsh_pac_auth_sts ) OR
	            (SA2_AUTHFAIL in Mapsh_pac_auth_sts ) THEN

	            %Beg Swfi_compose ^OUT(Swfi_temp_memo) Mapsh_pac_auth_memo, / ; %End

%^ If memo is too long to append to routing memo, trim it.

	            If (Swfi_temp_memo_length > 54)
	               Move 54 to Swfi_temp_memo_length
	            END-IF
	         End-if


	        %BEG
	         Swfi_Compose ^OUT(Swfi_routing_memo),
	         	"*/", Mapsh_Current_Bnk_Key, "/", "/", "/SWFINQ|",
  		   	Mapsh_Pac_Auth_sts(^ONEOF(
	    			"PAC AUTH SUCCESS",
	    			"PAC AUTH NOT REQ",
	    			"PAC Authenticator key not found",
				^SUB("PAC Authfail: ", |Swfi_temp_memo),
	    			"PAC Authenticator result missing from trailer",
	    			"PAC Authenticator key has improper format",
	    			^SUB("PAC SA2fail: ", |Swfi_temp_memo) )), /;
	   	%END
	    END-IF



	    If NOT Auth_required in Mapsh_auth_sts then

	       Move "FAI" to Swfi_temp_command

	       If (AUTH_FAILED in Mapsh_auth_sts ) OR
	          (SA2_AUTHFAIL in Mapsh_auth_sts ) THEN

	           %Beg Swfi_compose ^OUT(Swfi_temp_memo) Mapsh_auth_memo, / ; %End

%^ If memo is too long to append to routing memo, trim it.

	      	   If (Swfi_temp_memo_length > 54)
	              Move 54 to Swfi_temp_memo_length
	           END-IF
	       End-if

	       If Failure_is in Swfi_Pki_sts
	       %BEG
	        COMPOSE ^OUT(Swfi_routing_memo),
		 	"*/", Mapsh_Current_Bnk_Key, "/", "/", "/SWFINQ|",  		   	
	    			"PKI Authfail", /;
	   	%END
	       Else
	       %BEG
	       COMPOSE ^OUT(Swfi_routing_memo),
		 	"*/", Mapsh_Current_Bnk_Key, "/", "/", "/SWFINQ|",
  		   	Mapsh_Auth_sts(^ONEOF(
                                "AUTHORIZATION OK",                             
                                "AUTHORIZ NOT REQ",   
                                "AUTHORIZATION Relation not found",
                                ^SUB("AUTHORZ FAIL: ", |Swfi_temp_memo),
	    			"MAC Authenticator result missing from trailer",
	    			"MAC Authenticator key has improper format",
	    			^SUB("MAC SA2fail: ", |Swfi_temp_memo) )), /;
	   	%END
		End-if

	   End-if

	   %Beg Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/", Swfi_temp_command, "/", Mapsh_full_parse_flag, /; %End

	    %Beg
	    ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "AUTH",
		       	        	   	    .Rcs_Command  	= Swfi_temp_command),
					 .Rcs_Routing_Str   		= "",
					 .Rcs_Rtg_Memo1	   		= Swfi_routing_memo,
					 .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);

	    %End

	    If Swfi_hist_memo not = spaces then
	       PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
	    End-if

	End-if.

**************************************************************************
*
* BKE-PROCESSING:
*
* Process BKE-related messages; on success, bypass routing and clean up.

	IF (Swfi_bke_installed = "T")
	   CALL "SWFIN_BKE"
	     Returning Swfi_temp_status
	   IF (Success_Is in Swfi_temp_status) then
	        %Beg
	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	        .Rcs_Command  	= "NUL"),
					     .Rcs_Routing_Str   		= "",
					     .Rcs_Rtg_Memo1	   	= "",
					     .Rcs_Rtg_Memo2	   	= "");
	        %End 
		SET Failure_is in Swfi_route_msg to TRUE
		GO TO B200_PROCESS_MSG_CLEANUP
	   END-IF
	END-IF.

****************************************************************************
*
* DELIVERY CONFIRMATION:
*
* If this is a delivery confirmation, attempt to tie it to the
* original
*
%^ #63474
        IF Swfshl2_msg_type of Swfs_hdr_line2 = "010" OR
           Swfshl2_msg_type of Swfs_hdr_line2 = "011" OR
           Swfshl2_msg_type of Swfs_hdr_line2 = "012" OR
           Swfshl2_msg_type of Swfs_hdr_line2 = "019"
        THEN
           CALL "PARSE_SWF_DLV_CNF" Using
                        By Reference Swfshl2_msg_type of Swfs_hdr_line2
                        Returning Swfi_delivery_status
        END-IF.


********************************************************************************
*
* SWF ROUTING TABLE:
*
* Look at the routing tables to see where this message goes next. If it
* is a funds transfer, proceed to parse it. Else deliver it to the specified
* queue.
	Move 8 to Swfi_fake_bic_length.
	%Beg Swfi_msg_currency = Ent_ftr_set.currency_code; %End

	If  Swfshl2m_in_branch of Swfshl2_Mir of Swfs_hdr_line2 Not = "XXX" then
	    %Beg
		Swfi_compose ^OUT(Swfi_temp_bic)
		     Swfs_hdr_line2.Swfshl2_Mir.Swfshl2m_in_adr,
		     Swfs_hdr_line2.Swfshl2_Mir.Swfshl2m_in_tid,
		     Swfs_hdr_line2.Swfshl2_Mir.Swfshl2m_in_branch,/;
	    %End

	Else
	   %Beg
		Swfi_compose ^OUT(Swfi_temp_bic) ^TRAILING_BLANKS,
		     Swfs_hdr_line2.Swfshl2_Mir.Swfshl2m_in_adr,/;
	   %end
	End-if

	If (Incoming_msgtype of Ent_Ftr_set = "300" or "304" or "392" or "398") and
	   (Swfi_cls_enabled = "Y") and
	   (Success_is in Mapsh_found_cls) then
           %Beg
	    Ent_msg_union.msgtype trade;
	    Ent_ftr_set.typ.tran_type = "TRA";
	    Swfi_swf_route_src = "TRD";
	   %End
	Else

	   %Beg Swfi_swf_route_src = Ent_ftr_set.src_code; %end

	End-if.

%^ CR3958 - if CUST routine implemented, overwrites Mapsh_rte_codeword

	CALL "CUST_CHNG_SWF_RTG_PARAM"
	    returning Swfi_temp_status.

%^ end CR3958



	CALL "SWF_ROUTING_MATCH" USING
	     BY REFERENCE Idbank of Swfi_union_key_ws
	     BY REFERENCE Idloc of Swfi_union_key_ws
	     BY REFERENCE Idcust of Swfi_union_key_ws
	     BY REFERENCE Swfshl2_msg_type of Swfs_hdr_line2 
	     BY REFERENCE Swfi_temp_bic
	     BY REFERENCE Swfshl1_out_adr of Swfshl1_address of Swfs_hdr_line1
	     BY REFERENCE Swfi_fake_bic_length
	     BY REFERENCE Swfshl1_out_branch of Swfshl1_address
							       of Swfs_hdr_line1
	     BY REFERENCE Swfi_msg_currency
	     BY REFERENCE Swfshl1_out_tid of Swfshl1_address of Swfs_hdr_line1
       	     BY REFERENCE Swfi_swf_route_src
	     BY REFERENCE Mapsh_current_bnk_key
	     BY REFERENCE Mapsh_rte_codeword
	     BY REFERENCE Mapsh_swfrout_mode
	     BY REFERENCE Mapsh_swfrout_command
	     BY REFERENCE Swfi_queue_spec
	     BY REFERENCE Swfi_queue_spec_length
	     BY REFERENCE Mapsh_swfrout_idtype
	     BY REFERENCE Mapsh_swfrout_id
	     BY REFERENCE Mapsh_swfrout_id_length
	     BY REFERENCE Mapsh_return_valve
	     BY REFERENCE Swfi_table_error
	     BY REFERENCE Swfi_table_error_length
	   Returning Swfi_temp_status.


*
* If either the swf routing table not found OR no matching entry trap else will route to nowhere
*

       If Mapsh_swfrout_mode = spaces then
	    Call "NEX_CREATE_AND_BROADCAST_MSG" Using 
		by content	Z"MAPPER$_NO_TABLE"
		by value	-1
		%ace_msg_arg_list(Mapsh_program_name);
	    %Exit Program
	End-if.

	Set Failure_is in Swfi_routing_found to TRUE
	%Beg First: Mr_rout_cond_seq; %End
	Perform until (seq_end_is in Mr_rout_cond_seq_cursor) OR
		      (Success_is in Swfi_routing_found)

	   Evaluate TRUE

	      When Rcs_category of Rcs_route of Mr_rout_cond_seq(1:5) = "AUTH"
	         Set Success_is in Swfi_routing_found to TRUE

	      When Rcs_category of Rcs_route of Mr_rout_cond_seq(1:6) = "POSDUP"
	         Set Success_is in Swfi_routing_found to TRUE

	   End-evaluate
	   %Beg Next: Mr_rout_cond_seq; %End
	End-perform


	If Success_is in Swfi_routing_found then

	    %Beg Swfi_Compose ^OUT(Swfi_prule_param_name), "MTS$ORIGINAL_32A_DATE", /; %End

	    Perform X800_GET_PRULE_PARAM thru X800_GET_PRULE_PARAM_END

	    If Success_is in Swfi_prule_status and
	       Swfi_prule_value_length > ZERO then
		Set Calculated_is in Change_state of Swfi_32a_date to TRUE
		Set None in Adjuster of Swfi_32a_date to TRUE
		Set None in Special  of Swfi_32a_date to TRUE
		%Beg
		Swfi_Parse ^IN(Swfi_prule_value) Swfi_32a_date.Date_time;
		Ent_credit_set.Cdt_value_date = Swfi_32A_date;
		%End
	    End-if


	   If (Mapsh_swfrout_mode = "RPR") then
              %Beg Ent_msg_union.msgtype ftr_msg; %End
	   Else
	      %BEG
	      Ent_ftr_set.typ.tran_type = "ADM";
	      Ent_msg_union.msgtype admin;
	      %End
	   End-if
	   Go to B200_PROCESS_MSG_CLEANUP
	End-if.

%^
%^ Automatically map the non_return_valve_flag from the routing table if there is one.
%^

	If (Success_is in Swfi_temp_status)
		If Mapsh_return_valve = SPACES
			Move Zero		      to Mapsh_return_valve_length
		 Else
			Move %SIZ(Mapsh_return_valve) to Mapsh_return_valve_length
			If Non_ret_valve_flg of Flgs3 of Ent_ftr_set not = Mapsh_return_valve
				%Beg
				Ent_ftr_set.Flgs3.Non_ret_valve_flg = Mapsh_return_valve;
		   		Swfi_Compose ^OUT(Swfi_hist_memo),
						"Non-Return valve has been set by SWFIN.", /;
			        %End
	    		        PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
			End-if
		End-if
	End-if.

*
* If we found a FX codeword, we need to check if message is a payment.
* If it is to be processed as a payment, update ftr fields with FX info
* and route via FX otherwise ignore FX codeword processing if ADM.
*
       If MapProp_Fx_found = "Y" then
	  If (Mapsh_swfrout_mode = "RPR")
	     %Beg
	     Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/FX/", Mapsh_full_parse_flag, /;
	     ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "CUSTOM",
		       	        	   	     .Rcs_Command  	= "FX"),
					  .Rcs_Routing_Str   		= "",
					  .Rcs_Rtg_Memo1	   	= "",
					  .Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo);

	     %End

	     %Beg Swfi_Compose ^Out(Swfi_hist_memo) "FX codeword detected",/;%End
	     PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END



	     If Success_is in Mapprop_fx_status
	        %Beg
	        Ent_ftr_Set (
	   	      .currency_code = Mapprop_fx_currency,
	   	      .amount	     = Mapprop_fx_amount,
	   	      .exch_rate     = Mapprop_fx_exch_rt,
	   	      .trader_ctrl   = Mapprop_fx_trader_id);
	        Ent_ftr_set.Flgs2.exch_rate_flg = Mapprop_Fx_exch_rt_flg;
		Amt_index(INSERT);
		Ent_ftr_set( ETRAP, .Amt_ndx_join Alloc_JOIN:
			Amt_index(
				.Amount = Ent_ftr_set.Amount,
				.Currency_code = Ent_ftr_set.Currency_code,
				.Value_date = Ent_ftr_set.typ.value_date,
				.Txt = Ent_ftr_set.Trn_ref,
				.Systime NOW ));
		%END
	     Else
		%Beg
	          Ent_ftr_Set (
	   	      .currency_code = "",
	   	      .amount	     = <0>);
		%End
	     End-if
	   End-if
	End-if.

%^ If we are an admin with mapping errors reset the full parse flag back to "Y"

	If (Mapsh_swfrout_mode NOT = "RPR") then
	   If Mapsh_full_parse_flag not = "O" then
	      Move "Y" to Mapsh_full_parse_flag
	   End-if
        End-if.


%^ Parse the raw ascii queue name into record form
	%Beg  Mapsh_swfrout_queue = NULL;  %End
	If (Swfi_queue_spec_length NOT = 0 )
	   AND (Swfi_queue_spec NOT = SPACES)
	THEN
	    %Beg
	    Swfi_misc_parse ^IN(Swfi_queue_spec)
		Mapsh_swfrout_queue.Idbank, "/",
		Mapsh_swfrout_queue.Idloc,  "/",
		Mapsh_swfrout_queue.Idcust, "/",
		Mapsh_swfrout_queue.Idprod, "/",
		Mapsh_swfrout_queue.Idname, / ;
	    %End
	END-IF.
*
* If there is a routing override, apply it now.
*
	IF Mapsh_Route_ovr_str NOT = SPACES THEN
	   %BEG
	   Ent_ftr_set.typ.tran_type = "ADM";
	   Ent_msg_union.msgtype admin;
	   %END
	   Move Mapsh_route_ovr_str(4:3) to Swfi_temp_command
	   %Beg
	   Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/",Swfi_temp_command, "/", Mapsh_full_parse_flag, /;
	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "LINK",
		       	        	   	   .Rcs_Command  	= Swfi_temp_command),
					.Rcs_Routing_Str   		= "",
					.Rcs_Rtg_Memo1	   		= "",
					.Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);
	   %End
	END-IF.



*
* If payment to be processed as non-payment, override payment flag here
*
		

	If (Mapsh_swfrout_mode = "RPR") then
	   Move 1 to Mapsh_Payment
	   If not trade in msgtype of Ent_msg_union then
              %Beg Ent_msg_union.msgtype ftr_msg; %End
	   End-if
	Else
	   %BEG Ent_ftr_set.typ.tran_type = "ADM"; %END
	   Move 0 to Mapsh_Payment

	   If Mapsh_swfrout_mode = "MRS" then
	      %Beg
	      Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRS/MAP/",Mapsh_swfrout_command,"/", Mapsh_full_parse_flag, /;
	      ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "SWFRTE/S",
		       	        	   	      .Rcs_Command  	= Mapsh_swfrout_command),
					   .Rcs_Routing_Str   		= "",
					   .Rcs_Rtg_Memo1	   	= "",
					   .Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo);
	      %End
	   Else
	      If Mapsh_swfrout_mode = "MRH" then
	         %Beg
	         Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/",Mapsh_swfrout_command, "/", Mapsh_full_parse_flag, /;
	         ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "SWFRTE/H",
		       	        	   	         .Rcs_Command  	= Mapsh_swfrout_command),
					      .Rcs_Routing_Str   	= "",
					      .Rcs_Rtg_Memo1	   	= "",
					      .Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo);
	         %End
	      Else

	   	 If (Mapsh_swfrout_queue NOT = SPACES) OR
	      	    (Mapsh_swfrout_command NOT = SPACES ) THEN
	            %Beg
	            ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "SWFRTE/Q",
		       	        	   	            .Rcs_Command  	= ""),
						 .Rcs_addl_route (.Rcs_type	= "ENQ",
						 		  .Rcs_queue (.Idbank =  Mapsh_swfrout_queue.Idbank,
									      .Idloc  =  Mapsh_swfrout_queue.Idloc,
									      .Idcust =  Mapsh_swfrout_queue.Idcust,
									      .Idprod =  Mapsh_swfrout_queue.Idprod,
									      .Idname =  Mapsh_swfrout_queue.Idname)),
					         .Rcs_Routing_Str   		= "",
					         .Rcs_Rtg_Memo1	   		= "",
					         .Rcs_Rtg_Memo2	   		= "");
	            %End


                 Else
	            If Mapsh_swfrout_id NOT = SPACES then
	               %Beg
	    		Swfi_Compose ^OUT(Swfi_hist_Memo) "Routed to address '",
		   		Mapsh_Swfrout_Idtype, "/", Mapsh_Swfrout_Id, "'.", /;

	               ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "SWFRTE/I",
		       	        	   	               .Rcs_Command  		= ""),
						    .Rcs_addl_route(.Rcs_idtype		= Mapsh_swfrout_idtype,
								    .Rcs_id		= Mapsh_swfrout_id),
					            .Rcs_Routing_Str   			= "",
					            .Rcs_Rtg_Memo1	   		= "",
					            .Rcs_Rtg_Memo2	   		= "",
						    .Rcs_info_hist_memo			= Swfi_hist_memo);
	   	       %End
		    End-if
		 End-if
              End-if
 	   End-if
	End-if 

*********************************************************************************************************

* Perform the full set of Autotrieve/HOST_GET, PD and Lookups
* Loop if autotrieve or PD indicate that they changed a party requiring re-lookup
*
* the following boolean will be set to fail if any
* hostget call fails and Swf_auttrv_auto_ws = Y
*
*	Set Success_is in Swfi_hostget_call to True.  %^moved to start of each new message

	Initialize Swfi_hg_loop_count.
	Move 2 to Swfi_loop_once_more

	PERFORM D100_HOSTGET_PD_LOOKUPS THRU D100_HOSTGET_PD_LOOKUPS_END
		WITH TEST AFTER UNTIL
				(Failure_is in Swfi_all_lookup_status AND
			         Swfi_loop_once_more = 0) OR
				(Swfi_Dbt_party_changed = SPACES AND 
				 Swfi_Cdt_party_changed = SPACES AND
				 Failure_is in Swfi_PD_party_changed).


        IF Mapsh_Dbt_full_parse = 0 OR
	   Mapsh_dbt2_full_parse = 0 OR
           Mapsh_Cdt_full_parse = 0 THEN
%^ Something probably needs repair.
              Move "N" to Mapsh_Full_parse_flag
        End-if


	%^ If in Base-Line Currency and Msg Amount is not in Foreign Currency
	%^ then both accounts must be in base currency, else it goes to repair
	%^ ... so ... no longer need to trick FTRSCR_EDITS to calculate the
	%^ foreign amount instead of the base amount
	%^ If lookup failed, but adv type was filled, and there is NO FED type
	%^ set up for bank, then blank it out and send to repair


	If (Mapsh_Payment = 1) and
	   (Incoming_msgtype of Ent_ftr_set NOT = "201" and "203" and "204") AND
	   (NOT(Incoming_msgtype of Ent_ftr_set = "101" or "102") AND
	       (Success_is in Mapsh_global_debit)) then
	   Move 0 to Swfi_err_memo_length
           IF (Cdt_adv_typ of Ent_Credit_Set = "FED") AND 
	      (Failure_Is in Mapsh_allow_Fed_Advice) AND
	      (Cdt_Ovr of Cdt_Typ of Ent_Credit_Set = "*") THEN
	      %Beg
	         Ent_credit_set.cdt_adv_typ = "   " ;
	         Ent_ftr_set.flgs.cdt_adv_flg = "" ;
		 Swfi_err_memo =
			    "Invalid BLANK Cdt Advice Type ... Cannot use FED.";
	      %End
	   Else
	      IF Cdt_adv_typ of Ent_Credit_Set = SPACES THEN
	         %Beg Swfi_err_memo = "Invalid BLANK Cdt Advice Type."; %End
	      END-IF
	   End-if
	   If Swfi_err_memo_length not = 0 then
	      %Beg
	      ALLOC_END: Ent_msg_history(.Qname(.Idbank = Mapsh_Current_bnk_key,
						.IdLoc = NULL,
						.Idname = "*SYS_MEMO"),
					 .Qtype = "OBJTYP$_NULL",
					 .Memo   = Swfi_err_memo);
	      Swfi_err_memo = NULL;
	      %End
	      MOVE "N" TO Mapsh_full_parse_flag
	      ADD 1 TO Mapsh_Memo_count
           End-if
	End-if.



	IF Mapsh_Msg_Bank_Changed1 NOT = 0 
	OR Mapsh_Msg_Bank_Changed2 NOT = 0 
	THEN
	   IF Mapsh_Msg_Bank_Changed2 NOT = 0
	   THEN
              %Beg Mapsh_Current_bnk_key = Ent_ftr_set.loc_info.bank; %End
	      CALL "SET_BANK_CONTEXT" 
	   END-IF

	   %BEG Ent_ftr_set (NOTRAP, .amt_ndx_join CONN: Swfi_amount_ndx); %END
	   IF Success_Is in Swfi_amount_ndx_status THEN
	      %BEG
	      BREAK: Swfi_amount_ndx;
	      Ent_ftr_set ETRAP;
	      %END
	   ELSE
	      %BEG
		  Amt_index(INSERT);
	          Ent_Ftr_Set(ETRAP, .Amt_Ndx_Join ALLOC_JOIN:
	            Amt_Index(
                        .Amount = Ent_Ftr_Set.Amount,
			.Currency_Code = Ent_Ftr_Set.Currency_Code,
			.Value_Date = Ent_Debit_Set.Dbt_Value_Date.Date_Time,
			.Txt = Ent_Ftr_Set.Trn_Ref,
			.Systime now ));
	      %END
           END-IF
	END-IF.

*
* If a name was specified, straight through is allowed in only
* the case of a two party credit to a branch of the bank.
*

	IF (Mapsh_Cdt_swf_name1_length > ZERO ) AND
	   (Mapsh_Payment = 1) AND
	   (Success_is in Swfi_prelookup_by_name) AND
	   (Cdt_adv_typ of Ent_credit_set NOT = "CHK" OR "CHQ") AND
	   (Swf_name_edt of Menu_cfg is not = "T") THEN 
	   IF (Mapsh_Orig_cdt_depth = 0 ) AND
	      (Cdt_rel_id of Ent_credit_set NOT = 0 ) AND
	      (Type_code of Adr_type of Ent_c_adr_set = "I" ) AND
	      (Swift_id of Ent_d_adr_set(1:4) =
				      Cdt_id of Cdt_typ of Ent_credit_set(1:4) )
	    THEN
                CONTINUE
	    ELSE
	        %Beg
	        END: Ent_msg_history;
	        ALLOC_ELEM: Ent_msg_history ( (
			.Qname (.idBank = Mapsh_Current_bnk_key,
				.idLoc = NULL,
				.idName= "*SYS_MEMO"),
			.Qtype	= "OBJTYP$_NULL",
			.Memo   = "Cdt party identified by name, not a branch of the bank."));
	        %END
	        MOVE "N" TO Mapsh_full_parse_flag
	        ADD 1 TO Mapsh_Memo_count
	        MOVE "F" TO Mapsh_Charge_state

	    END-IF
	END-IF.



* 104402 Add call to HGET_WRITE_MEMOS to flush memo_seq to ent_msg_history.
	Call "HGET_WRITE_MEMOS".

	Call "CUST_MAP_101_FLDS" returning Swfi_return_status.

	%Beg
	FIRST: Mapsh_Msg_cnf_seq;
	%End.

	Perform until seq_end_is in Mapsh_msg_cnf_seq_cursor
	
	   Call "WRITE_CNF_TO_MSG" Using
		 by reference Msg_cnf_rec of Mapsh_Msg_cnf_seq
		 by reference Msg_cnf_rec_lengths of Mapsh_Msg_cnf_seq_lengths
		   Returning Swfi_cnf_Return_status
	   %Beg Next: Mapsh_msg_cnf_seq; %End

	End-perform.



* Update Admin Log if successful lookup for non-payments
*
	IF  (Mapsh_Payment = 0 )
	AND (Sbk_rel_id of Ent_debit_set NOT = 0 )
	THEN
	   %ace_conn_root_q Rel_index ;
           %Beg
	      BREAK: Relget_adr_set ;
	      Rel_index ^SEARCH (Key = Ent_debit_set.sbk_rel_id);
	   %End

	   IF  (Success_Is in Rel_index_status )
	   AND (OBJECT_IS in Rel_index_cursor )
	   AND (ADDRESS_IS in Rel_type of Rel_index )
	   THEN
	      %Beg  
	   	 Rel_index CONN: Relget_adr_set(NOMOD) ;  
	         Relget_adr_set.Msg_que CONN: Swfi_gen_work_que(INSERT);
		 END: Swfi_gen_work_que ;

	         ALLOC_END: Ent_msg_history(
		  .Qname(
		   .Idbank = Menu_bnk_union.Bnk_Id,
		   .IdLoc  = NULL,
		   .Idname = "*ADR_MSG_QUE"),
		  .Qtype = "QTYP$_GEN_WORK_QUE",
		  .Memo = NULL,
		  ALLOC_JOIN: Swfi_gen_work_que(
		   .Txt = Ent_ftr_set.Trn_ref,
		   .Memo = "DBT"));

	         BREAK: Swfi_gen_work_que;
	      %End
	   END-IF	
	END-IF.

* If after lookups still no Credit ID the issue error.

	IF  (Cdt_id OF Ent_credit_set = SPACES ) AND
	    (Cdt_name1 of Ent_credit_set not = spaces) AND
	    (Cdt_adv_typ of Ent_credit_set NOT = "CHK" AND "CHQ") AND
	    (Success_is in Swfi_prelookup_by_name) then
	      MOVE "N" TO Mapsh_full_Parse_Flag
	      ADD 1 TO Mapsh_Memo_count
	      %Beg
	      END: Ent_msg_history;
	      ALLOC_ELEM: Ent_msg_history ( (
			.Qname (.idBank = Mapsh_Current_bnk_key,
				.idLoc = NULL,
				.idName= "*SYS_MEMO"),
			.Qtype	= "OBJTYP$_NULL",
			.Memo   = "Credit Party id was not identified"));
	      %END
	End-if

*
********************************************************************************
*
* DEBIT AUTHORITY CHECK:
*

	IF ((Mapsh_Lookup_Payment = 1) and (Incoming_msgtype of Ent_ftr_set not = "210"))  and
	   ((Dbt_rel_id of Ent_debit_set not = Sbk_rel_id of Ent_debit_set) or
 	    (Dbt_rel_id of Ent_debit_set = 0 and Sbk_rel_id of Ent_debit_set = 0 and Mapsh_full_parse_flag = "Y")) and
	   ((Dbt_idtype of Dbt_typ of ent_debit_set not = space) AND
	    (Dbt_id of Dbt_typ of ent_debit_set not = spaces)) then

* cr8067 don't check debit authority on non-global debit mt101's - parent will die anyway, debit auth checks are done on kids

	   If incoming_msgtype of Ent_ftr_set  = "101" and Failure_is in Mapsh_Global_Debit then 

		CONTINUE

	   Else	

		Initialize Swfi_dbt_auth_memo
	   	%Beg Swfi_dbt_auth_memo = NULL; %end
           	CALL "DBT_AUTH_CHECK" using
			by reference Swfi_dbt_auth_memo
			returning  Mapsh_Dbt_auth_status

	   	IF Failure_Is in Mapsh_Dbt_auth_status

	   	   MOVE "N" TO Mapsh_full_parse_flag

	   	   %Beg
	   	   Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/NDA/", Mapsh_full_parse_flag, /;
	   	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	      	.Rcs_Command  		= "NDA"),
							.Rcs_Routing_Str   	= "",
					   		.Rcs_Rtg_Memo1	   	= "",
					   		.Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo);
	   	   %End

	   	   %Beg Swfi_Compose ^Out(Swfi_hist_memo) "DBT party not sender or exceeded DA limit",/;%End
	   	   PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
	   	END-IF
	    End-if
	END-IF.

*
* Check if processing MT102 as a payment that we have authority
*

	If (Incoming_msgtype of Ent_ftr_set = "102") and
	   (Mapsh_Payment = 1) then
	   PERFORM B500_CHECK_102_AUTHORITY THRU B500_CHECK_102_AUTHORITY_END
	End-if.




*
*****************************************************************************
*
* RTE/COR CHECK
*
*

       If (Mapsh_Payment = 1) and (Mapsh_Full_parse_flag = "Y") then

          Call "SI_FINAL_PARTY" USING
                By reference Src_code of Ent_ftr_set
                By reference Cdt_adv_typ of Ent_credit_set
                By reference Amount of Ent_ftr_set 
                By reference Swfi_rte_party
                By reference Mapsh_Rte_or_Cor
                By reference Mapsh_Rte_command
                By reference Mapsh_Rte_printrec1
                By reference Mapsh_Rte_printrec2
                By reference Mapsh_Rte_found
              RETURNING Swfi_rte_cor_status
 

	If Success_Is in Swfi_rte_cor_status then
	   If Mapsh_Rte_or_Cor = "C" then
	      %Beg
	      Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/COR/", Mapsh_full_parse_flag, /; 
	      ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "PRM",
		       	        	   	      .Rcs_Command  	= "COR"),
					   .Rcs_Routing_Str   		= "",
					   .Rcs_Rtg_Memo1	   	= "",
					   .Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo,
				           .Rcs_info_hist_memo		=  "A COR standing instruction has been executed"); 
	   %End

	   Else
	      %Beg

	      Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/", Mapsh_rte_command, "/",
					Mapsh_Rte_printrec1,"/", Mapsh_Rte_printrec2, "/",
					Mapsh_Rte_found, "/", Mapsh_full_parse_flag, /; 
	      ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "PRM/RTE",
		       	        	   	      .Rcs_Command  		= Mapsh_rte_command),
					   .Rcs_addl_route(.Rcs_type		= "RPR",
							   .Rcs_printrec1 	= Mapsh_Rte_printrec1,
							   .Rcs_printrec2 	= Mapsh_Rte_printrec2),
					   .Rcs_Routing_Str   			= "",
					   .Rcs_Rtg_Memo1	   		= "",
					   .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo,
				           .Rcs_info_hist_memo			= "" );
	      %End
	   End-if


	End-if
     End-if.
*
*
***********************************************************
*
* IRT STANDING INSTRUCTIONS:
*
* Check whether there are any IRT standing instructions 
* to process first.
	If (Mapsh_Payment = 0)
	   and (Sbk_rel_id OF Ent_debit_set Not = zero)
	then
* Initialize prule IRT type and ordinal.
	    %beg
	    Swfi_prule_type_ws = "IRT";
	    Swfi_prule_ordinal_ws = <0>;
	    %end

	    Set Failure_is in  Swfi_irt_status to TRUE

* Loop to find a debit party IRT processing rule.
	    Perform with test after until(
	     success_is in Swfi_irt_status
	     or failure_is in Swfi_prule_status )

		Call "PRULE_MSG_RULE_MATCH" using
		 by reference Swfi_prule_type_ws
		 by reference Swfi_prule_type_ws_length
		 by reference Swfi_prule_ordinal_ws
		 by reference Swfi_prule_msglevel_ws
		 by reference Swfi_prule_source_ws
		 by reference Swfi_prule_subtype_ws
		 by reference Swfi_prule_subtype_ws_length
		 by reference Swfi_prule_memo_ws
		 by reference Swfi_prule_memo_ws_length
		 returning Swfi_prule_status

* When no match found exit.
		If(
		 success_is in Swfi_prule_status
		 and(
		  Dbt_msg_ml in Swfi_prule_msglevel_ws
		  or Dbt_db_ml in Swfi_prule_msglevel_ws
		  or Dbt_prof_ml in Swfi_prule_msglevel_ws
		  or Dbt_bank_ml in Swfi_prule_msglevel_ws 
		  or Sbk_msg_ml in Swfi_prule_msglevel_ws
		  or Sbk_db_ml in Swfi_prule_msglevel_ws
		  or Sbk_prof_ml in Swfi_prule_msglevel_ws
		  or Sbk_bank_ml in Swfi_prule_msglevel_ws ) )
		  then	Set Success_is in Swfi_irt_status to true
		end-if
	    end-perform

	
	    IF (Success_is in Swfi_irt_status) THEN
		Move Swfi_prule_subtype_ws(1:3) to Mapsh_swfrout_type
		Move Swfi_prule_subtype_ws(4:3) to Mapsh_swfrout_carrier
	        Move 3 to Mapsh_swfrout_type_length
	        Move 3 to Mapsh_swfrout_carrier_length


%^ Prule_param_name is input to return the parameter value.

		Set Failure_is in Swfi_prule_status to true
		%Beg Swfi_prule_value = null; %End

		Initialize Swfi_prule_vals_left

		Perform with test after until Failure_is in Swfi_Prule_status
		   Call "PRULE_MSG_READEX_PARM" using
			by reference Swfi_prule_param_name
			by reference Swfi_prule_param_name_length
			by reference Swfi_prule_edit
			by reference Swfi_Prule_vals_left
			by reference Swfi_Prule_value
			by reference Swfi_Prule_value_length
			returning Swfi_Prule_status
		   If (Success_is in Swfi_Prule_status) then
		      Evaluate Swfi_Prule_param_name

			When "MTS$ROUTE_ID" 
		    		%Beg Parse ^in(Swfi_prule_value) Mapsh_swfrout_route_id, /; %End

			When "MTS$FORMAT" 

				%Beg Parse ^in(Swfi_prule_value) Mapsh_swfrout_format, /; %End
			When "MTS$LOCATION" 

				%Beg Parse ^in(Swfi_prule_value) Swfi_loc, /; %End

			When "MTS$QUEUE" 


		    		%Beg
		    		Mapsh_swfrout_queue = NULL;  
		    		Swfi_misc_parse ^IN(Swfi_prule_value)
		     			^OPTION(Mapsh_swfrout_queue.Idbank
			       				(^STRING(<CHAR$M_ALPHA!CHAR$M_NUMBER>))),
		     			"/", ^OPTION(Mapsh_swfrout_queue.Idloc
			       				(^STRING(<CHAR$M_ALPHA!CHAR$M_NUMBER>))), ^SPACE,
		     			"/", ^OPTION(Mapsh_swfrout_queue.Idcust
			       				(^STRING(<CHAR$M_ALPHA!CHAR$M_NUMBER>))), ^SPACE,
		     			"/", ^OPTION(Mapsh_swfrout_queue.Idprod
			       				(^STRING(<CHAR$M_ALPHA!CHAR$M_NUMBER>))), ^SPACE,
		     			"/", Mapsh_swfrout_queue.Idname, ^SPACE, / ;
				%End
			        If Failure_is in Swfi_misc_parse_status then
				   %Beg
			            Mapsh_swfrout_queue(.Idbank =  Mapsh_current_bnk_key,
							 .Idloc  = Swfi_loc,
							 .Idcust = "",
							 .Idprod = "",
							 .Idname = Swfi_prule_value);
				   %End
				End-if



			When OTHER

			   Continue

		   End-evaluate
		
		End-if
	       End-perform


	       If Mapsh_swfrout_queue not = spaces then
	          %Beg
	           Swfi_Compose ^OUT(Swfi_hist_memo),	
	              "IRT processing rule '", Mapsh_swfrout_queue(.idbank,.idloc,.idname), "'", /;
		  %End
		Else
	          %Beg
	          Swfi_Compose ^OUT(Swfi_hist_memo),	
	              "IRT processing rule '", Mapsh_swfrout_type, "/", Mapsh_swfrout_carrier, "/" Mapsh_swfrout_route_id"'", /;
	    	  %End
		End-if


	        %Beg

	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "PRM/IRT",
		       	        	   	        .Rcs_Command  		= ""),
					     .Rcs_addl_route(.Rcs_type		= Mapsh_swfrout_type,
							     .Rcs_queue	 	= Mapsh_swfrout_queue,
							     .Rcs_carrier	= Mapsh_swfrout_carrier,
							     .Rcs_route_id	= Mapsh_swfrout_route_id,
							     .Rcs_format	= Mapsh_swfrout_format),
					     .Rcs_Routing_Str   		= "",
					     .Rcs_Rtg_Memo1	   		= "",
					     .Rcs_Rtg_Memo2	   		= "",
				             .Rcs_info_hist_memo		= Swfi_hist_memo );
	        %End
	   End-if
	End-if.

 

 
***********************************************************************
*
* If a non-funds transfer was not fully parsed or failure in mapping the
* message, cut out now and route for repair.
*

* If MT104 check Agreements.

       If incoming_msgtype of ent_ftr_set = "104" then

	  Move "I" to Swfi_agree_type

	  Call "DETERMINE_AGREEMENT" using
		by value	Swfi_agree_type
		by reference	Swfi_agree_reject
		by reference	Swfi_agree_codeword
		by reference 	Swfi_agree_codetext
		returning Swfi_agreement_status

	  If Success_is in Swfi_agree_reject then
	     %Beg
	     ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	     .Rcs_Command  	= "NUL"),
					  .Rcs_Routing_Str   		= "",
					  .Rcs_Rtg_Memo1	   	= "",
					  .Rcs_Rtg_Memo2	   	= "");
	     %End 
	     Set Failure_is in Swfi_agreement_ok to TRUE
	     Set Failure_is in Swfi_route_msg to TRUE
  	     GO TO B200_PROCESS_MSG_CLEANUP
	  End-if
	End-if.


       If ((Mapsh_Full_parse_flag = "N") and (Mapsh_Payment = 0)) then
	   %Beg
	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	   .Rcs_Command  	= "BST"),
					.Rcs_Routing_Str   		= "",
					.Rcs_Rtg_Memo1	   		= "",
					.Rcs_Rtg_Memo2	   		= "*MRH/MAP/BST/N");
	   %End

	  %Beg Swfi_hist_memo = NULL ; %End
	  Go to B200_PROCESS_MSG_CLEANUP
       End-if. 

*
* If non-payment, establish the routing from the swift routing table if
* it hasn't already been established and cut out here.
*
       IF Mapsh_swfrout_mode NOT = "RPR" THEN
	  GO to B200_PROCESS_MSG_CLEANUP
       END-IF.




*******************************************************************************
*
*
*  ONLY FUNDS TRANSFERS SHOULD BE HERE AT THIS POINT
*
*

       %BEG
       BEG: Ent_text_seq;			%^ Revert to start of text
       %END.				

*
* Special Case Funds Transfers *****************
*
*
*

	PERFORM B300_SPECIAL_FUNDS THRU B300_SPECIAL_FUNDS_END.

B200_PROCESS_MSG_CLEANUP.

	If Global_debit of Flgs4 of Ent_ftr_set = "P"
* Bulk parent, mark child_que element creation as completed .
	    %Beg Ent_ftr_set.Flgs5.Childq_create_flg = "C"; %End
	End_if.

***************************************************************************
* ROUTING ROUTINE.....

*

**************************************************************************
* EMF ROUTINE TO CHANGE TEST REQUIRED STATUS
*
	PERFORM X1000_CHECK_TEST THRU X1000_CHECK_TEST_END.

*****************************************************************

	If Success_is in Swfi_route_msg then

	  IF (Base_amount IN Ent_ftr_set IS ZERO)
             IF (Amount IN Ent_ftr_set IS NOT ZERO ) OR
                (Dbt_amount IN Ent_debit_set IS NOT ZERO) OR
                (Cdt_amount IN Ent_credit_set IS NOT ZERO)
                   %^  Ent_ftr_set.Base_amount must always be set to something
                   CALL "CURRENCY_EDIT"
             END-IF
	   END-IF

	   IF (Child_is in Msgsubtype_oneof of Ent_msg_union) or
	      (Orphan_is in Msgsubtype_oneof of Ent_msg_union) then

	      %Beg
	      BREAK: Swfi_Child_history_seq;
	      BREAK: Swfi_Parent_ftr_set;
 	      BREAK: Swfi_Parent_union;
	      BREAK: Swfi_Parent_child_que;
	      %End	

	      %Beg
	      Ent_msg_history EQUATE: Swfi_Child_history_seq;
	      Swfi_Child_history_seq ^FIRST;
	      SCAN: Swfi_Child_history_seq (forward, Key="CHILDQ");	      
	      %End

	      If Success_is in Swfi_Child_history_seq_status then
		Initialize Swfi_Children_Base_amt
		%Beg
		Swfi_Children_Base_amt = <0>; 
		Swfi_child_history_seq CONN: Swfi_parent_child_que (INSERT_LOCK) ; 
		CHANGE: Swfi_Parent_child_que;
		Swfi_Children_base_amt = Swfi_Parent_child_que SUM; 
		Swfi_parent_child_que.child_value = Ent_ftr_set.Base_amount; 
		UPDATE: Swfi_parent_child_que; 
		%End
		Add Base_amount in Ent_ftr_set to Swfi_Children_base_amt

		%Beg
		Swfi_Parent_child_que TOP: Swfi_Parent_union;
		Swfi_Parent_union.ftr CONN: Swfi_Parent_ftr_set (MOD);

		Swfi_Parent_ftr_set.Base_amount = Swfi_Children_Base_amt; 
		%End


		%^ Check for RECEIVERS_CHARGE in Parent's Related Amount Sequence,
		%^ they need to be added back into the Base Amount (after being converted)
		%^ to Base Currency if needed

		%Beg
		BREAK: Swfi_Parent_Relamt_seq;
		Swfi_Parent_union.related_amount_seq CONN: Swfi_Parent_relamt_seq;
		%End
		Initialize Swfi_Parent_Rcvr_chgs
		%Beg FIRST: Swfi_Parent_Relamt_seq; %End
		Perform until Seq_end_is in Swfi_Parent_Relamt_seq_cursor

		    If Amt_Codeword of Swfi_Parent_Relamt_seq = "RECEIVERS_CHARGE" then

			If Curr of Swfi_Parent_Relamt_seq = Base_Currency_id of Menu_Bnk_Union then
			    Add Amount of Swfi_Parent_Relamt_seq to Swfi_Parent_Rcvr_chgs

			Else
			    Initialize Swfi_Base_rel_amt, Swfi_Base_rel_cur, 
					   Swfi_Rel_amt_amt, Swfi_Rel_amt_cur
			    %Beg
			    Swfi_Rel_amt_amt  = Swfi_Parent_Relamt_seq.Amount;
			    Swfi_Rel_amt_cur  = Swfi_Parent_Relamt_seq.Curr;
			    Swfi_Base_rel_amt = <0>;
			    Swfi_Base_rel_cur = Menu_Bnk_Union.Base_Currency_id;
			    %End
			    Initialize Swfi_zero_rate

			    Call "CONVERT_AMOUNT" using
				   by reference Swfi_Rel_amt_cur
				   by reference Swfi_Rel_amt_amt
				   by reference Base_Currency_Id of Menu_Bnk_Union
				   by reference Swfi_Base_rel_amt
				   by reference Swfi_Base_rel_cur
				   by content "D"
				   by reference OMITTED
				   by reference OMITTED
				   by reference Swfi_zero_rate
				   by reference OMITTED

			    Add Swfi_Base_rel_amt to Swfi_Parent_Rcvr_chgs
			End-if
		    End-if
				
		    %Beg NEXT: Swfi_Parent_Relamt_seq; %End

		End-perform

		Add Swfi_Parent_Rcvr_chgs to Base_amount of Swfi_parent_ftr_set

		%Beg
		Swfi_parent_ftr_set.base_amount CHANGE;
		Swfi_parent_ftr_set(NOMOD);
		%End

	   End-if
	End-if

*
* CHECK_RELEASE_TIME which look for /CLSTIME/ in the BBI, verify that the message is not
* late (if found) and enqueue it on the timed_index monitor.
*

	IF Mapsh_Payment = 1 then


	   Call "CHECK_RELEASE_TIME" USING
		BY REFERENCE Swfi_ftr_mode
		BY REFERENCE Date_Time OF Dbt_Value_Date OF Ent_Debit_Set
	        BY REFERENCE Swfi_rls_rte_command
		BY REFERENCE Swfi_rls_error_msg_length
		BY REFERENCE Swfi_rls_error_msg
		RETURNING Swfi_rls_return_status

	   If Swfi_rls_error_msg_length > 0 then

	      If Swfi_rls_rte_command = "RPR" then
		 Move "N" to Mapsh_full_parse_flag
	      End-if

	      %Beg
	      Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/",Swfi_rls_rte_command "/", Mapsh_full_parse_flag, /;
	      ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "CUTOFF",
		       	        	   	      .Rcs_Command  		= Swfi_rls_rte_command),
					   .Rcs_Routing_Str   			= "",
					   .Rcs_Rtg_Memo1	   		= "",
					   .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);

	      %End

	      %Beg Swfi_hist_memo = Swfi_rls_error_msg; %End
	      PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
	  End-if
	End-if
	End_if.
*
* use new Autotrieve Result to decide what to do next.
* EXC (formerly status B, C, D, M, N, P, X) route to repair
* UNV (formerly status F, L, U, I) route to autotrieve holdq
* SPACES, success or call not configured.
*

	Set Success_is in Swfi_do_map_route to TRUE

	If (Failure_is in Mapsh_warehouse) then


	  Set Failure_is in Swfi_routing_found to TRUE
	  %Beg First: Mr_rout_cond_seq; %End
	  Perform until (seq_end_is in Mr_rout_cond_seq_cursor) OR
			(Success_is in Swfi_routing_found)

	     Evaluate TRUE

	        When Rcs_category of Rcs_route of Mr_rout_cond_seq(1:7) = "NOWHERE"
	           Set Success_is in Swfi_routing_found to TRUE

	        When OTHER
	           Continue

	     End-evaluate
	     %Beg Next: Mr_rout_cond_seq; %End
	  End-perform



	   If Failure_is in Swfi_routing_found then

	       Evaluate Hget_summary_status

	         When	"EXC"
				Move "N" to Mapsh_full_parse_flag
				If Swfi_autrv_exc_routing = "T" or "Y" then
	   			   %Beg
	      			   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "ERROR",
		       	        	   	      			   .Rcs_Command  		= "EXC"),
					   		        .Rcs_Routing_Str   		= "",
					   		        .Rcs_Rtg_Memo1	   		= "",
					   		        .Rcs_Rtg_Memo2	   		= "*MRH/MAP/EXC/N");
	   			   %End 
				Else

	   			   %Beg
	      			   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "STP",
		       	        	   	      			   .Rcs_Command  		= ""),
					   		        .Rcs_Routing_Str   		= "",
					   		        .Rcs_Rtg_Memo1	   		= "",
					   		        .Rcs_Rtg_Memo2	   		= "*MRH/MAP/DBT/N");
	   			   %End 
				End-if

				If Hget_comment_length =  ZERO then
				   %Beg Swfi_hist_memo = "Autotrieve account problem."; %End
				Else
				   %Beg Swfi_hist_memo = Hget_comment; %End
				End-if
	   			PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END


	         When	"UNV"
				If Swfi_autrv_automated = "Y" then
				    Set Failure_is in Swfi_do_map_route to TRUE
				End-if
	         When	SPACES
				Continue
	       End-evaluate
	    

	       If success_is IN Swfi_pd_down_wf Then
		   %beg Swfi_do_map_route failure_is; %end
	       End-if
	   End-if

	End-if
	   

	Call "CUST_SYSMEMO_TO_PRM" USING
	      BY CONTENT "SWF"  
	      BY REFERENCE Swfi_cust_memo
	      BY REFERENCE Swfi_cust_memo_length
	      RETURNING Swfi_return_status 



	If Success_is in Swfi_do_map_route then

	       Call "MAP_ROUTE" USING
	           BY REFERENCE Swfi_Hist_memo_length
	           BY REFERENCE Swfi_hist_memo
	         RETURNING Swfi_routing_status 


	End-if.

* Queue to autotrieve hold here if hostget failed
* Save queue routing info in routing memo


	If Swfi_autrv_automated = "Y" and
	   Failure_is in Swfi_do_map_route and
	   Success_is in Swfi_agreement_ok then

	   %beg Swfi_hold_routing_ws = "AHD"; %end

	   Perform D200_RETRY_Q thru D200_RETRY_Q_END

	End-if.

* Queue to pd hold here if one of the PD (via
* CUST_PARTY_DETERMINATION) calls indicated PD down

	If success_is IN Swfi_pd_down_wf
	 And Success_is in Swfi_agreement_ok then

	   %beg Swfi_hold_routing_ws = "SHD"; %end

	   Perform D200_RETRY_Q thru D200_RETRY_Q_END

	End-if.


	If Straight_thru_flg of Ent_ftr_set = Spaces
		%Beg Ent_ftr_set.Flgs2.Straight_thru_flg = Mapsh_full_parse_flag; %End
	End-if.

*
* FTR      -> Route as payment (repair or otherwise)
* EPR	   -> Route to Exception Print Queue
* MRH      -> Route via routing override
* AUTH	   -> Route to AUTHFAILQ
* COR      -> Route to Core verify
* ENQ      -> Route by enqueuing on queue (MRH, SWF_ROUTE queue, WRP queue)
* ID	   -> Route by SWF_ROUTE idtype/id destination
* IRT      -> Route to IRT standing instruction queue
* BUST     -> Route to EXCEPTION Repair Queues
* NOWHERE  -> Route nowhere - create empty destination (for 201, 203, 204, 210)
*	      [Note: This option was formerly named SPL]
* DBT_AUTH -> Route "NDA" no debit authority
* PDM      -> Route as possible duplicate
* RTE      -> Route by Routing Override SI

*************************************************************************
*
*
* MISCELLANEOUS LOGGING AND CLEAN UP.....
*
* 
* Break connections and commit message
*
* If an additional log is to be made for "RPR" category messages, make it
*
      IF (Mapsh_swfrout_queue NOT = SPACES)
	AND (Mapsh_swfrout_mode = "RPR")
      THEN
	 PERFORM X160_ADDITIONAL_LOG THRU X160_ADDITIONAL_LOG_END
      END-IF.

*-----
* Post the incoming funds for liquidity purposes if applicable.  If LQM_POST
* succeeds, we will call LQM_KICK later on to wake the throttler after
* committing the message.

	Set Failure_is in Swfi_kick_lqm to TRUE.
	Set Failure_is in Swfi_liq_auto_rls_ls to TRUE.

%^ Before calling LQM_POST, determine whether this msg is for a CLEARINGSYSTEM and, if so,
%^ whether it is for a NOSTRO Clearingsystem -OR- NORMAL/REGULAR Clearingsystem
%^ (and put its name in Swfi_centbank).
%^ Note: We must check for a Nostro account FIRST, because it is possible that a NOSTRO msg's
%^	 SRC_CODE alone might lead "GET_PID_ADV_CENTBANK" to think the msg is for a
%^	 "NORMAL" clearingsystem when in fact the msg is for a NOSTRO clearingsystem.


%^ Is this msg intended for a NOSTRO clearingsystem ?

	CALL "IS_THIS_ACCT_A_NOSTRO"  USING
	    By Reference Bank 	       of Loc_info 	      of Ent_ftr_set            %^ IN
	    By Reference Idtype        of Dbt_account 	      of Ent_debit_set          %^ IN   DBT_ACCOUNT account of message
	    By Reference Idkey	       of Dbt_account         of Ent_debit_set          %^ IN   "
	    By Reference Idkey_length  of Dbt_account_lengths of Ent_debit_set_lengths  %^ IN   Length of IDKEY
	    By Reference Dbt_idtype    of Dbt_typ 	      of Ent_debit_set	        %^ IN   DBT_TYP account of message 
	    By Reference Dbt_id        of Dbt_typ	      of Ent_debit_set  	%^ IN     "
	    By Reference Dbt_id_length of Dbt_typ_lengths     of Ent_debit_set_lengths  %^ IN   Length of DBT_ID
	    By Reference Swfi_centbank	       						%^ OUT  Name of Nostro Clearingsystem
	    By Reference Swfi_centbank_length	   					%^ OUT  Name's length (3)
	    Returning    Swfi_pid_status.     						%^ OUT  Success = An input account was
											%^      found as a Nostro in Bank's
											%^	clearingsystem sequence

	If (Success_is in Swfi_pid_status) AND						%^ If was success, then it's a NOSTRO
	   (Swfi_centbank_length NOT = 0 )  THEN
	   %BEG Swfi_kind_of_clrsys_ws = "N"; %END					%^ "N" means NOSTRO

	Else										%^ Else failure. So, see if it's for a
	   Call "GET_PID_ADV_CENTBANK" using						%^ "NORMAL/REGULAR" clearingsystem:
	         by reference Bank of Loc_info of Ent_ftr_set
	   	 by reference Src_code of Ent_ftr_set
	    	 By Reference Swfi_centbank
	   	 By Reference SwfI_centbank_length
	 	 Returning Swfi_pid_status
	   %BEG Swfi_kind_of_clrsys_ws = " "; %END				        %^ " " = NORMAL/REGULAR clearingsystem
	End-if.

%^ Assuming we found SOME clearingsytem (Swfi_centbank) for this msg, then
%^ call LQM_POST to log this msg and possibly post some accouting entries:

	If (Success_is in Swfi_pid_status) AND						%^ If msg is for SOME clearingsystem,
	   (Swfi_centbank_length NOT = 0)  THEN						%^ then:
	    Call "LQM_POST" Using
	        By Reference Bank of Loc_info of Ent_ftr_set
	        By Reference Swfi_centbank
		By Reference Amount of Ent_ftr_set
		By Reference Currency_code of Ent_ftr_set
		By Reference Incoming_msgtype of Ent_ftr_set
		By Reference SubType of Ent_ftr_set
		By Reference Date_Time OF Dbt_Value_date of Ent_Debit_Set
		By Reference Trn_ref of Ent_ftr_set
		By Reference Swfi_kind_of_clrsys_ws		%^ In: Kind of clearingsystem: Blank = Regular, N = Nostro
		By Reference Swfi_liq_auto_rls_ls		%^ Output
	      Returning Swfi_kick_lqm
	END-IF.
*-----

*
* Break connections and commit message
*

	Call "DAT_BREAK_MSG".
	%Beg
        Tran (CHAIN: Mapsh_deq_tran);
	COMMIT: tran; 
	%End.

* Call Auto-Release (ie. Message_Routing with *AR) IF the call to LQM_POST above said so.
* Fields (ar_*) needed by Auto-Release were set by LQM_POST

	If Success_is in Swfi_liq_auto_rls_ls Then
	   Call "MESSAGE_ROUTING" using
	         By Value 2
		 By Content "*AR"
		 Returning Swfi_Temp_status
	End-if.

	Call "LOCK_DEQ" Using
	    By reference omitted
	    By value Swfi_long_zero_wc.	

* FOR VMS, Wake the LIQ throttler if POST_LIQ said so
	If Success_is in Swfi_kick_lqm
	    Call "LQM_KICK" using
	        By Reference Bank of Loc_info of Ent_ftr_set
		By Reference Swfi_centbank
	      Returning Swfi_pid_status
	END-IF.

B200_PROCESS_MSG_END.
	Exit.

B300_SPECIAL_FUNDS.

***** Multiple messages
*
       If incoming_msgtype of ent_ftr_set = "201" or "203" or "204" then
	  %BEG
	  Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/ISO/", Mapsh_full_parse_flag, /; 
	  Mapsh_child_mode = Mapsh_Swf_mode;	  
	  ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	  .Rcs_Command  	= "NUL"),
				       .Rcs_Routing_Str   		= "",
				       .Rcs_Rtg_Memo1	   		= "",
				       .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);
	  %End

	  Set Failure_is in Swfi_routing_found to TRUE
	  %Beg First: Mr_rout_cond_seq; %End
	  Perform until (seq_end_is in Mr_rout_cond_seq_cursor) OR
			(Success_is in Swfi_routing_found)

	     Evaluate TRUE

	        When Rcs_category of Rcs_route of Mr_rout_cond_seq(1:5) = "AUTH"
	           Set Success_is in Swfi_routing_found to TRUE

	        When Rcs_category of Rcs_route of Mr_rout_cond_seq(1:6) = "POSDUP"
	           Set Success_is in Swfi_routing_found to TRUE

	     End-evaluate
	     %Beg Next: Mr_rout_cond_seq; %End
	  End-perform

	  If Success_is in Swfi_routing_found then
	     GO TO B300_SPECIAL_FUNDS_END	    
	  End-if

	  If swf1 in Mapsh_swf_mode 
	     CALL "CREATE_CHILD_MSG" USING 
		  BY REFERENCE Swf1_hdr_line1
		  BY REFERENCE Swf1_hdr_line2
		  BY REFERENCE Swf1_hdr_line3 
		  BY CONTENT "SWF" 
		  BY REFERENCE Swfi_hist_memo 
		  BY REFERENCE incoming_msgtype of ent_ftr_set 
		RETURNING Swfi_child_status
	  Else
	     CALL "CREATE_CHILD_MSG" USING 
		  BY REFERENCE Swfs_hdr_line1
		  BY REFERENCE Swfs_hdr_line2
		  BY REFERENCE Swfs_hdr_line3 
		  BY CONTENT "SWF" 
		  BY REFERENCE Swfi_hist_memo 
		  BY REFERENCE incoming_msgtype of ent_ftr_set 
		RETURNING Swfi_child_status
	  End-if

	  If Failure_Is in Swfi_child_status then
	     Move "N" to Mapsh_full_parse_flag

	     %Beg
	      ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "ERROR",
		       	        	   	      .Rcs_Command  		= "BST"),
					   .Rcs_Routing_Str   			= "",
					   .Rcs_Rtg_Memo1	   		= "",
					   .Rcs_Rtg_Memo2	   		= "*MRH/MAP/BST/N");
	     %End 

          End-if
	  GO TO B300_SPECIAL_FUNDS_END
       End-if.

       If incoming_msgtype of ent_ftr_set = "102" then

	  Move "I" to Swfi_agree_type

	  Call "DETERMINE_AGREEMENT" using
		by value	Swfi_agree_type
		by reference	Swfi_agree_reject
		by reference	Swfi_agree_codeword
		by reference 	Swfi_agree_codetext
		returning Swfi_agreement_status

	  If Success_is in Swfi_agree_reject then
	     %Beg
	      ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "NOWHERE",
		       	        	   	      .Rcs_Command  		= "NUL"),
					   .Rcs_Routing_Str   			= "",
					   .Rcs_Rtg_Memo1	   		= "",
					   .Rcs_Rtg_Memo2	   		= "");
	     %End 
	     Set Failure_is in Swfi_agreement_ok to TRUE
	     Set Failure_is in Swfi_route_msg to TRUE
  	     GO TO B300_SPECIAL_FUNDS_END
	  End-if


       End-if



*
******* Notice to Receive
*
       If incoming_msgtype of ent_ftr_set = "210" then
	  %Beg
	  ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "NOWHERE",
		       	        	   	  .Rcs_Command  		= "NUL"),
				       .Rcs_Routing_Str   			= "",
				       .Rcs_Rtg_Memo1	   			= "",
				       .Rcs_Rtg_Memo2	   			= "");
	  %End 

	  CALL "CREATE_210_ANTICIPATIONS"
	    RETURNING Swfi_notice_status
	  If Failure_Is in Swfi_notice_status then
	     Move "N" to Mapsh_full_parse_flag
	     %Beg
	     ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	     .Rcs_Command  	= "EPR"),
					  .Rcs_Routing_Str   		= "",
					  .Rcs_Rtg_Memo1	   	= "",
					  .Rcs_Rtg_Memo2	   	= "*MRH/MAP/EPR/N");
	     %End 

             %BEG Swfi_hist_memo = "Anticipations not created for invalid notices."; %END
	     PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END


    	  End-if	    
	  GO TO B300_SPECIAL_FUNDS_END
       End-if.

*
******* Confirmation of Credit
*
* =========
* If 910 is flagged as a payment, then force it to RPR by blindly
* setting the full parse flag to NO - there will never be a credit
* party already parsed out; so it really won't ever be fully parsed
* ... but ... the flag sometimes tells us that it is

       If incoming_msgtype of ent_ftr_set = "910" then
	  If Matched_ant_flg of Flgs2 of Ent_ftr_set = space then
	     CALL "ANT_MATCH" USING
		BY CONTENT "SWF"	%^ i STR(3) Caller
		BY CONTENT "C"		%^ i STR(1) Dbt/Cdt/Both
	  End-if
	  %Beg
	  Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/DBT/", Mapsh_full_parse_flag, /;
	  ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "STP",
		       	        	   	  .Rcs_Command  	= ""),
				       .Rcs_Routing_Str   		= "",
				       .Rcs_Rtg_Memo1	   		= "",
				       .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);
	  %End
	  IF Mapsh_Payment = 1
	  THEN
	     MOVE "N" TO Mapsh_Full_Parse_Flag
	  END-IF
	  GO TO B300_SPECIAL_FUNDS_END
       End-if.

* 
* Regular Funds transfers *****************
*
       If Trade in msgtype of Ent_msg_union then
	  PERFORM C750_EDIT_TRADE THRU C750_EDIT_TRADE_END
       Else
          PERFORM C700_EDIT_FTR THRU C700_EDIT_FTR_END
	  If Failure_is in Swfi_agreement_ok and
             Incoming_msgtype of Ent_ftr_set = "102" then
	     GO TO B300_SPECIAL_FUNDS_END
	  End-if
       End-if.

      If (incoming_msgtype of ent_ftr_set = "101")
	THEN
	  If Mapsh_deq_memo_vstr(1:11) NOT = "WAREHOUSING" then

	     CALL "MAP_SWF_101" USING
		   BY CONTENT "C"
	       RETURNING Swfi_child_status

	     If Failure_Is in Swfi_child_status then
		Move "N" to Mapsh_full_parse_flag
	        %Beg
	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	     		.Rcs_Command  	= "BST"),
				       	     .Rcs_Routing_Str   	= "",
				             .Rcs_Rtg_Memo1	   	= "",
				             .Rcs_Rtg_Memo2	   	= "*MRH/MAP/BST/N");

	   	%End 
	     Else
	        If Failure_is in Mapsh_global_debit then
	           %Beg
	           ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	           .Rcs_Command  	= "NUL"),
					        .Rcs_Routing_Str   		= "",
					        .Rcs_Rtg_Memo1	   		= "",
					        .Rcs_Rtg_Memo2	   		= "");
	           %End 
                Else
	           %Beg
	           Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/DBT/", Mapsh_full_parse_flag, /;
	  	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "STP",
		       	        	   	  	   .Rcs_Command  	= ""),
				       		.Rcs_Routing_Str   		= "",
				       		.Rcs_Rtg_Memo1	   		= "",
				       		.Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);
	  	   %End

	        End-if
             End-if
	   Else
	     If Failure_is in Mapsh_global_debit then
	        %Beg
	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	        .Rcs_Command  	= "NUL"),
					     .Rcs_Routing_Str   		= "",
					     .Rcs_Rtg_Memo1	   		= "",
					     .Rcs_Rtg_Memo2	   		= "");
	        %End 
             Else
	        %Beg
	        Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/DBT/", Mapsh_full_parse_flag, /;
	  	ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 		= "STP",
		       	        	   	  	.Rcs_Command  		= ""),
				       	     .Rcs_Routing_Str   		= "",
				       	     .Rcs_Rtg_Memo1	   		= "",
				       	     .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);

	  	%End

	     End-if
	   End-if
       End-if.

       If (incoming_msgtype of ent_ftr_set = "102")
	THEN
	  CALL "MAP_SWF_102" USING
		BY CONTENT "C"
	    RETURNING Swfi_child_status

	  If Failure_Is in Swfi_child_status then
	     Move "N" to Mapsh_full_parse_flag
	     %Beg
	     ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	     	     .Rcs_Command  	= "BST"),
				       	  .Rcs_Routing_Str   		= "",
				          .Rcs_Rtg_Memo1	   	= "",
				          .Rcs_Rtg_Memo2	   	= "*MRH/MAP/BST/N");

	     %End 
	  Else
	     If Failure_is in Mapsh_global_debit then
	        %Beg
	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	        .Rcs_Command  	= "NUL"),
					     .Rcs_Routing_Str   		= "",
					     .Rcs_Rtg_Memo1	   		= "",
					     .Rcs_Rtg_Memo2	   		= "");
	        %End 
             Else		
	        %Beg
	        Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/DBT/", Mapsh_full_parse_flag, /;
	  	ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "STP",
		       	        	   	  	.Rcs_Command  	= ""),
				      	     .Rcs_Routing_Str   	= "",
				       	     .Rcs_Rtg_Memo1	   	= "",
				       	     .Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo);
	  	%End
	     End-if
          End-if
       End-if.



       If PDM_DEBITNDX_CHECK of Menu_cfg = "Y" and Mapsh_Full_parse_flag = "Y"
	%Beg
	Cfg_union_key_ws (.Idname = Source_code_tables_wc,
			  .Idprod = Mts_prod_wc,
			  .Idbank = null,
			  .Idloc = null,
			  .Idcust = null);
	Cfg_item_key_ws = "NO_PDM_CHECK:";
	%End
	Call "CFG_MATCH_ITEM" using
				by reference Idname of Cfg_union_key_ws
				by reference Idprod of Cfg_union_key_ws
				by reference Idbank of Cfg_union_key_ws
				by reference Idloc of Cfg_union_key_ws
				by reference Idcust of Cfg_union_key_ws
				by reference Cfg_item_key_ws
				by reference Src_code of Ent_ftr_set
				by reference Src_code_length of Ent_ftr_set_lengths
				by reference Cfg_seq_ordinal_ws
				by reference Cfg_error_msg_ws
				by reference Cfg_error_msg_ws_length
        	      returning return_status_ws
	       %^
	  if Failure_Is in return_status_ws then
            Move SPACES to Swfi_PDM_match_criteria
            Move "T" to Swfi_Key_search
            Call "CUST_PDM_MATCH" Using
                By Reference Swfi_Key_search          %^ "T" = Key search into PDM_INDEX; "F" = Secondary search
                By Reference Swfi_PDM_match_criteria
                RETURNING Swfi_PDM_match_status

            If Swfi_PDM_match_criteria NOT =  SPACES
		Set FAILURE_IS in Mapsh_found_pdm to TRUE
		Call "PDM_CHECK" Using
                    By Reference Swfi_PDM_match_criteria
                    By Reference Swfi_Ftr_mode
                    RETURNING Swfi_PDM_match_status


%^ SUCCESS if PDM found in PDM_CHECK.COB.
%^ PDM_found_ws (a new flag in MAP_FSECT.DDL) is needed in MAP_ROUTE to:
%^      a. Suppress the "Possible duplicate detected" memo if a PDM was found.
%^          The "PDM_VFYQ Matches: TRN, TRN, ..." memo will be used instead.
%^      b. Move "DDM" to command_str_ws to route TRN to the PDM_VFYQ.

		If Success_is in Swfi_PDM_match_status       %^ Then a duplicate was found.
		    Set Success_is in Mapsh_found_pdm to TRUE
		    %Beg
		    Ent_ftr_set.flgs2(
			.Charge_state_flg = Mapsh_Charge_state,
			.Straight_thru_flg = Mapsh_Full_parse_flag );
		    %End

	     	    %Beg
	            Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/DDM/", Mapsh_full_parse_flag, /;
	  	    ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "POSDUP",
		       	        	   	  	    .Rcs_Command  	= "DDM"),
				      	         .Rcs_Routing_Str   		= "",
				       	         .Rcs_Rtg_Memo1	   		= "",
				       	         .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo,
				         	 .Rcs_info_hist_memo		=  "Possible duplicate detected"); 


	            %End

		End-if
	    End-if
	  End-if
     	End-if.




       Perform C800_EDIT_CUTOFF thru C800_EDIT_CUTOFF_END.
       If Failure_Is in Swfi_cutoff_status
	  Move Cut_time of Swfi_intrtl_cutoff(1:2) to Swfi_Colontime(1:2)
	  Move Cut_time of Swfi_intrtl_cutoff(3:2) to Swfi_Colontime(4:2)
	  Move "N" to Mapsh_full_parse_flag

	  %Beg
	  ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "CUTOFF",
		       	        	   	  .Rcs_Command  	= "EXC"),
				       .Rcs_Routing_Str   		= "",
				       .Rcs_Rtg_Memo1	   		= "",
				       .Rcs_Rtg_Memo2	   		= "*MRH/MAP/EXC/N");
	  %End 

	  %Beg
	  Swfi_Compose ^out(Swfi_hist_memo),
		"Warning: Cut-off time of ", Swfi_Colontime, " exceeded." /;
	  %End
	  PERFORM Z400_WRITE_HIST_MEMO THRU Z400_WRITE_HIST_MEMO_END
	  GO TO B300_SPECIAL_FUNDS_END
        End-if.	

	If Matched_ant_flg of Flgs2 of Ent_ftr_set = space
	  then	Call	"ANT_MATCH"
		using	by content	"SWF"		%^ i STR(3) Caller
			by content	"C"		%^ i STR(1) Dbt/Cdt/Both
	End-if.



	%Beg
        Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/DBT/", Mapsh_full_parse_flag, /;
	ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "STP",
		       	        	   	.Rcs_Command  	= ""),
				     .Rcs_Routing_Str   	= "",
				     .Rcs_Rtg_Memo1	   	= "",
				     .Rcs_Rtg_Memo2	   	= Swfi_2nd_routing_memo);

	%End.


B300_SPECIAL_FUNDS_END.

	Exit.



B500_CHECK_102_AUTHORITY.
*
*
*****************************************************************************
*



	Set Failure_is in Swfi_mt102_authorize to TRUE


	%Beg Swfi_Compose ^OUT(Swfi_prule_param_name), "MTS$AGR_AGREEMENT_ID", /; %End

	Perform X800_GET_PRULE_PARAM thru X800_GET_PRULE_PARAM_END


	If (Success_is in Swfi_prule_status) and
	   (Msg_is       in Swfi_prule_level or
	    Sbk_is       in Swfi_prule_level or
	    Sbk_prof_is  in Swfi_prule_level or
	    Sbk_bank_is  in Swfi_prule_level or
	    System_is    in Swfi_prule_level) then

	    Set Success_is in Swfi_mt102_authorize to TRUE
	Else


	   %Beg Swfi_Compose ^OUT(Swfi_prule_param_name), "MTS$MT102_SUBSCRIBER", /; %End

	    Perform X800_GET_PRULE_PARAM thru X800_GET_PRULE_PARAM_END

	    If (Success_is in Swfi_prule_status) and
	       (Msg_is       in Swfi_prule_level or
	        Sbk_is       in Swfi_prule_level or
	        Sbk_prof_is  in Swfi_prule_level or
	        Sbk_bank_is  in Swfi_prule_level or
	        System_is    in Swfi_prule_level) then

		Set Success_is in Swfi_mt102_authorize to TRUE
	        
	    Else
	        %Beg
	        ALLOC_END: Ent_msg_history(.Qname(.IdBank = Mapsh_Current_bnk_key,
					      .Idloc = NULL,
					      .Idname= "*SYS_MEMO"),
				       .Qtype = "OBJTYP$_NULL",
				       .Memo  =
			 "Sender not authorized for MT102 payment processing");
	        %END
	        MOVE "N" TO Mapsh_full_parse_flag
	        ADD 1 TO Mapsh_Memo_count
	    End-if
	End-if.


* Change MT102 from admin to payment if intrtl flag is set and sender is
* authorized to split MT102s into MT100s.


	If Success_is in Swfi_mt102_authorize then
	   Move 1 to Mapsh_Payment
           %Beg 
	   Ent_ftr_set.typ.tran_type = NULL ;
 	   Ent_msg_union.msgtype ftr_msg;
	   Mapsh_swfrout_mode = "RPR";
	   Mapsh_swfrout_queue = NULL;
	   Mapsh_swfrout_id = "";
	   %End
	Else
	   %BEG
	   Ent_ftr_set.typ.tran_type = "ADM";
	   Ent_msg_union.msgtype admin;
	   Mapsh_swfrout_mode = "RPR";
	   %End
	   Move "N" to Mapsh_full_parse_flag
	   Move 0 to Mapsh_Payment
	   %Beg
	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "ERROR",
		       	        	   	   .Rcs_Command  	= "BST"),
				        .Rcs_Routing_Str   		= "",
				        .Rcs_Rtg_Memo1	   		= "",
				        .Rcs_Rtg_Memo2	   		= "*MRH/MAP/BST/N");
	   %End 
	End-if.


*
B500_CHECK_102_AUTHORITY_END.


	Exit.


C700_EDIT_FTR.
*
* Call FTRSCR_EDITS only if debit and credit lookups succeeded and no
* other problems flagged yet.
*


	CALL "CUST_SET_PRIORITY" USING 
	   BY REFERENCE Swfi_ftr_mode
	RETURNING Swfi_temp_status.


*
* call DETERMINE_AGREEMENT
*

%^
%^ Call determine residency because it might change the BBK_RES_COUNTRY - this is temporary
%^ until the BBK_RES_COUNTRY can be set from the BIC if the BBK is a BIC within Lookups
%^


	Set Failure_is in Swfi_agree_reject to TRUE

	If Swfi_res_ctry_displ = "T" then 

	    Call "CUST_DET_RESIDENCY" using
	            by reference swfi_ftr_mode
		    by reference Swfi_res_mode
	            Returning Swfi_Residency_status
	 End-if
   	
	If (Incoming_msgtype of Ent_ftr_set not = "102") and
	   (Cancelled_flag in Flgs4 of Ent_ftr_set NOT = "P") then

	    Move "I" to Swfi_agree_type

	    Call "DETERMINE_AGREEMENT" using
		by value	Swfi_agree_type
		by reference	Swfi_agree_reject
		by reference	Swfi_agree_codeword
		by reference 	Swfi_agree_codetext
	      returning Swfi_agreement_status

	    If (Success_is in Swfi_agree_reject) then
		
	   	Set Failure_is in Swfi_agreement_ok to TRUE

	        If (Nothing_is in Msgsubtype_oneof of Ent_msg_union) or
		   (Orphan_is  in Msgsubtype_oneof of Ent_msg_union) then 
	           %Beg
	           ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "NOWHERE",
		       	        	   	           .Rcs_Command  	= "NUL"),
					        .Rcs_Routing_Str   		= "",
					        .Rcs_Rtg_Memo1	   		= "",
					        .Rcs_Rtg_Memo2	   		= "");
	           %End 
           	    Set Failure_is in Swfi_route_msg to TRUE
		    GO TO C700_EDIT_FTR_CLEANUP
		End-if
		If Child_is in  Msgsubtype_oneof of Ent_msg_union then
		    Move "Y" to Mapsh_Full_Parse_Flag
		    Perform D100_HOSTGET_PD_LOOKUPS thru D100_HOSTGET_PD_LOOKUPS_end
		End-if
	    End-if

	End-if.

	CALL "FILL_DEFAULT_PASS1".

* Copy parent prules to children after lookups, but before FTRSCR_EDITS
* to gather all prules needed for date row processing.
	IF Child_is in Msgsubtype_oneof of Ent_msg_union
* save off child, connect to parent and copy CNF to ent_tmp set, then
* reconnect child.
* Parent msg must be connected thru Dat_alloc_msg or Dat_conn_msg.
		%Beg
		BREAK: Swfi_child_msg_union;
		Ent_msg_union EQUATE: Swfi_child_msg_union;

	        BREAK: Swfi_Child_history_seq;
	        BREAK: Swfi_Parent_ftr_set;
 	        BREAK: Swfi_Parent_union;
	        BREAK: Swfi_Parent_child_que;

	        Ent_msg_history EQUATE: Swfi_Child_history_seq;
	        Swfi_Child_history_seq ^FIRST;
	        SCAN: Swfi_Child_history_seq (forward, Key="CHILDQ");
	        %End

	        If Success_is in Swfi_Child_history_seq_status
		 %Beg
		 Swfi_Child_history_seq CONN: Swfi_Parent_child_que;
	         Swfi_Parent_child_que TOP: Swfi_Parent_union;
		 %End
	        End_if

		Call "DAT_BREAK_MSG"
		%Beg Swfi_parent_union EQUATE: Ent_msg_union; %End
		Call "DAT_CONN_MSG"

		Set Global_debit_is in Swfi_cnf_global_ws to true
		Call "PRULE_MSG_MAKE_TEMPLATE" Using
	    	    BY REFERENCE Swfi_cnf_global_ws 	%^(I) 1=global debit,
						%^    2=global credit
	    	    BY REFERENCE Dbt_rel_id of Ent_debit_set %^(I)parent rel_id
	    	    BY REFERENCE Swfi_cnf_prule_fnd_ws	%^(o)
	    	    BY REFERENCE Swfi_cnf_param_fnd_ws
	    	    BY REFERENCE Swfi_cnf_hist_msg_crtd
	    	    BY REFERENCE Swfi_prule_memo_ws
	    	    BY REFERENCE Swfi_prule_memo_ws_length
	    		Returning Swfi_prule_status

* connect back to child
		Call "DAT_BREAK_MSG"
		%Beg Swfi_child_msg_union EQUATE: Ent_msg_union; %End
		Call "DAT_CONN_MSG"
		%Beg
		Ent_ftr_set(mod);
		Ent_debit_set(MOD);
		Ent_credit_set(MOD) ;
		Ent_trade_detail_set(MOD) ;
		Ent_msg_history(MOD);
		Ent_msg_union(NOTRAP);
		Ent_msg_union.codeword_seq CONN: Ent_codeword_seq(MOD);
		Ent_msg_union(ETRAP);
		LAST: Ent_text_seq(MOD);
		%End

* Write parent CNF from ent_tmp set to global children.  This cannot be done
* before Lookups or they will be lost by call to prule_update_party!
* Child message should be connect thru Dat_alloc_msg or Dat_conn_msg.
	    Call "PRULE_MSG_COPY_FROM_TEMPLATE" Using
	    	BY REFERENCE Swfi_prule_ordinal_ws  %^Number of CNF copied
	    	BY REFERENCE Swfi_prule_memo_ws
	    	BY REFERENCE Swfi_prule_memo_ws_length
	    	 Returning Swfi_prule_status
	End_if.

*
* FTRSCR_EDITS will look edit for good FTR message. CREDIT_LOOKUP already
* scanned the real advice seq (if any), so we just connect a dummy ENT_ADV_SEQ.
* And set CDT_ADV_FLG to keep FTRSCR_EDITS from re-defaulting anything.
*
	move Cdt_adv_flg of Ent_ftr_set to Swfi_cdt_adv_flg.
	move "Y" to Cdt_adv_flg of Ent_ftr_set.

	Move "T" to Edits_passed_flg_ws.
	CALL "FTRSCR_EDITS" USING BY REFERENCE Swfi_ftr_mode.
	%Beg
	Ent_ftr_set.Flgs.Cdt_adv_flg = Swfi_cdt_adv_flg;
	%END
*
* In multi-currency environment, FTRSCR_EDITS (via CURRENCY_EDIT) might
* have determined the Ent_credit_set amount and currency. If so make a second
* amount index join out of the Ent_credit_set amount.
*
	If (fx_ena of Menu_cfg not = low-values) and
	   (cdt_currency of Ent_credit_set not = spaces) and
	   (cdt_amount of Ent_credit_set not = 0)
        then
	    %BEG
	        Amt_index(INSERT);
        	Ent_ftr_set.amt2_ndx_join ALLOC_JOIN:
		    Amt_index(
                        .amount = Ent_credit_set.cdt_amount,
			.currency_code = Ent_credit_set.cdt_currency,
			.value_date = Ent_Debit_set.Dbt_value_date.Date_Time,
			.txt = Ent_ftr_set.Trn_ref,
			.systime now);
	        Amt_index(READ_ONLY);
	    %END
	END-IF.

	If Edits_passed_flg_ws = "T" and
           Swfi_justificat_payment = "T" then

	    Call "CUST_JUST_PAYMENT" using
		    by reference Swfi_ftr_mode
		    by reference Swfi_Just_req
		    by reference Swfi_Just_party_req
		    by reference Swfi_Just_reg_id_req
		    by reference Swfi_Just_error
		    by reference Swfi_Just_error_length
	          returning Swfi_Just_ret_status

	    if Success_is in Swfi_arg_audit_error and 
	       Swfi_Just_error_length not = 0 then
		%Beg Swfi_Compose ^Out(Swfi_hist_memo) Swfi_Just_error,/;%End
		perform Z400_WRITE_HIST_MEMO thru
			Z400_WRITE_HIST_MEMO_END
		%beg swfi_hist_memo = null; %end
	    end_if

	    %^ Something is wrong and justification is required, 
	    %^ so set the edit_passed_flg_ws to Failure

	    If Failure_is in Swfi_Just_ret_status and 
	       Success_is in Swfi_Agreement_ok and
	       Swfi_Just_req = "Y"			
	    
	        Move "F" to Edits_passed_flg_ws

	        %Beg
	        Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/JPR/", Mapsh_full_parse_flag, /;
	        ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "CUSTOM",
		       	        	   	        .Rcs_Command  	= "JPR"),
				        .Rcs_Routing_Str   		= "",
				        .Rcs_Rtg_Memo1	   		= "",
				        .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);

	        %End




	    End-if

	    %^ Justification is required and edits are okay, 
	    %^ so update the BOPR_PTY_SIDE_IND with the party that requires justification

	    If Success_is in Swfi_Just_ret_status and Swfi_Just_req = "Y"
	        %Beg Ent_ftr_set.Flgs4.Bopr_pty_side_ind = Swfi_Just_party_req; %End
	    End-if

	End-if.



	If Edits_Passed_Flg_Ws NOT = "T" then

	    ADD 1 TO Mapsh_Memo_count
	    Move "N" to Mapsh_Full_Parse_Flag
	    MOVE "F" TO Mapsh_Charge_state
	    %Beg
	      ALLOC_END: Ent_Msg_History(
	           .Qname(.Idbank = Ent_ftr_set.Loc_info.bank, 
		          .Idloc = NULL,
		          .Idname= "*SYS_MEMO"),
	           .Qtype = "OBJTYP$_NULL", 
	           .Memo = "Failed a Repair Screen Edit.");
	    %End
	ELSE
	    IF Mapsh_full_parse_flag = "N" THEN
	       GO TO C700_EDIT_FTR_CLEANUP
	    END-IF

***********************************************************************
*
* Message is a valid straight through.
*
* Create a PHN confirmation for PHN advices if not configured for PHN advising.
*
	    IF(
	     phone_advising of Menu_cfg is = "F"
	     AND(
	      (Cdt_adv_typ of Ent_credit_set is = "PHN") OR
	      ( (Cdt_adv_inst1 of Ent_credit_set(1:3) is = "PHN") AND
	        (Cdt_adv_typ of ent_credit_set = "LTR" or "NON" ) ) ) ) THEN
		CALL "CREATE_PHN_CNF" using
		    by reference Swfi_phone		%^ Phone number
		    by content "M"			%^ Mapper Origin
		  returning Swfi_temp_status

		%BEG
		ALLOC_END: Ent_msg_history(
			.Qname(.Idbank = Menu_bnk_union.Bnk_Id,
			       .Idloc = NULL,
			       .Idname= "*SYS_MEMO"),
			.Memo = "Phone advice processed as a PHN confirmation",
			.Qtype	=  "OBJTYP$_NULL");
		%END
		ADD 1 TO Mapsh_Memo_count
	    END-IF
	END-IF.

C700_EDIT_FTR_CLEANUP.
*
* If the BNP party is a NOF Swift address, remove branch code to facilitate
* qualitran lookup
*
	If (Bnp_id of Ent_credit_set(9:3) = "XXX"
	and Bnp_idtype of Ent_Credit_Set = "S"
	and Bnp_name1 of Ent_Credit_Set = spaces ) Then	
	    Move Bnp_id of Ent_credit_set to Swfi_tid_rec
	    %Beg Ent_credit_set.bnp.bnp_id = Swfi_tid_rec.Tid_adr; %End
 	End-if.

C700_EDIT_FTR_END.
	Exit.

C750_EDIT_TRADE.

	Set No_error_is in Swfi_trade_edit_status to TRUE.
	%Beg
	BREAK: Ent_errors_seq;
	ALLOC_TEMP: Ent_errors_seq(MOD) ;
	%End

	Call "TRADE_COMMON_EDITOR" using
		 By Reference Swfi_trade_edit_status.


	If (Error_is in Swfi_trade_edit_status) or
	   (Warning_is in Swfi_trade_edit_status) or
	   (Severe_error_is in Swfi_trade_edit_status) THEN
	    Move "N" to Mapsh_Full_Parse_Flag
	    MOVE "F" TO Mapsh_Charge_state
	End-if.


	If (Not No_error_is in Swfi_trade_edit_status) then
	   %Beg First:Ent_errors_seq; %End

	   Perform until Seq_end_is in Ent_errors_seq_cursor

	      %Beg
	      ALLOC_END: Ent_Msg_History(
	           .Qname(.Idbank = Ent_ftr_set.Loc_info.bank, 
		          .Idloc = NULL,
		          .Idname= "*SYS_MEMO"),
	           .Qtype = "OBJTYP$_NULL", 
	           .Memo = Ent_errors_seq.txt);
	      Next:Ent_errors_seq;
	      %End
	      ADD 1 TO Mapsh_Memo_count
	   End-perform
	End-if.
	      

C750_EDIT_TRADE_END.
	Exit.


C800_EDIT_CUTOFF.
%^ Assume successful return status
        Set Success_Is in Swfi_cutoff_status to TRUE.
	Move SPACES to Swfi_intrtl_cutoff.
%^
%^ If it's an internal book transfer, we don't need to
%^ check cutoff times.	
%^
	If dbt_adr_bnk_id of Ent_debit_set is =
	   cdt_adr_bnk_id of Ent_credit_set
           go to C800_edit_cutoff_end
        End-if.
%^
%^ If transaction is future value dated then we don't
%^ need to check cutoff times.	
%^
        
        %BEG Date_Ws = Ent_Debit_Set.Dbt_Value_Date.Date_Time; %END.
	If (Date_Ws not = zero
	  and (Date_Ws > Mapsh_todate))
        THEN
               go to C800_edit_cutoff_end
        End-if.
%^
%^ Find the intrtl table that contains banks and cutoff
%^ times.
%^
 	    %BEG
	    Swfi_union_key_ws.Idname = "FIELD_EDIT_TABLES";
	    Swfi_item_key = "BANK_CUTOFF_TIMES:";
 	    Swfi_match_key = Ent_ftr_set.Loc_info.Bank;   
	    %END

	    Call "CFG_MATCH_ITEM" USING
	        By Reference Idname of Swfi_union_key_ws
                By Reference Idprod of Swfi_union_key_ws
                By Reference Idbank of Swfi_union_key_ws
                By Reference Idloc  of Swfi_union_key_ws
                By Reference Idcust of swfi_union_key_ws
                By reference Swfi_item_key
   	        By Reference Swfi_match_key
                By Reference Swfi_match_key_length
      	        By Reference Swfi_seq_ordinal_ws
                By Reference Swfi_error_msg_ws
                By Reference Swfi_error_msg_ws_length
              Returning Swfi_temp_status
	    If (Success_Is in Swfi_temp_status)
	        %Beg  Swfi_item_type_ws = "STR(8)";  %End
	        Call "CFG_GET_ITEM" USING
	            BY Reference Idname of Swfi_union_key_ws
	            BY Reference Idprod of Swfi_union_key_ws
	            BY Reference Idbank of Swfi_union_key_ws
	            BY Reference Idloc of Swfi_union_key_ws
	            BY Reference Idcust of Swfi_union_key_ws
	            BY Reference Swfi_item_key
	            By Reference Swfi_seq_ordinal_ws
	            By Reference Swfi_item_type_ws
	            By Reference Swfi_item_data_ws
	            By Reference Swfi_item_data_ws_length
	            By Reference Swfi_error_msg_ws
	            By Reference Swfi_error_msg_ws_length
                  RETURNING Swfi_temp_status
	    If (Success_Is in Swfi_temp_status)
		%Beg
		Swfi_misc_parse ^IN(Swfi_item_data_ws)
			Swfi_intrtl_cutoff.Cut_bnk_id, "/",
		    	Swfi_intrtl_cutoff.Cut_time, / ;
		%End
	  	Move Swfi_misc_parse_status to Swfi_temp_status
	    END-IF
	END-IF.
	If (Failure_Is in Swfi_temp_status )
%^ Couldn't get or parse INTRTL cutoff time record.
	    GO TO C800_EDIT_CUTOFF_END
	END-IF.

	%Beg
%^ Get current time
	Swfi_current_time  now;
%^ Strip out hours
	Swfi_current_hours  = Swfi_current_time.ho;
%^ And minutes
	Swfi_current_minutes = Swfi_current_time.mm ;
	%End
	Move Swfi_current_hours to Swfi_current_nhours.
	Move Cut_time of Swfi_intrtl_cutoff(1:2) to Swfi_cutoff_nhours
	If (Swfi_current_nhours < Swfi_cutoff_nhours )
%^ We're before cutoff.
	    GO TO C800_EDIT_CUTOFF_END
	END-IF.
	If (Swfi_current_nhours = Swfi_cutoff_nhours)
	    Move Swfi_current_minutes to Swfi_current_nminutes
	    Move Cut_time of Swfi_intrtl_cutoff(3:2) to Swfi_cutoff_nminutes
	    If (Swfi_current_nminutes < Swfi_cutoff_nminutes)
%^ We're before cutoff.
	        GO TO C800_EDIT_CUTOFF_END
	    END-IF
	END-IF.
		
%^ Current time exceeds cutoff, return failure status.
	Set Failure_Is in Swfi_cutoff_status to true.

C800_EDIT_CUTOFF_END.
	Exit.

D100_HOSTGET_PD_LOOKUPS.

* Do pre-lookup PD, VLD autotrieve for DBT+CDT, debit and credit lookups,
* ADR autotrieve for DBT+CDT, post-lookup PD call

	SET Success_is in Swfi_all_lookup_status TO TRUE.
	MOVE SPACES TO Swfi_Cdt_party_changed, Swfi_Dbt_party_changed.
	Set Failure_is in Swfi_PD_party_changed to TRUE
	%beg Swfi_pd_down_wf failure_is; %end.

* Autotrieve VLD call for both parties

	If Mapsh_payment = 1 then

	    MOVE "VLD" TO Swfi_Hg_request_type
	    MOVE "DR" TO Swfi_Hg_dbt_cdt
	    PERFORM ZA110_AUTOTRIEVE THRU ZA110_AUTOTRIEVE_END
	    MOVE "CR" TO Swfi_Hg_dbt_cdt
	    PERFORM ZA110_AUTOTRIEVE THRU ZA110_AUTOTRIEVE_END

	End-if.

* Call party determination

	Move "MAP1"  to  Ptydet_func of Ptydet_param_rec.
	PERFORM ZA100_PARTY_DETERMINATION THRU ZA100_PARTY_DETERMINATION_END.

        If Trade in msgtype of Ent_msg_union then
	   PERFORM ZA125_LOOKUP_TRADE THRU ZA125_LOOKUP_TRADE_END
        Else
	   PERFORM ZA120_PERFORM_LOOKUPS THRU ZA120_PERFORM_LOOKUPS_END
	End-if.

* Autotrieve ADR for both parties

	If Mapsh_payment = 1 then

	    MOVE "ADR" TO Swfi_Hg_request_type
	    MOVE "DR" TO Swfi_Hg_dbt_cdt
	    PERFORM ZA110_AUTOTRIEVE THRU ZA110_AUTOTRIEVE_END
	    MOVE Swfi_Party_changed TO Swfi_dbt_party_changed
	    MOVE "CR" TO Swfi_Hg_dbt_cdt
	    PERFORM ZA110_AUTOTRIEVE THRU ZA110_AUTOTRIEVE_END
	    MOVE Swfi_Party_changed TO Swfi_Cdt_party_changed

	End-if.


* Post-lookup PD call


	Move "MAP2"  to  Ptydet_func of Ptydet_param_rec.
        PERFORM ZA100_PARTY_DETERMINATION THRU ZA100_PARTY_DETERMINATION_END.

	If (Ptydet_changed of Ptydet_param_rec not = SPACES) and
	   (Ptydet_changed of Ptydet_param_rec not = "N")  then
	   Set Success_is in Swfi_PD_party_changed to TRUE
	End-if

	Add 1 to Swfi_hg_loop_count
	If Swfi_hg_loop_count > Swfi_hg_loop_limit then
	    Set Failure_is in Swfi_all_lookup_status to TRUE
	    Move zero to Swfi_loop_once_more
	End-if.

* Set Swfi_all_lookup_status to Failure when HOST_GET returns Hget_summary_status "EXC" to 
* prevent looping.

	If (Hget_summary_status = "EXC") and
	   ((Swfi_dbt_party_changed = space) and
	    (Swfi_cdt_party_changed = space)) then
	    Set Failure_is in Swfi_all_lookup_status to TRUE
	    Subtract 1 from Swfi_loop_once_more
	End-if.


D100_HOSTGET_PD_LOOKUPS_END.
	Exit.

D200_RETRY_Q.

	If Swfi_hold_routing_ws = "AHD" Then
	    %Beg
	    Compose ^OUT(Ent_msg_history.Memo),
		"Moved to Autotrieve Hold queue. SWFIN ",^TIME,/;

	    %end
	Else
* SHD
	    %Beg
	    Compose ^OUT(Ent_msg_history.Memo),
		"Moved to PD Hold queue. SWFIN ",^TIME,/;
	    %end
	End-if.
	
	%beg
	ALLOC_END: Ent_msg_history(
		.Qname(
			.Idprod	= "",
			.Idbank	= Mapsh_current_bnk_key,
			.Idloc	= "",
			.Idcust = "",
			.Idname = "*SYS_MEMO"),
		.Qtype		= "OBJTYP$_NULL" );


	Compose ^out(Swfi_tmp_vstr80) "*MRH/MAP/   /", Mapsh_Full_parse_flag ,/;
	%end.

	Call	"MESSAGE_ROUTING"
	using	by value	7		%^ number of parameters here
		by content	"MAP"
		by reference	Swfi_hold_routing_ws
		by content	"TRAP"
		by content	opr_login_id of Menu_opr_union
		by reference	Swfi_tmp_vstr80_length
		by reference    Swfi_tmp_vstr80.


D200_RETRY_Q_END.
	Exit.

D300_PKI_CHECK.

	Set Success_is in Swfi_Pki_sts to True.	
	Set Failure_is in Swfi_need_pki to True.
	Initialize Swfi_vTextBlock.
	Initialize swfi_block_8_prep.
	Initialize swfi_block_8_prep_length.
	Initialize Swfi_vTextBlock_length.
	%Beg
	 BREAK: Swfi_tmp_text_seq;
	 Ent_text_seq equate: Swfi_tmp_text_seq;
	 First: Swfi_tmp_text_seq;		
	%End

	Perform Until (Txt of Swfi_tmp_text_seq(1:3) = "{1:") OR
			(Seq_end_is in Swfi_tmp_text_seq_cursor)
		%beg Next: Swfi_tmp_text_seq; %End			
	End-Perform.
	
%^ Store the BIC in field 1 of the 398 message incase it's not on the
%^ FinCopy config

	If txt of Swfi_tmp_text_seq(1:3) = "{1:"
  		Move Txt of Swfi_tmp_text_seq(7:8) to Swfi_alt_BIC		
	End-if.

	Perform Until (Txt of Swfi_tmp_text_seq(1:5) = ":77E:") OR
			(Seq_end_is in Swfi_tmp_text_seq_cursor)
		%beg Next: Swfi_tmp_text_seq; %End			
	End-Perform.
	
	If txt of Swfi_tmp_text_seq(1:5) = ":77E:"  			
		PERFORM D400_ASSEMBLE_PKI_STRING thru D400_ASSEMBLE_PKI_STRING_EXIT
		If Success_is in Swfi_need_PKI
		   If Swfi_vHashcodeBase64(1:44) = Swfi_block_8_digest
			Continue
		   Else
			Set Failure_is in Swfi_Pki_sts to True
			Set Failure_Is in Swfi_auth_status to True
			Set auth_failed in Mapsh_auth_sts to True
 			%Beg
		   	 Swfi_Compose ^Out(Swfi_hist_memo) "PKI validation Failure", /; 
			%End
		   End-if
		End-if
	End-if.

	%Beg
	 BREAK: Swfi_tmp_text_seq;
	%End.
	
D300_PKI_CHECK_EXIT.
	Exit.

D400_ASSEMBLE_PKI_STRING.

	Perform Until (Txt of Swfi_tmp_text_seq(1:8) = ":103:TPS") OR
			(Seq_end_is in Swfi_tmp_text_seq_cursor)
		%beg Next: Swfi_tmp_text_seq; %End			
	End-Perform.

	If Seq_end_is in Swfi_tmp_text_seq_cursor
		%Beg
	 	 BREAK: Swfi_tmp_text_seq;
		%End
		Go To D400_ASSEMBLE_PKI_STRING_EXIT
	End-if.

	Set Success_is in Swfi_need_pki to True

	%beg First: Swfi_tmp_text_seq; %End

%^ Assemble the DIGEST of the embedded message by concatenating various 
%^ fields within the embedded message into Swfi_vTextBlock.

	%beg Next: Swfi_tmp_text_seq; %End	
	Perform Until (txt of Swfi_tmp_text_seq(1:4) = ":(1:") OR
			(Seq_end_is in Swfi_tmp_text_seq_cursor)
		%beg Next: Swfi_tmp_text_seq; %End			
	End-Perform.	

%^ Receiver BIC

	If txt of Swfi_tmp_text_seq(1:4) = ":(1:"
	        Move txt of Swfi_tmp_text_seq(8:8) to Swfi_pki_receiver_bic
		%Beg
	 	 Swfi_pki_compose ^OUT(Swfi_vTextBlock) Swfi_pki_receiver_bic,/;
		%End		
	End-if.


%^ Sender BIC
	

	%Beg
	 Swfi_pki_compose ^OUT(Swfi_vTextBlock) ,^APPEND, Swfi_alt_BIC,/;
	%End	      
 
	%beg Next: Swfi_tmp_text_seq; %End	

	Perform until (txt of Swfi_tmp_text_seq(1:4) = ":(4:") or (failure_is in Swfi_tmp_text_seq_status)
	  %beg next: Swfi_tmp_text_seq; %end
	end-perform.
	
	If txt of Swfi_tmp_text_seq(1:4) = ":(4:"
	  	perform D600_FULL_COPY thru D600_FULL_COPY_END
	Else
		Go to D400_ASSEMBLE_PKI_STRING_EXIT		
	end-if.

%^	Obtain the Digest 1 value by calling SH256 with the contents of
%^	Swfi_vTextblock
%^	subtract 1 from Swfi_iOutOffset giving Swfi_vTextBlock_length.


	call "NEX_SHA256" using
	  by reference Swfi_4b256HashcodeBin,
	  by reference Swfi_vTextBlock,
	  by value Swfi_vTextBlock_length.

	call "NEX_MIME_ENCODE" using
	  by reference Swfi_vHashcodeBase64_length,
	  by reference Swfi_vHashcodeBase64,
	  by value %siz(Swfi_vHashcodeBase64),
	  by reference Swfi_4b256HashcodeBin,
	  by value Swfi_4b256HashcodeBin_length,
	  by reference Swfi_vstr_ws,
	  by reference Swfi_vstr_ws_length,
	  returning Swfi_iStatus.

%^ Now get the Digest 1 value by reconstituting block 8 to the original xml structure  


	Perform until (txt of Swfi_tmp_text_seq(1:4) = ":(8:") or (failure_is in Swfi_tmp_text_seq_status)
	  %beg next: Swfi_tmp_text_seq; %end
	End-Perform.
		
	If txt of Swfi_tmp_text_seq(1:4) = ":(8:"
		%beg next: Swfi_tmp_text_seq; %end
		Perform until (txt of Swfi_tmp_text_seq(1:4) = "-}") or (failure_is in Swfi_tmp_text_seq_status)
			%Beg
			 Swfi_Block_8_compose ^OUT(Swfi_Block_8_prep), ^APPEND, Swfi_tmp_text_seq.Txt,/;
			 next: Swfi_tmp_text_seq; 
			%end
		End-Perform
	
	End-if.

	Divide Swfi_block_8_prep_length by 4 Giving Swfi_junk Remainder Swfi_padding_needed.
	If  Swfi_padding_needed = 1
		%Beg
		 Swfi_Block_8_compose ^OUT(Swfi_Block_8_prep), ^APPEND, "===",/;
		%End	
	Else
		If  Swfi_padding_needed = 2
			%Beg
			 Swfi_Block_8_compose ^OUT(Swfi_Block_8_prep), ^APPEND, "==",/;
			%End		
		Else
		If Swfi_padding_needed = 3				
			%Beg
		 	 Swfi_Block_8_compose ^OUT(Swfi_Block_8_prep), ^APPEND, "=",/;
			%End		
		End-if
	End-if.

* Convert binary to base64

	call "NEX_MIME_DECODE" using
	  by reference Swfi_Ascii_block_8_length,
	  by reference Swfi_Ascii_block_8,
	  by value %siz(Swfi_Ascii_block_8),
	  by reference Swfi_block_8_prep,
	  by value Swfi_block_8_prep_length,
	  by reference Swfi_vstr_ws,
	  by reference Swfi_vstr_ws_length,
	  returning Swfi_iStatus.	

	%Beg
	 Parse ^IN(Swfi_Ascii_block_8) ^String, "<Sw:DigestRef>1</Sw:DigestRef><Sw:DigestValue>", Swfi_block_8_digest, "</Sw:DigestValue>", ^String,/;
	%End.	  

			
D400_ASSEMBLE_PKI_STRING_EXIT.
	Exit.

D600_FULL_COPY.
* FIN Full Copy message.
* Insert full copy of message text into vTextBlock.
* Input:
*	Swfi_iOutOffset = offset into Swfi_vTextBlock

* Find first text line
	%beg
	next: Swfi_tmp_text_seq;
	%end.
	perform until (failure_is in Swfi_tmp_text_seq_status) or
			(txt of Swfi_tmp_text_seq(1:1) = ":")
	  %beg next: Swfi_tmp_text_seq; %end
	end-perform.

* Insert text lines, preceded by <cr><lf>

	%Beg
	 Swfi_block_4_compose ^OUT(Swfi_vTextBlock), ^APPEND, Swfi_recCRLF,/;
	%End
	perform until (failure_is in Swfi_tmp_text_seq_status) or
			(txt of Swfi_tmp_text_seq(1:4) = ":(5:") 
		%Beg
		 Swfi_block_4_compose ^OUT(Swfi_vTextBlock), ^APPEND, Swfi_tmp_text_seq.Txt, Swfi_recCRLF,/;
		 next: Swfi_tmp_text_seq; 
		%end
	end-perform.

* Add message terminator
	
	%Beg
	 Swfi_block_4_compose ^OUT(Swfi_vTextBlock), ^APPEND, "-",/;
	%End.

D600_FULL_COPY_END.
	Exit.

X160_ADDITIONAL_LOG.
*
* Log a message to an auxilliary log specified in Mapsh_swfrout_queue
* The queue or log is assumed to be a GENWORK queue.
*
	IF Idbank of Mapsh_swfrout_queue = SPACES THEN
	    %Beg  Mapsh_swfrout_queue.Idbank = Menu_bnk_union.bnk_id;  %End
	END-IF.
	%Beg  BREAK: Swfi_gen_work_que;  %End
	%ACE_CONN_Q Mapsh_swfrout_queue TO Swfi_gen_work_que FOR INSERT;
	%BEG
	END: Swfi_gen_work_que ;
	ALLOC_END: Ent_msg_history(.Qname = Mapsh_swfrout_queue,
				   .Qtype = "QTYP$_GEN_WORK_QUE",
				   .Memo = NULL,
			ALLOC_JOIN: Swfi_gen_work_que);
	BREAK: Swfi_gen_work_que;
	%End.

X160_ADDITIONAL_LOG_END.
	Exit.

X470_FIND_ACC_USING_LOC.
*
* The account is ambiguous, but the CLASS_LOC table exists.
* The logic for resolving this is quite convoluted.
* This is because accounts with classes which ARE NOT represented in
* the CLASS_LOC code table must be treated as a match with
* any incoming message which is addressed to a location which is
* also not represented in the CLASS_LOC table. Accounts with classes
* which are represented in the CLASS_LOC table are matched only with
* messages addressed to locations which are also in the table.
*
* First determine the Location (if any) which matches the SWIFT destination at
* which the wire was received. Then translate that to an account class using
* the CLASS_LOC table. Then, depending on whether it is found, either:
*	step through the addresses which match the SWIFT sender identifier, and
*	pick the first one which has the right account class code.
*			OR
*	step through the addresses which match the SWIFT sender identifier, and
*	pick the first one which has a class code which is NOT represented in
*	the CLASS_LOC table.
*
* Input:
*	Swfi_swf_id contains a SWIFT TID (8 or 11 characters)
* Output:
*	If found, Ent_acc_set and Relget_adr_set are left connected,
*	Swfi_swf_id contains
*	ac #  Swfi_acc_by_loc is set to indicate success
*

	IF (Failure_Is in Swfi_class_locs)
	   OR (Failure_Is in Swfi_branch_codes)
	THEN
	    SET Failure_Is in Swfi_acc_by_loc TO TRUE
	    GO TO X470_FIND_ACC_USING_LOC_END
	END-IF.

	Move %SIZ(Swfs_branch_codes_rec) to Swfi_temp_size.
 	%BEG
	Swfi_union_key_ws.Idname =  "SWIFT_TELEX_TABLES";
	Swfi_item_key = "SWF_BRANCH_CODES:";
 	Swfi_misc_compose ^OUT(Swfi_match_key)
			Swfs_hdr_line1.Swfshl1_address.Swfshl1_out_adr,
			Swfs_hdr_line1.Swfshl1_address.Swfshl1_out_branch,
			Menu_bnk_union.Bnk_id, / ;
	Swfi_item_type_ws = "VSTR(42)";
  	Swfi_seq_ordinal_ws = <1>;
	%END
	Set Failure_Is in Swfi_loop_status to TRUE.
	Perform until (Success_Is in Swfi_loop_status)

	    Call "CFG_MATCH_ITEM_CONT" USING
	        By Reference Idname of Swfi_union_key_ws
                By Reference Idprod of Swfi_union_key_ws
                By Reference Idbank of Swfi_union_key_ws
                By Reference Idloc  of Swfi_union_key_ws
                By Reference Idcust of swfi_union_key_ws
                By reference Swfi_item_key
   	        By Reference Swfi_match_key
                By Reference Swfi_match_key_length
      	        By Reference Swfi_seq_ordinal_ws
                By Reference Swfi_error_msg_ws
                By Reference Swfi_error_msg_ws_length
              Returning Swfi_acc_by_loc
	    If (Success_Is in Swfi_acc_by_loc)
	        Call "CFG_GET_ITEM" USING
	            BY Reference Idname of Swfi_union_key_ws
	            BY Reference Idprod of Swfi_union_key_ws
	            BY Reference Idbank of Swfi_union_key_ws
	            BY Reference Idloc of Swfi_union_key_ws
	            BY Reference Idcust of Swfi_union_key_ws
	            BY Reference Swfi_item_key
	            By Reference Swfi_seq_ordinal_ws
	            By Reference Swfi_item_type_ws
	            By Reference Swfi_item_data_ws
	            By Reference Swfi_item_data_ws_length
	            By Reference Swfi_error_msg_ws
	            By Reference Swfi_error_msg_ws_length
                  RETURNING Swfi_acc_by_loc
	        If (Success_Is in Swfi_acc_by_loc)
		    %Beg
		    Swfs_branch_codes_rec = NULL;
		    Swfi_misc_parse ^IN(Swfi_item_data_ws)
		    	    Swfs_branch_codes_rec.Swbc_bic(^STRING<8>),
		    	    Swfs_branch_codes_rec.Swbc_branch(^STRING<3>),
		    	    Swfs_branch_codes_rec.Swbc_Bank_id(^STRING<3>),
		    	    Swfs_branch_codes_rec.Swbc_loc(^STRING<6>),
			    Swfs_branch_codes_rec.Swbc_term(^STRING<1>),
			    Swfs_branch_codes_rec.Swbc_int_send(^STRING<3>),
		 Swfs_branch_codes_rec.Swbc_flags.Swbcr_non_swf_rte(^STRING<1>),
		 Swfs_branch_codes_rec.Swbc_flags.Swbcr_Test_tid(^STRING<1>),
	^OPTION(Swfs_branch_codes_rec.Swbc_flags.Swbcr_spare_flags(^STRING<2>)),
	       ^OPTION(Swfs_branch_codes_rec.Swbc_priority_mask(^STRING<1>),
		    	Swfs_branch_codes_rec.Swbc_dest_adr_mask(^STRING<8>),
		    	Swfs_branch_codes_rec.Swbc_msg_type_mask(^STRING<3>),
		    	Swfs_branch_codes_rec.Swbc_Q_suffix(^STRING<2>)),
			/;
		    %End
		    If (Swbc_loc of Swfs_branch_codes_rec NOT = "******" )
			Set Success_Is in Swfi_loop_status to TRUE
		    ELSE
			ADD 1 to Swfi_seq_ordinal_ws
		    END-IF
		END-IF
	    END-IF
	    If Failure_Is in Swfi_acc_by_loc
%^ No table match
		GO TO X470_FIND_ACC_USING_LOC_END
	    END-IF
	END-PERFORM.

* Now we have the location.
* Do another translation step: determine the matching class code (if any)
*
	Move %SIZ(Swfi_cl_table_entry) to Swfi_temp_size.
	%Beg
	Swfi_union_key_ws.Idname = "FIELD_EDIT_TABLES" ;
	Swfi_seq_ordinal_ws = <1>;
	Swfi_item_key = "CLASS_LOCS:";	
	Swfi_misc_compose ^OUT(Swfi_item_type_ws )
		"STR(", Swfi_temp_size, ")", / ;
	Swfi_cl_table_entry = NULL ;
	%End       
	Set Success_Is in Swfi_loop_status to TRUE
	PERFORM WITH TEST AFTER UNTIL
		(Sclte_Loc OF Swfi_cl_table_entry =
					  Swbc_Loc OF Swfs_branch_codes_rec )
		OR (Failure_Is in Swfi_loop_status )
	    Call "CFG_GET_ITEM" USING
	        BY Reference Idname of Swfi_union_key_ws
	        BY Reference Idprod of Swfi_union_key_ws
	        BY Reference Idbank of Swfi_union_key_ws
	        BY Reference Idloc of Swfi_union_key_ws
	        BY Reference Idcust of Swfi_union_key_ws
	        BY Reference Swfi_item_key
	        By Reference Swfi_seq_ordinal_ws
	        By Reference Swfi_item_type_ws
	        By Reference Swfi_item_data_ws
	        By Reference Swfi_item_data_ws_length
	        By Reference Swfi_error_msg_ws
	        By Reference Swfi_error_msg_ws_length
              RETURNING Swfi_loop_status
	    If (Success_Is in Swfi_loop_status)
		%Beg
		Swfi_misc_parse ^IN(Swfi_item_data_ws)
			Swfi_cl_table_entry.Sclte_acc(^STRING<6>),
			Swfi_cl_table_entry.Sclte_loc(^STRING<6>), / ;
		%End
		Add 1 to Swfi_seq_ordinal_ws
	    END-IF
	END-PERFORM.
*
* Now we have the class code, or there is none.
* Loop to find a DDA account which has a matching class code.
*
	%Beg
	Swift_index ^SEARCH (geq, .Rel_name_key(
	  					.Idbank = Menu_bnk_union.Bnk_Id,
	  					.Idtype = "S",
	  					.Idkey = Swfi_swf_id ) );
	Swift_index(eql);
	%End

	If (Idbank of Rel_name_key of Swift_index NOT = 
						      Bnk_Id of Menu_bnk_union )
	   OR (Idkey of Rel_name_key of Swift_index(1:Swfi_swf_id_length)
				       NOT = Swfi_swf_id(1:Swfi_swf_id_length) )
	THEN
	   SET Failure_Is in Swfi_acc_by_loc to TRUE
	   GO TO X470_FIND_ACC_USING_LOC_END
	END-IF.

	%Beg  BREAK: Relget_adr_set;  %End
*
* For now, check DDA accounts only
*
	%ace_conn_root_q Rel_acc_index ;
	PERFORM WITH TEST AFTER UNTIL Swfi_loop_forever = ZERO
	    %Beg  BREAK: Swfi_acc_set;  %End
	    Move SPACES to Acc_class of Swfi_acc_set
	    Move ZERO to Acc_class_length of Swfi_acc_set_lengths
	    Move SPACES to Acc_id of Swfi_acc_set
	    %Beg
	    Swfi_acc_set.Acc_id = NULL;
	    Swift_index( CONN: Relget_adr_set(NOMOD,
		  .Account_seq CONN: Swfi_acctyp_seq(NOMOD)) );
	    SCAN: Swfi_acctyp_seq (Scan_Key = "D") ;
	    Swfi_temp_status = Swfi_acctyp_seq status;
	    BREAK: Swfi_acctyp_seq;
	    BREAK: Swfi_acc_set ;
	    %End
	    If Success_Is in Swfi_temp_status
		%Beg
	        SEARCH: Rel_acc_index (FORWARD, GEQ,
			.Rel_name_key = Swfi_acctyp_seq.Rel_name_key ) ;
		Swfi_temp_status = Rel_acc_index status ;
                %End
	    END-IF	
	    If (Success_Is in Swfi_temp_status)
	       AND (Idbank of Rel_name_key of Rel_acc_index = 
				    Idbank of Rel_name_key of Swfi_acctyp_seq )
	       AND (Idtype of Rel_name_key of Rel_acc_index = 
				    Idtype of Rel_name_key of Swfi_acctyp_seq )
	       AND (Idacc of Idkey of Rel_name_key of Rel_acc_index =
			    Idacc of Idkey of Rel_name_key of Swfi_acctyp_seq )
	    THEN
	        %Beg
		Rel_acc_index CONN: Swfi_acc_set(NOMOD) ;
		BREAK: Swfi_acc_set ;
		%End
	    END-IF
	    If (Idtype of Acc_id of Swfi_acc_set is = "D" )
		EVALUATE TRUE
		    WHEN Failure_Is in Swfi_loop_status
*
* LOC was not in CLASS_LOC table: if the account class of this account is
* also not in the table, this is a match
*
			%Beg
			Swfi_cl_table_entry = NULL;
			Swfi_match_key = Swfi_acc_set.acc_class;
			%End
			Call "CFG_MATCH_ITEM" USING
			    By Reference Idname of Swfi_union_key_ws
			    By Reference Idprod of Swfi_union_key_ws
			    By Reference Idbank of Swfi_union_key_ws
			    By Reference Idloc  of Swfi_union_key_ws
			    By Reference Idcust of swfi_union_key_ws
			    By reference Swfi_item_key
			    By Reference Swfi_match_key
			    By Reference Swfi_match_key_length
			    By Reference Swfi_seq_ordinal_ws
			    By Reference Swfi_error_msg_ws
			    By Reference Swfi_error_msg_ws_length
			  Returning Swfi_temp_status
	    		If (Success_Is in Swfi_temp_status)
%^ Did not find a location in branch codes table,
%^ so account class must not be in location table either.
			    SET Failure_Is in Swfi_acc_by_loc TO TRUE
			ELSE
			    SET Success_Is in Swfi_acc_by_loc TO TRUE
			END-IF

		    WHEN OTHER
*
* LOC was in the CLASS_LOC table: if the account class of this account
* matches the LOC, this is a match
*
			IF Acc_class of Swfi_acc_set =
						Sclte_acc OF Swfi_cl_table_entry
			   SET Success_Is in Swfi_acc_by_loc TO TRUE
			ELSE
			   SET Failure_Is in Swfi_acc_by_loc TO TRUE
			END-IF
		END-EVALUATE
		IF Success_Is in Swfi_acc_by_loc THEN
		   %Beg
		   Swfi_swf_id = Swfi_acc_set.Acc_id.Idkey;
		   Swfi_swf_idt = Swfi_acc_set.Acc_id.Idtype;
		   %End
		   GO TO X470_FIND_ACC_USING_LOC_END
		END-IF
	    END-IF
*
* Step to the next entry in the SWIFT index. If same sender address, keep
* searching.
*
	    %Beg
	    BREAK: Relget_adr_set;
	    BREAK: Ent_acc_set;
	    NEXT: Swift_index;
	    %End
	    IF (Idbank of Rel_name_key of Swift_index NOT = 
					     	      Bnk_Id of Menu_bnk_union )
	    	OR (Idkey of Rel_name_key of
					Swift_index(1:Swfi_swf_id_length)
 				     NOT = Swfi_swf_id(1:Swfi_swf_id_length) )
	    Then	
		SET Failure_IS in Swfi_acc_by_loc TO TRUE
		GO TO X470_FIND_ACC_USING_LOC_END
	    END-IF

	END-PERFORM.

X470_FIND_ACC_USING_LOC_END.
	Exit.

X600_CDT_MATCH_BY_NAME.
*
* Config control of this feature:
*	SWF_LOOKUP_BY_NAME is a binary flag containing bit values.
*   Lowest bit (1's):	Do ABA lookup match
*     Next bit (2's):	Do search of rel file by short name (3 party
*			payment only).
*     Next bit (4's):   Do search of auxiliary mnemonic name index
*			using the first (name) and the last (city/country) line
*
* Get the config flag. If no options are selected, return failure immediately
*
	MOVE Swf_lookup_by_name OF Menu_cfg TO Mask_low.
	IF Long_mask = ZERO THEN
	   SET Failure_Is in Swfi_matched_by_name TO TRUE
	   GO TO X600_CDT_MATCH_BY_NAME_END
	END-IF.
*
* If ABA match is not indicated, try mnemonic name match
*
*
* If 1's bit is set, first search the credit name and address for a possible
* FED ABA number.
* If found, then look it up in the AUX index and see if the normalized
* name matches. If so, it is a match.
*
* If this scheme fails, then (if 2's bit is set) attempt a REL file short
* name lookup and accept the resulting bank if it is an unambiguous
* match. If that doesn't work, ( and 4's bit is set) do an aux file lookup
* by forming the compound
*	(normalized bank name)(normalized city/country)
* string, and attempt an "@" name lookup in the aux index. The result
* must be an exact match in both components.

	If Long_mask not = 0 then

  	   %BEG
	   Compose ^OUT(Swfi_long_tmp_vstr),
		Ent_credit_set.Cdt_name1, " ",
		Ent_credit_set.Cdt_name2, " ",
		Ent_credit_set.Cdt_name3, " ",
		Ent_credit_set.Cdt_name4, /;
	
	   Swfi_misc_parse ^NOSPACE_SKIP, ^IN(Swfi_long_tmp_vstr),
		^ONEOF (
			(^STRING, "ABA", ^OPTION(^SPACE, "ROUTING"),
				^OPTION(^SPACE, "ROUTE"), ^SPACE,
				^ONEOF("NO.","NO","NUMBER","CODE","")),
			(^STRING, "ROUT",^ONEOF("E","ING"), ^SPACE,
				^ONEOF("NO.","NO","NUMBER","CODE","") ) ),
		Swfi_2nd_id (^STRING <-1>
		     (<CHAR$M_NUMBER!CHAR$M_SPACE!CHAR$M_SIGN!CHAR$M_PERIOD>));
	   Swfi_temp_status = Swfi_misc_parse STATUS;
	   Swfi_misc_parse ^SPACE_SKIP;
	   %END
*
* If there is an apparent FED ABA number, and it passes the MOD 10 check, then
* do a lookup of the FED ABA and see if the normalized form of the bank
* name from the SWIFT wire matches the normalized form of the name from
* the REL or AUX database record. If the ABA is valid but the name match
* fails, accept it but route it with a full parse flag of "2" instead of "1".
*
	   IF Success_Is in Swfi_temp_status THEN
	      PERFORM Z200_NORMALIZE_2ND_ID THRU Z200_NORMALIZE_2ND_ID_END
	      MOVE Swfi_tmp_vstr_length TO Swfi_swf_id_length
	      MOVE Swfi_tmp_vstr(1:Swfi_tmp_vstr_length) TO Swfi_swf_id
	      CALL "VALIDATE_ABA" USING
	         BY REFERENCE Swfi_swf_id
	       RETURNING Swfi_temp_status
	      IF Success_Is in Swfi_temp_status
	         MOVE "A" TO Swfi_swf_idt
	         SET Other_title IN Relget_title_flag TO TRUE
	         PERFORM X700_MINI_LOOKUP THRU X700_MINI_LOOKUP_END
	         IF SUCCESS_IS in Swfi_minilook_status THEN
		    %Beg
		    Swfi_cmp_id1 = NULL ;
		    Swfi_cmp_id2 = NULL ;
		    %End
		    CALL "AUTONAM" USING
              	        by reference Cdt_name1 of Ent_credit_set 
              	        by reference Cdt_name1_length of Ent_credit_set_lengths 
              	        by reference Swfi_cmp_id1
              	        by reference Swfi_cmp_id1_length

		    CALL "AUTONAM" USING
              	        by reference Swfi_name1
              	        by reference Swfi_name1_length
              	        by reference Swfi_cmp_id2
              	        by reference Swfi_cmp_id2_length
*
* Compare up to the length of the AUX file name string
*
		   IF Swfi_cmp_id1(1:Swfi_cmp_id2_length) =
			 		    Swfi_cmp_id2(1:Swfi_cmp_id2_length)
	           THEN
		       IF Mapsh_Full_parse_flag = "Y" THEN
			   MOVE "1" TO Mapsh_Full_parse_flag
		       END-IF
		       MOVE 1 TO Swfi_oneof_ord
		   ELSE
		       IF Mapsh_Full_parse_flag = "Y" or "1" THEN
			   MOVE "2" TO Mapsh_Full_parse_flag
		       END-IF
		       MOVE ZERO TO Swfi_oneof_ord
		   END-IF
*
* Success: return the lookup key as the credit party identifier
*
		   MOVE "A" TO Cdt_idtype OF Cdt_typ OF Ent_credit_set
		   %BEG
		   Ent_credit_set.cdt_typ.Cdt_idtype = "A";
		   Ent_credit_set.Cdt_typ.Cdt_id = Swfi_swf_id;
		   Swfi_misc_Compose ^OUT(Swfi_temp_memo),
			"CDT party lookup via unstructured Fed ABA",
			Swfi_oneof_ord (^ONEOF("", " - good name match")), /;
		   ALLOC_END: Ent_msg_history(
					.Qname (.IdBank = Mapsh_Current_bnk_key,
						.Idloc  = NULL,
						.Idname = "*SYS_MEMO"),
				        .Qtype  = "OBJTYP$_NULL",
					.Memo	= Swfi_temp_memo );
		   Swfi_temp_memo = NULL ;
		   %END
		   ADD 1 TO Mapsh_Memo_count
		   SET Success_Is in Swfi_matched_by_name to TRUE
		   GO TO X600_CDT_MATCH_BY_NAME_END
		   END-IF
	       END-IF
	   END-IF
	END-IF.
*
* ABA was not located or did not work or option is not selected.
* See if name lookup option (bit 1) is selected.
*
* REL_NAME_LOOKUP

	DIVIDE Long_mask BY 2 GIVING Long_mask.
	IF Long_mask = 0 THEN	       %^ Rotated 1's bit out.  Have 2's and 4's
	   SET Failure_is in Swfi_matched_by_name to TRUE

	ELSE
*
* Get encoded form of name line for lookup
*
	   %Beg
	   Swfi_cmp_id1 = NULL;
	   BREAK: Relget_adr_set;
	   %End
           CALL "AUTONAM" USING
	       by reference Cdt_name1 of Ent_credit_set 
               by reference Cdt_name1_length of Ent_credit_set_lengths 
               by reference Swfi_cmp_id1
               by reference Swfi_cmp_id1_length
%^
%^ Try a short name lookup using the name only. If the result is unambiguous,
%^ pay it but route it as a type 2 full-parse.
%^
	   Move SPACE to Swfi_pend_del
           CALL "ACCT_LOOKUP" USING
	        BY Content "N"
	        BY REFERENCE Swfi_cmp_id1
	        BY REFERENCE Swfi_ovr
	        BY REFERENCE Mapsh_Cdt_ambig_flg
	        BY REFERENCE Mapsh_Cross_bank_search
	        BY REFERENCE Swfi_blank_str_3
	        By Reference Swfi_pend_del

           IF (Swfi_ovr = SPACE) THEN
	       %BEG
	       Swfi_misc_compose ^OUT(Swfi_temp_memo),
			"CDT party lookup in REL file by name", /;
	       ALLOC_END: Ent_msg_history(
				.Qname (.Idbank = Mapsh_Current_bnk_key,
					.IdLoc  = NULL,
					.Idname = "*SYS_MEMO"),
				.Qtype  = "OBJTYP$_NULL",
				.Memo	= Swfi_temp_memo );
	       Swfi_temp_memo = NULL ;
	       Ent_credit_set.Cdt_typ (.Cdt_idtype = "N",
				    .Cdt_id = Swfi_cmp_id1);
	       BREAK: Relget_adr_set;
	       %END
	       ADD 1 TO Mapsh_Memo_count
* ==========
* Best guess lookups shouldn't go straight through
* Routing table has entries (at least for bank) for parse flag 
* settings of 1, 2, and 3 which send msgs to a verify queue

	       IF Mapsh_Full_Parse_Flag = "Y"
	       THEN
	           IF (Cdt_adr_type of Ent_credit_set (3:1) NOT = "B" and "I")
		      OR ( Bnp_Id of Ent_Credit_Set = SPACES
		           AND Bnp_Name1 of Ent_Credit_Set(1:Bnp_name1_length
					     of Ent_credit_set_lengths) = SPACES
		           AND Bnp_Name2 of Ent_Credit_Set (1:Bnp_name2_length
					     of Ent_credit_set_lengths) = SPACES
		           AND Bnp_Name3 of Ent_Credit_Set (1:Bnp_name3_length
					     of Ent_credit_set_lengths) = SPACES
		           AND Bnp_Name4 of Ent_Credit_Set (1:Bnp_name4_length
				           of Ent_credit_set_lengths) = SPACES )
		   THEN
%^ When BNP not set, then we have only 2 parties - BNF was mapped as CDT
%^ Also, even if there are 3 parties, set to "3" if the party we are paying is not a bank or internal dept
%^ **counting of cdt parties done in map_fields locally - not here
		       MOVE "3" TO Mapsh_Full_Parse_Flag
		   ELSE
		       MOVE "2" TO Mapsh_Full_Parse_Flag
		   END-IF
	       END-IF
	       SET Success_Is in Swfi_matched_by_name to TRUE
	       GO TO X600_CDT_MATCH_BY_NAME_END
	   END-IF
	END-IF.
*
* Not in the rel file or not configured to look there.
*

* AUX_NAME_LOOKUP

	DIVIDE Long_mask BY 2 GIVING Long_mask.
	IF Long_mask = 0 THEN		%^ 4's bit remains.
	   SET Failure_Is in Swfi_matched_by_name to TRUE
	   GO TO X600_CDT_MATCH_BY_NAME_END
	END-IF.


*
* Append last line compression to the name-line compression resulting in
* no more than 20 characters including the separating "/". Rule is to take
* at least 7 characters from the second string unless it is smaller than
* 7 to begin with. "/" is always appended even if the second string is null.
*
	IF (Swfi_cmp_id1_length + Swfi_cmp_id2_length) > 19 THEN
	   IF Swfi_cmp_id1_length > 12 THEN 
	      MOVE 12 TO Swfi_cmp_id1_length
	   END-IF
	   IF (Swfi_cmp_id1_length + Swfi_cmp_id2_length) > 19 THEN 
	      MOVE 7 to Swfi_cmp_id2_length
	   END-IF
	END-IF.
*
* Search to position to first possible match
*
	%beg
	Aux_sname_index ^SEARCH (
	 geq,
	 .Rel_name_key(
	  .Idbank = null,
	  .Idtype = "@",
	  .Idkey = Swfi_cmp_id1 ) );
	Aux_sname_index(eql);
	%end
*
* Find out how many (leading) characters match the search string.
* That length, provided it is at least 6, becomes the benchmark for looking
* for an unambiguous match.
*
	MOVE 1 TO Swfi_loop_ind.
	PERFORM UNTIL (Idkey of Rel_name_key of
					Aux_sname_index(Swfi_loop_ind:1)
					    NOT = Swfi_cmp_id1(Swfi_loop_ind:1))
		      OR (Swfi_loop_ind > Swfi_cmp_id1_length)
	    ADD 1 TO Swfi_loop_ind
	END-PERFORM.
	SUBTRACT 1 FROM Swfi_loop_ind.
*
* Swfi_loop_ind reflects the number of leading, matching
* characters on the first index entry found. If it is not at least 6,
* or the entire original length of Swfi_cmp_id1, then fail.
*
	SET Failure_Is in Swfi_matched_by_name to TRUE.
	IF ((Swfi_loop_ind < 6) AND (Swfi_loop_ind < Swfi_cmp_id1_length)) OR
	    (Swfi_cmp_id1_length = 0) THEN
	    GO TO X600_CDT_MATCH_BY_NAME_END
	END-IF.
	MOVE Swfi_loop_ind TO Swfi_cmp_id1_length.

*
* Step through all entries which match in the first component.
* Search the full name and address for each of the words found in the
* address description, which should contain the city, country, and
* may contain a state and/or a zip code.
* Keep track of the entry with the largest number of words matched in the
* name and address; provided there is only one such winner, then it is
* taken to be the matching entry. If there is a tie, or if no entry contains
* any matching words, then fail.
*
	MOVE ZERO TO Swfi_best_match.		%^ Record word count so far

	PERFORM UNTIL Swfi_cmp_id1(1:Swfi_cmp_id1_length) is not =
	  Idkey of Rel_name_key of Aux_sname_index(1:Swfi_cmp_id1_length)
*                         
* Name component matches
*
	    PERFORM Z300_MATCH_DESC_WORDS THRU Z300_MATCH_DESC_WORDS_END
	    EVALUATE TRUE
		WHEN Swfi_word_count = Swfi_best_match
		     SET Failure_Is in Swfi_matched_by_name to TRUE

		WHEN Swfi_word_count > Swfi_best_match
		     %BEG
		     Aux_sname_index CONN: Aux_adr_set;
		     BREAK: Aux_adr_set;
		     %END
		     MOVE Swfi_word_count TO Swfi_best_match
		     SET Success_Is in Swfi_matched_by_name to TRUE

	    END-EVALUATE
*
* Step to next entry
*
	    %BEG NEXT: Aux_sname_index; %END

	END-PERFORM.
*
* If no unique match was found, return failure
*
	IF Failure_Is in Swfi_matched_by_name THEN
	   GO TO X600_CDT_MATCH_BY_NAME_END
	END-IF.

*
* Found a match.
* RELGET_ADR_SET instrument fields contain matching AUX record.
* Return an identifier corresponding to the type of AUX record
*
	EVALUATE TRUE

	    WHEN Aba_id OF Aux_adr_set NOT = SPACES
		 MOVE "A" TO Cdt_idtype OF Cdt_typ OF Ent_credit_set
		 MOVE Aba_id OF Aux_adr_set TO Swfi_swf_id
		 MOVE 9 TO Swfi_swf_id_length

	    WHEN Chips_uid_id OF Aux_adr_set NOT = SPACES
		 MOVE "C" TO Cdt_idtype OF Cdt_typ OF Ent_credit_set
		 MOVE Chips_uid_id OF Aux_adr_set TO Swfi_swf_id
		 MOVE 6 TO Swfi_swf_id_length

	    WHEN Swift_id OF Aux_adr_set NOT = SPACES
		 MOVE "S" TO Cdt_idtype OF Cdt_typ OF Ent_credit_set
		 MOVE Swift_id OF Aux_adr_set TO Swfi_swf_id
		 MOVE Swift_id_length OF Aux_adr_set_lengths
							  TO Swfi_swf_id_length

	    WHEN OTHER
		 SET Failure_IS in Swfi_matched_by_name TO TRUE
		 GO TO X600_CDT_MATCH_BY_NAME_END
	
	END-EVALUATE.

*
* Return the lookup key as the credit party identifier
*
	%BEG
	Ent_credit_set.Cdt_typ.Cdt_id = Swfi_swf_id;
	Swfi_misc_Compose ^OUT(Swfi_temp_memo),
		"CDT party lookup in AUX file by name and city/country", /;
	ALLOC_END: Ent_msg_history(
			.Qname (.IdBank = Mapsh_current_bnk_key,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.Qtype  = "OBJTYP$_NULL",
			.Memo   = Swfi_temp_memo);
	Swfi_temp_memo = NULL;
	%END
	ADD 1 TO Mapsh_Memo_count.
*
* Name lookup has succeeded: return success status
*
* 
* Best guess lookups shouldn't go straight through
* Routing table has entries (at least for bank) for parse flag
* settings of 1, 2, and 3 which send msgs to a verify queue

	IF Mapsh_Full_Parse_Flag = "Y"
	THEN
	   IF Bbk_Id of Ent_Credit_Set = SPACES
	   AND Bbk_Name1 of Ent_Credit_Set = SPACES
	   AND Bbk_Name2 of Ent_Credit_Set = SPACES
	   AND Bbk_Name3 of Ent_Credit_Set = SPACES
	   AND Bbk_Name4 of Ent_Credit_Set = SPACES
	   THEN
	      %^ When BBK not set, then we don't have 3 credit parties
	      %^ **counting of cdt parties done in map_fields locally - not here
	      MOVE "2" TO Mapsh_Full_Parse_Flag
	   ELSE
	      MOVE "3" TO Mapsh_Full_Parse_Flag
	   END-IF
	END-IF.

    	SET Success_Is in Swfi_matched_by_name TO TRUE.

X600_CDT_MATCH_BY_NAME_END.
	Exit.

X700_MINI_LOOKUP.
*
* if wrong ID type don't do lookup
*
* INPUT (et.al.):
*	RELGET_TITLE_FLAG initialized by caller.

	SET Failure_Is in Swfi_minilook_status to TRUE.

	If ((Swfi_swf_idt not = "A") and
	    (Swfi_swf_idt not = "P") and
	    (Swfi_swf_idt not = "S")) then
	    go to x700_mini_lookup_end
	END-IF.
*
* Check to see if the length of the identifier is greater than 24 prior to
* calling "ACCT_LOOKUP" in order to prevent string overflows. If the length
* is greater than 24, the lookup will assumed to have failed.
*
	IF Swfi_swf_id_length > 24 THEN
		go to x700_mini_lookup_end
	END-IF.

	move zero to Swfi_name1_length;
	move zero to Swfi_name2_length;
	move zero to Swfi_name3_length;
	move zero to Swfi_name4_length;
	Move spaces to Swfi_swf_bank.

	%Beg Break: Relget_adr_set; %End
*
* Try lookup
*
	Move SPACE to Swfi_pend_del
	CALL "ACCT_LOOKUP" USING
	     BY REFERENCE Swfi_swf_idt
	     BY REFERENCE Swfi_swf_id
	     BY REFERENCE Swfi_ovr
	     BY REFERENCE Mapsh_Cdt_ambig_flg
	     BY REFERENCE Mapsh_Cross_bank_search
	     BY REFERENCE Swfi_blank_str_3
	     By reference Swfi_pend_del.
*
*
*
* If lookup failed, we're done
* But check for different return status for aux DB.
*
	IF Swfi_ovr NOT = SPACE THEN
	   IF Relget_msgcode NOT = "VMSG$_DAT_NOTONFILE" THEN
	      GO TO X700_MINI_LOOKUP_END
	   END-IF
	END-IF.
*
* Lookup succeeded (in REL file or AUX database).
* Copy name and address from account file.
*
	SET Success_Is in Swfi_minilook_status to TRUE.
	%BEG
	Swfi_name1 = Relget_adr_set.adr_name;
	Swfi_name2 = Relget_adr_set.adr1;
	Swfi_name3 = Relget_adr_set.adr2;
	Swfi_name4 = Relget_adr_set.adr3;
	Swfi_swf_bank  = Relget_adr_set.bnk_id;
	%END
*
* If there's a zip code, call subroutine to put it into address
*
	IF Zip OF Relget_adr_set NOT = SPACES THEN
	   CALL "ZIPSUB" USING
		BY REFERENCE Swfi_name4,
		BY REFERENCE Swfi_name4_length,
		BY REFERENCE Swfi_name3,
		BY REFERENCE Swfi_name3_length,
		BY REFERENCE Zip OF Relget_adr_set,
		BY REFERENCE Line_flg_ws
	END-IF.

X700_MINI_LOOKUP_END. EXIT.

   EXIT.
X800_GET_PRULE_PARAM.

%^ Swfi_prule_param_name is input to return the parameter value.

	Set Failure_is in Swfi_prule_status to true.
	%Beg Swfi_prule_value = null; %End.
	Initialize Swfi_prule_vals_left.

	Call "PRULE_MSG_GET_PARAM" using
	  by reference Swfi_prule_param_name
	  by reference Swfi_prule_param_name_length
	  by reference Swfi_prule_level
	  by reference Swfi_prule_source
	  by reference Swfi_prule_edit
	  by reference Swfi_prule_vals_left
	  by reference Swfi_prule_value
	  by reference Swfi_prule_value_length
	  returning Swfi_prule_status.

X800_GET_PRULE_PARAM_END. EXIT.

X1000_CHECK_TEST.
*
* For banks that have EMF enabled, a cust routine exists that can change the
* INBOUND and OUTBOUND test requried states.
*
        If (EMF_enabled of Menu_cfg = "T")

***********************************************************
*      Brought this chunk over from 1.2
***********************************************************
%^ #139009 do not check for a carrier.
%^	   If Dst_carrier of Ent_dst_set NOT = spaces then
%^    		 %Beg Swfi_Temp_dst_carrier = Ent_dst_set.dst_carrier; %End 
%^	   Else

	      If Mapsh_swfrout_id not = spaces then
	         Move 1 to Swfi_dest_ovr_flag	
		 SET dst IN relget_title_flag TO TRUE
		 Move "F" to Swfi_pend_del
		 CALL "ACCT_LOOKUP" USING
		  BY REFERENCE Mapsh_swfrout_idtype
	  	  BY REFERENCE Mapsh_swfrout_id
	  	  BY REFERENCE Swfi_swf_ovr
	  	  BY content   "T"
	  	  BY REFERENCE Mapsh_cross_bank_search
	  	  BY content   "   "
	  	  BY Reference Swfi_pend_del
		 RETURNING Swfi_return_status

		 If success_is in Swfi_return_status then

        	    %BEG
		    Break: Ffant_msg_union;
		    Break: Ffant_hist;
		    Ent_msg_union EQUATE: Ffant_msg_union;
	            Ffant_msg_union.dst_seq CONN: Ent_dst_seq; 
		    ALLOC_TEMP: Ffant_hist(mod);
		    ALLOC_END: Ffant_Hist(.Qname(.Idbank = Mapsh_current_bnk_key,
		   			  .Idloc = null,
					  .Idname = "*SUB_HISTORY"),
	       			   .Qtype = "OBJTYP$_MSG_HISTORY_SEQ",
	       			   .Memo = NULL,
		    ALLOC: Ent_Msg_Subhist(MOD) ) ;
		    Ent_dst_seq(MOD);
	            ALLOC_END: Ent_Dst_Seq(
		        ALLOC: Ent_Dst_Set(MOD));
	            %End


          	    %BEG relget_adr_set.dst_seq CONN: ent_adr_dst_seq ^FIRST(NOMOD); %END
          	    IF (Success_is in ent_adr_dst_seq_status  ) THEN

 			%Beg
	  		Swfi_blank_str_3 = "   ";
	  		Swfi_blank_str_4 = "    ";
			%End


       			CALL "WIRE_ADR" USING
	 		   BY REFERENCE Swfi_Blank_Str_3	       %^ spaces = no wire type known
	 		   BY REFERENCE Swfi_Blank_Str_4	       %^ spaces = no specific carrier
	 		   BY REFERENCE Swfi_zero_long	       %^ zero means start at beginning
	 		RETURNING Swfi_Return_Status
		    End-if
		 End-if

%^ #140779 Use the IRT Prule carrier, instead of the Ent_dst_set_carrier if the following are met.

		 If IRT in Mapsh_routing_option And
		    Mapsh_swfrout_carrier Not = Spaces Then
		    %Beg
		    Swfi_Temp_dst_carrier = Mr_rout_cond_seq.rcs_addl_route.rcs_carrier;
		    %End
	   	Else
	   	    %Beg  Swfi_dest_conn = Ent_dst_set state.conn;  %End
	   	    If (Swfi_dest_conn = 0 )
		    	Move SPACES to Swfi_temp_dst_carrier
	   	    ELSE
	            	%Beg 
     			Swfi_Temp_dst_carrier = Ent_dst_set.dst_carrier; 
			Ent_dst_set(MOD);
	       	    	%End
	   	     END-IF
	       	End-if

%^ #139009 Null the carrier in preparation for the next swift message to be loaded.
%^ CR1228 Subject not connected trap

		If Success_is in Swfi_return_status
		Then
    		    %Beg 
			Ent_dst_set.dst_carrier = NULL; 
		 	Delete_then_prev: Ent_dst_seq;
		    %End 
		End-if

		 %Beg
		 Break: Ffant_msg_union;
		 Break: Ffant_hist;
		 Break: Ent_msg_subhist;
		 Break: Ent_dst_seq;
		 Break: Ent_dst_set;
		 %End
	      End-if
%^ #139009	   END-IF
***********************************************************
*	end of chunk brought over from 1.2
***********************************************************

	   Move Incoming_msgtype of Ent_ftr_set to Swfi_incoming_msgtype

	   Call "CUST_GET_TESTKEY_RQTS" using
		by reference Bank of Loc_info of Ent_ftr_set
		by reference Src_code of Ent_ftr_set
		by reference Swfi_Temp_dst_carrier
		by reference Swfi_Incoming_msgtype
		by reference Test_req_flg of Flgs of Ent_ftr_set
		by reference Swfi_in_test
		by reference Swfi_out_test
	      RETURNING Swfi_Return_status
    
	   %Beg
	   Swfi_Temp_dst_carrier = NULL;		%^ #140779 icr_003440
	   Mapsh_test_out = Swfi_out_test; 
	   BREAK: relget_adr_set; 
	   BREAK: ent_adr_dst_seq;
	   %End


	End-if.

X1000_CHECK_TEST_END.
	EXIT.

ZA100_PARTY_DETERMINATION.

* The site-specific party determination routine is a hook that can accomplish
* almost anything that is outside the ordinary MTS paradigm.  Not all customers
* need one, and every one is different.

	%Beg 
	Ptydet_param_rec.Ptydet_dbt2nd_id = Mapsh_dbt_2nd_id;
	Ptydet_param_rec.Ptydet_cdt2nd_id = Mapsh_cdt_2nd_id;
	%End

	Call "CUST_PARTY_DETERMINATION" using by reference Ptydet_param_rec
			returning Swfi_pd_status.


	If Failure_is in Swfi_pd_status
	Then	%Beg
		Swfi_Hist_memo = "Cust Party Determination error.";
		%End
		ADD 1 TO Mapsh_Memo_count
		Move "N" to Mapsh_Full_parse_flag
		Go to ZA100_PARTY_DETERMINATION_END
	End-if.

	If Ptydet_dbt2nd_id of Ptydet_param_rec not = Mapsh_dbt_2nd_id
		%Beg Mapsh_dbt_2nd_id = Ptydet_param_rec.Ptydet_dbt2nd_id; %End
	End-if.
	If Ptydet_cdt2nd_id of Ptydet_param_rec not = Mapsh_cdt_2nd_id
		%Beg Mapsh_cdt_2nd_id = Ptydet_param_rec.Ptydet_cdt2nd_id; %End
	End-if.

	%^ Allow Party Determination's full parse flag to override ours, unless
	%^ ours is N


	If  (Ptydet_Full_parse of Ptydet_param_rec not = space) and
     	    (Mapsh_Full_parse_flag not = "N") then
	    Move Ptydet_full_parse of Ptydet_param_rec to Mapsh_Full_parse_flag
	End-if

	If Ptydet_action_string of Ptydet_param_rec NOT = space then
	   Move Ptydet_action_string of Ptydet_param_rec to Swfi_temp_command  

	   %Beg
	   Swfi_compose ^OUT(Swfi_2nd_routing_memo) "*MRH/MAP/",Swfi_temp_command "/", Mapsh_full_parse_flag, /;
	   ALLOC_END: Mr_rout_cond_seq (.Rcs_route(.Rcs_Category 	= "CUSTOM",
		       	        	   	   .Rcs_Command  	= Swfi_temp_command),
				        .Rcs_Routing_Str   		= "",
				        .Rcs_Rtg_Memo1	   		= "",
				        .Rcs_Rtg_Memo2	   		= Swfi_2nd_routing_memo);

	   %End
	End-if.



ZA100_PARTY_DETERMINATION_END.
	EXIT.

ZA110_AUTOTRIEVE.

* Issue autotrieve call, mapping results back to the message
* Input:
*	SWFI_HG_REQUEST_TYPE contains VLD or ADR
*	SWFI_HG_DBT_CDT contains DR or CR

	MOVE 0 TO Swfi_tmp_vstr_length.
	MOVE SPACE TO Swfi_tmp_vstr (1:3).

	CALL "HOST_GET" USING
		BY REFERENCE Swfi_Hg_request_type,
		BY REFERENCE Swfi_tmp_vstr,		%^ Account bank field is blank - HOST_GET will derive from message
		BY REFERENCE Swfi_tmp_vstr,		%^ IDTYPE is blank - HOST_GET will parse from party fields
		BY REFERENCE Swfi_tmp_vstr_length,	%^ Account number length and
		BY REFERENCE Swfi_tmp_vstr,		%^ Account number are null
		BY REFERENCE Swfi_tmp_vstr,		%^ 3-char system of record field is blank
		BY REFERENCE Swfi_Hg_dbt_cdt,		%^ "DR" for debit party and "CR" for credit party
		BY CONTENT "SWF",			%^ Calling function
		By Reference Swfi_Edit_memo,		%^ VIDEO_MSG
		BY CONTENT " ",				%^ Release flag - indicates item is "ready for release"
		BY Reference Swfi_Party_changed		%^ Output: HOST_GET sets this field if it changed a party
		RETURNING Swfi_return_status.

*
* use new Autotrieve Result to decide what to do next.
* EXC (formerly status B, C, D, M, N, P, X) route to repair
* UNV (formerly status F, L, U, I) route to autotrieve holdq
* SPACES, success or call not configured.
*
* this is going to be decided just before the call to MAP_ROUTE


ZA110_AUTOTRIEVE_END.
	EXIT.

ZA120_PERFORM_LOOKUPS.
****************************************************************************
*
* LOOKUP ROUTINES GO HERE
*
* Define Lookup routine calling parameters which are specific to calling program
*	(Others will be set in DO_MAP_LOOKUPS from commonly held data in 
*	 ENT_FTR, ENT_DEBIT, and ENT_CREDIT sets)
*



* Set up CHIPS qualification parameters
*
* Always try to CHIPS qualify payments from SWIFT or ISO.
* (SEEMS to be the right thing to do here functionally.)
*
	If (Mapsh_Payment NOT = 0 )
	   Move 1 to Mapsh_Qualify_chips
	ELSE
	   Move 0 to Mapsh_Qualify_chips
	END-IF.

*
* If /D/ or /C/ indicator found in debit or credit party set account
* type search to go after a nostro or vostro.
*
* If MAP_GL_OVERRIDE set, Sender has indicated that the general ledger account will be used
*

	If Swfi_gl_override = "Y" then

	   IF  (Mapsh_Dbt_swf_acct = "C") then
	       %Beg  Mapsh_Dbt_account_type = "G" ;  %End
	   ELSE
	       %Beg  Mapsh_Dbt_account_type = " " ;  %End
	   END-IF

	   IF (Mapsh_Cdt_swf_acct = "D") then
	      %Beg  Mapsh_Cdt_account_type = "G" ;  %End
	   ELSE
	      %Beg  Mapsh_Cdt_account_type = " " ;  %End
	   END-IF

	Else

	   IF  (Mapsh_Dbt_swf_acct = "C") then
	       %Beg  Mapsh_Dbt_account_type = "F" ;  %End
	   End-if
	   If (Mapsh_dbt_swf_acct = "D") then
	       %Beg  Mapsh_Dbt_account_type = "D" ;  %End
	   END-IF

	   IF (Mapsh_Cdt_swf_acct = "C") then
	      %Beg  Mapsh_Cdt_account_type = "F" ;  %End
	   End-if
	   
	   If (Mapsh_cdt_swf_acct = "D") then
	      %Beg  Mapsh_Cdt_account_type = "D" ;  %End
	   END-IF
	End-if.
*
* Check location table cases
*
* Now check to see if we're going to have the location table case for DEBIT
*
	%Beg
	Mapsh_Dbt_account_id = NULL ;
	Swfi_saved_dbt_idtype = " " ;
	%End
	If (Dbt_idtype of Dbt_typ of Ent_debit_set = "S") then	
	    Call "ACCT_LOOKUP" USING
	         by reference Dbt_idtype of Dbt_typ of Ent_debit_set
	         by reference Dbt_id of Dbt_typ of Ent_debit_set
	         by reference Swfi_tmp_ovr
	         by content "T"
	         by reference Mapsh_cross_bank_search
	         by reference Currency_code of Ent_ftr_set
		 By reference Swfi_pend_del
	       Returning Swfi_temp_status
*
*  We have the location table case.
*
            If (Swfi_tmp_ovr = "?")
		AND (Fx_ena of Menu_cfg = LOW-VALUES)
		AND (Swfi_pend_del NOT = "T" )
		%BEG Swfi_swf_id = Ent_debit_set.dbt_typ.dbt_id; %END
		PERFORM X470_FIND_ACC_USING_LOC THRU X470_FIND_ACC_USING_LOC_END
*
*  We resolved ambiguity via table so set things up.
*
		IF Success_Is in Swfi_acc_by_loc
		   %Beg
		      Swfi_saved_dbt_idtype = Ent_debit_set.Dbt_typ.Dbt_idtype ;
	 	      Swfi_saved_dbt_id     = Ent_debit_set.Dbt_typ.Dbt_id ;
		      Ent_debit_set.Dbt_typ.Dbt_idtype = "#" ;
		      Swfi_Misc_Compose ^OUT(Ent_debit_set.Dbt_typ.Dbt_id)
				Relget_adr_set.rel_id, / ;
		      Mapsh_Dbt_account_id = Ent_acc_set.acc_id ;	
		   %End
		END-IF
	    END-IF
	END-IF.
*
* Now check to see if we're going to have the location table case for CREDIT
*
	%Beg
	Mapsh_Cdt_account_id = NULL ;
%^
%^ Now check to see if we're going to have the location table case.
%^
	Swfi_saved_cdt_idtype = " " ;
	%End
	If (Cdt_idtype of Cdt_typ of Ent_credit_set = "S" )	
	   Call "ACCT_LOOKUP" USING
	        by reference Cdt_idtype of Cdt_typ of Ent_credit_set
	        by reference Cdt_id of Cdt_typ of Ent_credit_set
	        by reference Swfi_tmp_ovr
	        by content "T"
	        by reference Mapsh_Cross_bank_search
	    	by reference Currency_code of Ent_ftr_set
		by reference Swfi_pend_del
	     Returning Swfi_temp_status
*
*  We have the location table case.
*
           If (Swfi_tmp_ovr = "?" )
	      AND (Fx_ena of Menu_cfg = LOW-VALUES)
	      AND (Swfi_pend_del NOT = "T" )
	      %BEG Swfi_swf_id = Ent_credit_set.cdt_typ.cdt_id; %END
	      PERFORM X470_FIND_ACC_USING_LOC THRU X470_FIND_ACC_USING_LOC_END
*
*  We resolved ambiguity via table so set things up.
*
	      IF Success_Is in Swfi_acc_by_loc
 		    %Beg
		    Swfi_saved_cdt_idtype = Ent_credit_set.Cdt_typ.Cdt_idtype ;
		    Swfi_saved_cdt_id     = Ent_credit_set.Cdt_typ.Cdt_id ;
		    Ent_credit_set.Cdt_typ.Cdt_idtype = "#" ;
		    Swfi_misc_compose ^OUT(Ent_credit_set.cdt_typ.cdt_id )
				Relget_adr_set.rel_id, /, ;
	  	    Mapsh_Cdt_account_id = Ent_acc_set.acc_id ;	
		 %End
	      END-IF
	    END-IF
	END-IF.
*
* Check the advice type overrides from mapping
*
* 
* If the Swfin_fed_adv_override is set, always set the credit advice
* to Fed if we found a //FW provided it is a valid advice type for the bank.
*
* ==========
	IF  (((Swfin_Fed_adv_override of Menu_Cfg = "T") AND 
	      (Success_Is in Mapsh_Found_Fw) AND
	      (Cdt_adv_typ of Ent_Credit_Set NOT = "FED"))
	OR	
	    (((Cdt_idtype of Cdt_typ of Ent_credit_set = "S") AND 
	      (Mapsh_Cdt_2nd_idtype = "A" )) ))
	THEN
	    If Success_Is in Mapsh_Allow_Fed_Advice
	   %Beg
	      Ent_Credit_Set.Cdt_adv_typ = "FED"; 
	      Ent_ftr_set.Flgs.Cdt_adv_flg = "Y" ;
	   %End
	END-IF.

* 5.5 Retain Credit Party - INTRTL checks are in sub-program
*     which will do push down if credit party & message meet 
*     criteria.  Set CHIPS qualify flag if logic is triggered.
* 	#49634/55784  
     
      Call "RETAIN_CREDIT_PARTY" returning Return_status_ws.
      If Success_is in Return_status_ws 
                move 0 to Mapsh_Qualify_chips
	        add 1 TO Mapsh_Memo_count
	   	%Beg
	 	Compose ^Out(Swfi_Hist_memo)
			"*SWFIN: Original Credit Party id retained.", /;
	        %End
      END-IF.

*
* Do CREDIT pre-lookup by name if id no found by mappers
*
	IF  (Cdt_id OF Ent_credit_set = SPACES ) 
	AND (Cdt_name1 of Ent_credit_set not = spaces) 
	AND (Cdt_adv_typ of Ent_credit_set NOT = "CHK" OR "CHQ") 
	THEN
	   PERFORM X600_CDT_MATCH_BY_NAME THRU X600_CDT_MATCH_BY_NAME_END
	   IF (Failure_Is in Swfi_matched_by_name)
	      and (Mapsh_Payment = 1)
	   THEN
	      Set Success_Is in Swfi_prelookup_by_name to TRUE
	      IF Cdt_ovr OF Cdt_typ OF Ent_credit_set = SPACES THEN
	   	 %BEG Ent_credit_set.Cdt_typ.Cdt_ovr = "*"; %END
	      END-IF
	   END-IF
	END-IF.


*
* Make sure bank context is set correctly
*
	If (Mapsh_Current_bnk_key not = Swfi_reset_bank) and 
	   (Mapsh_cross_bank_search = "Y")
	Then	
	    Move Swfi_reset_bank to Mapsh_Current_bnk_key
	    Move fut_bound_date_ws to Mapsh_future_date
	    Move backdate_bound_date_ws to Mapsh_back_date

	    CALL "SET_BANK_CONTEXT" 

	    Move Mapsh_future_date to fut_bound_date_ws
	    Move Mapsh_back_date to backdate_bound_date_ws
	End-if.
	Move Currency_Code of Ent_Ftr_Set to Swfi_Save_Ftr_Curr.

*
* Now do the lookups
*

	If Incoming_msgtype of Ent_ftr_set = "910"
	    %Beg
	    Mapsh_cdt_account_id(
		.Idbank = Ent_ftr_set.Loc_info.Bank,
		.Idtype = Ent_credit_set.Cdt_typ.Cdt_idtype,
		.Idkey = Ent_credit_set.Cdt_typ.Cdt_id);
	    %End
	End-if

	CALL "DO_MAP_LOOKUPS" USING
	    By Content "Y"			%^ Yes, call debitside_lookup
	    By Content "Y"			%^ Yes, call creditside_lookup
	    By reference Swfi_long_zero_wc	%^ No. don't Lock_Dbt_Party
	    By reference Swfi_long_zero_wc.	%^ No, don't Lock_Cdt_Party

	PERFORM ZA130_CHK_LOOKUPS THRU ZA130_CHK_LOOKUPS_END.


ZA120_PERFORM_LOOKUPS_END.
	Exit.

ZA125_LOOKUP_TRADE.

	%Beg
	BREAK: Ent_errors_seq;
	ALLOC_TEMP: Ent_errors_seq(MOD) ;
	%End


	If ( Cross_Bank_Search OF Menu_cfg = "T" OR
	     Cross_Bank_Search OF Menu_cfg = "Y" )THEN
	     Set Success_is in Swfi_cross_bank to TRUE
	Else
	     Set Failure_is in Swfi_cross_bank to TRUE
	End-if.


	CALL "TRADE_LOOKUP" Using
	     By Reference Swfi_cross_bank
	     By Reference Swfi_Owning_bank
	     By Reference Swfi_Memo_count
	     By Reference Swfi_fully_parsed
	Returning Swfi_trade_lookup_sts.

	If (Swfi_owning_bank NOT = spaces) AND
	   (Mapsh_current_bnk_key NOT = Swfi_owning_bank) THEN

           %Beg
	   Mapsh_Current_bnk_key = Swfi_owning_bank;
 	   Ent_ftr_set.Loc_info.bank = Swfi_owning_bank;
	   %End
	   CALL "SET_BANK_CONTEXT"

%^ Trades must be logged to the senders ref index in the bank for which they
%^ will be routed to allow them to be found later.  If bank context switched,
%^ make another entry for the new bank to the senders reference index.

	   %Beg Mapsh_sendrefndx_conn = Mapsh_Sendrefndx STATE.CONN; %End

	   If Mapsh_sendrefndx_conn NOT = 0  Then

	      If Orp_ref_num of Ent_debit_set not = spaces then

                 %BEG
	         ALLOC_END: Ent_msg_history(.qname(.Idbank = Mapsh_current_bnk_key,
					           .Idloc  = NULL,
					           .Idname = "SENDREFNDX"),
				            .qtype	= "QTYP$_GEN_VSTR_INDEX",
				            .memo	= NULL,
		        ALLOC_JOIN: Mapsh_Sendrefndx(.Vstr_key = Ent_debit_set.orp_ref_num,
					             .Txt = Ent_ftr_set.trn_ref ));
	         %END
	      End-if

	      If Obk_ref_num of Ent_debit_set not = spaces then

                 %BEG
	         ALLOC_END: Ent_msg_history(.qname(.Idbank = Mapsh_current_bnk_key,
					           .Idloc  = NULL,
					           .Idname = "SENDREFNDX"),
				            .qtype	= "QTYP$_GEN_VSTR_INDEX",
				            .memo	= NULL,
		        ALLOC_JOIN: Mapsh_Sendrefndx(.Vstr_key = Ent_debit_set.obk_ref_num,
					             .Txt = Ent_ftr_set.trn_ref ));
	         %END
	      End-if


	   End-If



	End-if.


	If (Swfi_memo_count > 0) then
	   %Beg First:Ent_errors_seq; %End

	   Perform until Seq_end_is in Ent_errors_seq_cursor

	      %Beg
	      ALLOC_END: Ent_Msg_History(
	           .Qname(.Idbank = Ent_ftr_set.Loc_info.bank, 
		          .Idloc = NULL,
		          .Idname= "*SYS_MEMO"),
	           .Qtype = "OBJTYP$_NULL", 
	           .Memo = Ent_errors_seq.txt);
	      Next:Ent_errors_seq;
	      %End
	      ADD 1 TO Mapsh_Memo_count
	   End-perform
	End-if.


	If Failure_is in Swfi_fully_parsed then
	   Move "N" to Mapsh_Full_parse_flag
	   MOVE "F" TO Mapsh_Charge_state
	End-if.

ZA125_LOOKUP_TRADE_END.

	Exit.

*

ZA130_CHK_LOOKUPS.
        ADD Mapsh_Cdt_errors_found TO Mapsh_Memo_count.
        ADD Mapsh_Dbt_errors_found TO Mapsh_Memo_count.

* Match up to the appropriate Relget_adr_set to set the Priority flag

        %Beg Swfi_Adr_conn_ws = Relget_adr_set State.conn; %End

        IF  Swfi_adr_conn_ws NOT = 0  
	AND Rel_id of Relget_adr_set NOT = Dbt_rel_id of Ent_debit_set
	THEN
           %Beg  BREAK: Relget_adr_set;  %End
           Move ZERO to Swfi_adr_conn_ws
        END-IF.

        IF Swfi_adr_conn_ws = 0  
	THEN
            MOVE 0 TO Rel_id of Relget_adr_set
        END-IF.

        IF Dbt_rel_id of Ent_debit_set > 0 
	AND Swfi_adr_conn_ws = 0 
	THEN
           %Beg
              Ent_debit_set.dbt_adr_set_ptr CONN: Relget_adr_set;
              Swfi_adr_conn_ws = Relget_adr_set State.conn;
           %End
        END-IF.

        IF Swfi_adr_conn_ws NOT = 0
	THEN
           IF Priority_flag of Flags of Relget_adr_set NOT = SPACE and
	      Priority_flg of Flgs of Ent_ftr_set = SPACES 
	   THEN
              %Beg
	      Ent_ftr_set.Flgs.Priority_flg =
				       Relget_adr_set.Flags.Priority_flag;  %End
           END-IF
           %Beg BREAK: Relget_adr_set; %End
	END-IF.

*
* Second debit party id was supplied but did not match.
*
	IF (Mapsh_dbt_2nd_idtype NOT = " ") 
	AND (Mapsh_matched_2nd_dbt = 0) 
	THEN
	   MOVE "F" TO Mapsh_charge_state
	END-IF.	

	IF (Swfi_saved_dbt_idtype NOT = " " )
	THEN
	   %Beg
	      Ent_debit_set.Dbt_typ.Dbt_idtype = Swfi_saved_dbt_idtype ;
	      Ent_debit_set.Dbt_typ.Dbt_id = Swfi_saved_dbt_id ;
	   %End
	END-IF.

*
* Loc table case, so we passed in an R number.  It may, however, have
* gotten pushed down by AIN's.
*
	IF (Swfi_saved_cdt_idtype NOT = " ") 
	THEN
	   IF (Cdt_idtype of Cdt_typ of Ent_credit_set = "#") 
	   THEN
	      %Beg
	         Ent_credit_set.Cdt_typ.Cdt_idtype = Swfi_saved_cdt_idtype ;
	         Ent_credit_set.Cdt_typ.Cdt_id = Swfi_saved_cdt_id ;
	      %End
	   ELSE
	      IF (Ib1_idtype of Ib1 of Ent_credit_set = "#" )
	         %Beg
	            Ent_credit_set.Ib1.Ib1_idtype = Swfi_saved_cdt_idtype ;
	            Ent_credit_set.Ib1.Ib1_id = Swfi_saved_cdt_id ;
	         %End
	      ELSE
		 IF (Ibk_idtype of Ibk of Ent_credit_set = "#" )
		 THEN
	            %Beg
	                Ent_credit_set.Ibk.Ibk_idtype = Swfi_saved_cdt_idtype ;
	                Ent_credit_set.Ibk.Ibk_id = Swfi_saved_cdt_id ;
	            %End
		 ELSE
	            IF (Bbk_idtype of Bbk of Ent_credit_set = "#" )
		    THEN
	               %Beg
	                   Ent_credit_set.Bbk.Bbk_idtype =
							Swfi_saved_cdt_idtype ;
	                   Ent_credit_set.Bbk.Bbk_id = Swfi_saved_cdt_id ;
	               %End
		    ELSE
	               IF (Bnp_idtype of Bnp of Ent_credit_set = "#" )
		       THEN
	                  %Beg
	                     Ent_credit_set.Bnp.Bnp_idtype =
							Swfi_saved_cdt_idtype ;
	                     Ent_credit_set.Bnp.Bnp_id = Swfi_saved_cdt_id ;
	                  %End
		       END-IF
		    END-IF
		 END-IF
	      END-IF		
	   END-IF
	END-IF.





ZA130_CHK_LOOKUPS_CLEANUP.

	%Beg
	   BREAK: relget_adr_set;
	   BREAK: ent_acc_set;
	%End.

ZA130_CHK_LOOKUPS_END.

	Exit.




Z200_NORMALIZE_2ND_ID.
*
* Input: Swfi_2nd_id
* Output: Copy in Swfi_tmp_vstr with punctuation stripped out
*
	MOVE 1 TO Swfi_loop_ind.
	MOVE ZERO TO Swfi_tmp_vstr_length.
	PERFORM UNTIL Swfi_loop_ind > Swfi_2nd_id_length
	    IF Swfi_2nd_id (Swfi_loop_ind:1) NOT = SPACES AND "." AND "," AND
						"-" AND "#" AND "*" THEN
		ADD 1 TO Swfi_tmp_vstr_length
		MOVE Swfi_2nd_id (Swfi_loop_ind:1) TO
					Swfi_tmp_vstr (Swfi_tmp_vstr_length:1)
	    END-IF
	    ADD 1 TO Swfi_loop_ind
	END-PERFORM.

Z200_NORMALIZE_2ND_ID_END.
	Exit.


Z300_MATCH_DESC_WORDS.
*
* Count the number of words in the description field which occur in the
* full name and address from the wire. If this entry establishes a best,
* hang onto it.
* Input:
*	Aux_sname_index contains the entry to test.
*	SWFI_LONG_TMP_VSTR contains the name and address.
* Output:
*	SWFI_WORD_COUNT contains the matching word count
*	RETURN_STATUS_WS contents unaffected

	MOVE ZERO TO Swfi_word_count.
	%BEG
	Swfi_misc_Compose ^OUT(Swfi_tmp_vstr80)
		Aux_sname_index.Memo, /;
	Swfi_misc_parse ^IN(Swfi_tmp_vstr80);
	%END
	PERFORM UNTIL Swfi_loop_forever = ZERO
	    %BEG
	    Swfi_misc_parse ^SPACE, Swfi_tmp_vstr, ^ONEOF (",", ^BLANK, /);
	    %END
	    IF (Swfi_tmp_vstr_length = ZERO)
	       OR (Failure_Is in Swfi_misc_parse_status)
	    THEN
	       GO TO Z300_MATCH_DESC_WORDS_END
	    END-IF
*
* See if this word occurs
* Don't count words of 1 or 2 characterss
*
	    %Beg
	    Swfi_misc_compose ^OUT(Swfi_tmpwild_vstr)
		"*", Swfi_tmp_vstr, "*", / ;
	    %End
	    CALL "NEX_MATCH_STRINGS" using
		By Reference Swfi_tmpwild_vstr
		By Reference Swfi_tmpwild_vstr_length
		By Reference Swfi_long_tmp_vstr
		By Reference Swfi_long_tmp_vstr_length
	      Returning Swfi_temp_status
	    If (Success_Is in Swfi_temp_status)
		AND (Swfi_tmp_vstr_length > 2 )
	    THEN
	       ADD 1 TO Swfi_word_count
	    END-IF
	END-PERFORM.

Z300_MATCH_DESC_WORDS_END. EXIT.
Z400_WRITE_HIST_MEMO.

	%Beg
	ALLOC_END: Ent_msg_history(
		.Qname (.IdBank = Mapsh_Current_bnk_key,
			.Idloc  = NULL,
			.Idname = "*SYS_MEMO"),
			.Qtype  = "OBJTYP$_NULL",
			.Memo	= Swfi_hist_memo );
	Swfi_hist_memo = NULL ;
	%End
	ADD 1 TO Mapsh_Memo_count.



Z400_WRITE_HIST_MEMO_END. EXIT.
